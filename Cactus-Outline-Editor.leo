<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="karstenw.20160619130609.2" a="E"><vh>Code</vh>
<v t="karstenw.20160619192706.1"><vh>Tools</vh>
<v t="karstenw.20160619130856.1"><vh>@clean CactusAccessoryController.py</vh>
<v t="karstenw.20160619130933.1"><vh>CactusAccessoryController declarations</vh></v>
<v t="karstenw.20160619130933.2"><vh>class CactusOpenAsAccessoryController</vh>
<v t="karstenw.20160619130933.3"><vh>__new__</vh></v>
<v t="karstenw.20160619130933.4"><vh>init</vh></v>
<v t="karstenw.20160619130933.5"><vh>menuOpenAsType_</vh></v>
</v>
</v>
<v t="karstenw.20160619131542.1" a="E"><vh>@clean CactusTools.py</vh>
<v t="karstenw.20160619131552.1"><vh>CactusTools declarations</vh></v>
<v t="karstenw.20160619131552.2"><vh>num2ostype</vh></v>
<v t="karstenw.20160619131552.3"><vh>ostype2num</vh></v>
<v t="karstenw.20160619131552.4"><vh>makeunicode</vh></v>
<v t="karstenw.20160619131552.5"><vh>detectFileTypeAtURL</vh></v>
<v t="karstenw.20160619131552.6"><vh>detectFileTypeLocalFile</vh></v>
<v t="karstenw.20160619131552.7"><vh>readURL</vh></v>
<v t="karstenw.20160619131552.8"><vh>classifyAndReadUrl</vh></v>
<v t="karstenw.20160619131552.9"><vh>cancelContinueAlert</vh></v>
<v t="karstenw.20160619131552.10"><vh>errorDialog</vh></v>
<v t="karstenw.20160619131552.11"><vh>getFileDialog</vh></v>
<v t="karstenw.20160619131552.12"><vh>getFolderDialog</vh></v>
<v t="karstenw.20160619131552.13"><vh>NSURL2str</vh></v>
<v t="karstenw.20160619131552.14"><vh>saveAsDialog</vh></v>
<v t="karstenw.20160619131552.15"><vh>getFileProperties</vh></v>
<v t="karstenw.20160619131552.16"><vh>setFileProperties</vh></v>
<v t="karstenw.20160619131552.17"><vh>datestring_nsdate</vh></v>
<v t="karstenw.20160619131552.18"><vh>getDownloadFolder</vh></v>
<v t="karstenw.20160619131552.19"><vh>getRemotefilemodificationDate</vh></v>
<v t="karstenw.20160619131552.20"><vh>setFileModificationDate</vh></v>
<v t="karstenw.20160619131552.21"><vh>cache_url</vh></v>
<v t="karstenw.20160619131552.22"><vh>mergeURLs</vh></v>
<v t="karstenw.20160619131552.23"><vh>getURLExtension</vh></v>
</v>
</v>
<v t="karstenw.20160619193218.1"><vh>Controllers</vh>
<v t="karstenw.20160619131140.1"><vh>@clean CactusOpenURLController.py</vh>
<v t="karstenw.20160619131158.1"><vh>CactusOpenURLController declarations</vh></v>
<v t="karstenw.20160619131158.2"><vh>class OpenURLWindowController</vh>
<v t="karstenw.20160619131158.3"><vh>__new__</vh></v>
<v t="karstenw.20160619131158.4"><vh>init</vh></v>
<v t="karstenw.20160619131158.5"><vh>clearMenu_</vh></v>
<v t="karstenw.20160619131158.6"><vh>lastVisitedMenuSelection_</vh></v>
<v t="karstenw.20160619131158.7"><vh>openAsMenuSelection_</vh></v>
<v t="karstenw.20160619131158.8"><vh>windowWillClose_</vh></v>
<v t="karstenw.20160619131158.9"><vh>OK_</vh></v>
<v t="karstenw.20160619131158.10"><vh>Cancel_</vh></v>
</v>
</v>
<v t="karstenw.20160619131136.1"><vh>@clean CactusMakeCalendarController.py</vh>
<v t="karstenw.20160619131155.1"><vh>Imports and Globals</vh></v>
<v t="karstenw.20160619131155.2"><vh>daterange</vh></v>
<v t="karstenw.20160619131155.3"><vh>timerange</vh></v>
<v t="karstenw.20160619131155.4"><vh>class MakeCalendarController</vh>
<v t="karstenw.20160619131155.5"><vh>__new__</vh></v>
<v t="karstenw.20160619131155.6"><vh>init</vh></v>
<v t="karstenw.20160619131155.7"><vh>makeItSo_</vh></v>
<v t="karstenw.20160619131155.8"><vh>windowWillClose_</vh></v>
<v t="karstenw.20160619131155.9"><vh>Cancel_</vh></v>
</v>
</v>
<v t="karstenw.20160619131507.1"><vh>@clean CactusPreferenceController.py</vh>
<v t="karstenw.20160619131527.1"><vh>CactusPreferenceController declarations</vh></v>
<v t="karstenw.20160619131527.2"><vh>class CactusPreferenceController</vh>
<v t="karstenw.20160619131527.3"><vh>init</vh></v>
<v t="karstenw.20160619131527.4"><vh>windowWillClose_</vh></v>
<v t="karstenw.20160619131527.5"><vh>chooseFolder_</vh></v>
</v>
</v>
</v>
<v t="karstenw.20160619131033.1" a="E"><vh>@clean CactusDocumentTypes.py</vh>
<v t="karstenw.20160619131040.1"><vh>CactusDocumentTypes declarations</vh></v>
</v>
<v t="karstenw.20160619131050.1"><vh>@clean CactusExceptions.py</vh>
<v t="karstenw.20160619131056.1"><vh>CactusExceptions declarations</vh></v>
<v t="karstenw.20160619131056.2"><vh>class CactusBaseException</vh>
<v t="karstenw.20160619131056.3"><vh>__init__</vh></v>
</v>
<v t="karstenw.20160619192840.1" a="E"><vh>Errors</vh>
<v t="karstenw.20160619131056.4"><vh>class OPMLParseErrorException</vh></v>
<v t="karstenw.20160619131056.5"><vh>class RSSParseErrorException</vh></v>
<v t="karstenw.20160619131056.6"><vh>class XMLParseErrorException</vh></v>
<v t="karstenw.20160619131056.7"><vh>class HTMLParseErrorException</vh></v>
<v t="karstenw.20160619131056.8"><vh>class PLISTParseErrorException</vh></v>
</v>
<v t="karstenw.20160619192849.1" a="E"><vh>Messages</vh>
<v t="karstenw.20160619131056.9"><vh>class CancelledException</vh></v>
<v t="karstenw.20160619131056.10"><vh>class DoneException</vh></v>
<v t="karstenw.20160619131056.11"><vh>class DoneMessageException</vh></v>
</v>
</v>
<v t="karstenw.20160619131102.1"><vh>@clean CactusFileOpeners.py</vh>
<v t="karstenw.20160619131110.1"><vh>Imports and Globals</vh></v>
<v t="karstenw.20160619131110.2"><vh>openOPML_</vh></v>
<v t="karstenw.20160619131110.3"><vh>openOPML_withURLTag_</vh></v>
<v t="karstenw.20160619131110.4"><vh>openXML_</vh></v>
<v t="karstenw.20160619131110.5"><vh>openRSS_</vh></v>
<v t="karstenw.20160619131110.6"><vh>getPLISTValue</vh></v>
<v t="karstenw.20160619131110.7"><vh>openIML_</vh></v>
<v t="karstenw.20160619131110.8"><vh>openPLIST_</vh></v>
</v>
<v t="karstenw.20160619131220.1"><vh>@clean CactusOPML.py</vh>
<v t="karstenw.20160619131225.1"><vh>CactusOPML declarations</vh></v>
<v t="karstenw.20160619131225.2"><vh>getOutlineNodes</vh></v>
<v t="karstenw.20160619131225.3"><vh>getOPML</vh></v>
<v t="karstenw.20160619131225.4"><vh>opml_from_string</vh></v>
<v t="karstenw.20160619131225.5"><vh>parse_plist</vh></v>
<v t="karstenw.20160619131225.6"><vh>parse</vh></v>
<v t="karstenw.20160619131225.7"><vh>indentXML</vh></v>
<v t="karstenw.20160619131225.8"><vh>createSubNodesOPML</vh></v>
<v t="karstenw.20160619131225.9"><vh>getXMLNodes</vh></v>
<v t="karstenw.20160619131225.10"><vh>getXML_</vh></v>
<v t="karstenw.20160619131225.11"><vh>getHTML_</vh></v>
<v t="karstenw.20160619131225.12"><vh>xml_from_string</vh></v>
<v t="karstenw.20160619131225.13"><vh>html_from_url</vh></v>
<v t="karstenw.20160619131225.14"><vh>createSubNodesXML</vh></v>
<v t="karstenw.20160619131225.15"><vh>reorderAttribKeys</vh></v>
<v t="karstenw.20160619131225.16"><vh>createSubNodesHTML</vh></v>
<v t="karstenw.20160619131225.17"><vh>generateHTML</vh></v>
<v t="karstenw.20160619131225.18"><vh>generateXML</vh></v>
<v t="karstenw.20160619131225.19"><vh>generateRSS</vh></v>
<v t="karstenw.20160619131225.20"><vh>serializePLISTOutline_</vh></v>
<v t="karstenw.20160619131225.21"><vh>generatePLISTDict_</vh></v>
<v t="karstenw.20160619131225.22"><vh>generatePLISTArray_</vh></v>
<v t="karstenw.20160619131225.23"><vh>generateOPML</vh></v>
<v t="karstenw.20160619131225.24"><vh>photo_from_string</vh></v>
<v t="karstenw.20160619131225.25"><vh>getPhotoXML</vh></v>
</v>
<v t="karstenw.20160619131230.1"><vh>@clean CactusOutline.py</vh>
<v t="karstenw.20160619131238.1"><vh>CactusOutline declarations</vh></v>
<v t="karstenw.20160619131238.2"><vh>open_photo</vh></v>
<v t="karstenw.20160619131238.3"><vh>open_node</vh></v>
<v t="karstenw.20160619131238.4"><vh>handleEventReturnKeyOV_Event_</vh></v>
<v t="karstenw.20160619131238.5"><vh>class KWOutlineView</vh>
<v t="karstenw.20160619131238.6"><vh>awakeFromNib</vh></v>
<v t="karstenw.20160619131238.7"><vh>menuForEvent_</vh></v>
<v t="karstenw.20160619131238.8"><vh>validateMenuItem_</vh></v>
<v t="karstenw.20160619131238.9"><vh>menuNeedsUpdate_</vh></v>
<v t="karstenw.20160619131238.10"><vh>insertSafariLinks_</vh></v>
<v t="karstenw.20160619131238.11"><vh>copySelectionPython_</vh></v>
<v t="karstenw.20160619131238.12"><vh>copySelectionNodes_</vh></v>
<v t="karstenw.20160619131238.13"><vh>pasteSelectionNodes_</vh></v>
<v t="karstenw.20160619131238.14"><vh>contextMenuInclude_</vh></v>
<v t="karstenw.20160619131238.15"><vh>XdraggingEntered_</vh></v>
<v t="karstenw.20160619131238.16"><vh>XdraggingUpdated_</vh></v>
<v t="karstenw.20160619131238.17"><vh>XdraggingExited_</vh></v>
<v t="karstenw.20160619131238.18"><vh>XprepareForDragOperation_</vh></v>
<v t="karstenw.20160619131238.19"><vh>XperformDragOperation_</vh></v>
<v t="karstenw.20160619131238.20"><vh>XconcludeDragOPeration_</vh></v>
<v t="karstenw.20160619131238.21"><vh>XsetDropItem_dropChildIndex_</vh></v>
<v t="karstenw.20160619131238.22"><vh>XmouseDragged_</vh></v>
<v t="karstenw.20160619131238.23"><vh>cut_</vh></v>
<v t="karstenw.20160619131238.24"><vh>copy_</vh></v>
<v t="karstenw.20160619131238.25"><vh>paste_</vh></v>
<v t="karstenw.20160619131238.26"><vh>copyNodesToPasteboard_</vh></v>
<v t="karstenw.20160619131238.27"><vh>readNodesFromPasteboard_parent_index_</vh></v>
<v t="karstenw.20160619131238.28"><vh>draggingSourceOperationMaskForLocal_</vh></v>
<v t="karstenw.20160619131238.29"><vh>draggedImage_endedAt_operation_</vh></v>
<v t="karstenw.20160619131238.30"><vh>textDidBeginEditing_</vh></v>
<v t="karstenw.20160619131238.31"><vh>textDidChange_</vh></v>
<v t="karstenw.20160619131238.32"><vh>textDidEndEditing_</vh></v>
<v t="karstenw.20160619131238.33"><vh>cancelOperation_</vh></v>
<v t="karstenw.20160619131238.34"><vh>setWindowStatus_</vh></v>
<v t="karstenw.20160619131238.35"><vh>keyDown_</vh></v>
<v t="karstenw.20160619131238.36"><vh>moveSelectionDown</vh></v>
<v t="karstenw.20160619131238.37"><vh>moveSelectionUp</vh></v>
<v t="karstenw.20160619131238.38"><vh>indentSelection</vh></v>
<v t="karstenw.20160619131238.39"><vh>outdentSelection</vh></v>
<v t="karstenw.20160619131238.40"><vh>getSelectionItems</vh></v>
<v t="karstenw.20160619131238.41"><vh>getSelectedRow</vh></v>
<v t="karstenw.20160619131238.42"><vh>getSelectedRowIndex</vh></v>
<v t="karstenw.20160619131238.43"><vh>selectItemRows_</vh></v>
<v t="karstenw.20160619131238.44"><vh>selectItems_</vh></v>
<v t="karstenw.20160619131238.45"><vh>selectRowItem_</vh></v>
<v t="karstenw.20160619131238.46"><vh>expandSelection_</vh></v>
<v t="karstenw.20160619131238.47"><vh>expandAllSelection_</vh></v>
<v t="karstenw.20160619131238.48"><vh>collapseSelection_</vh></v>
<v t="karstenw.20160619131238.49"><vh>collapseAllSelection_</vh></v>
<v t="karstenw.20160619131238.50"><vh>collapseToParent_</vh></v>
</v>
<v t="karstenw.20160619131238.51"><vh>class NiceError</vh>
<v t="karstenw.20160619131238.52"><vh>__init__</vh></v>
<v t="karstenw.20160619131238.53"><vh>__repr__</vh></v>
</v>
<v t="karstenw.20160619131238.54"><vh>stdAction</vh></v>
<v t="karstenw.20160619131238.55"><vh>visitOutline</vh></v>
<v t="karstenw.20160619131238.56"><vh>dfid</vh></v>
<v t="karstenw.20160619131238.57"><vh>class OutlineViewDelegateDatasource</vh>
<v t="karstenw.20160619131238.58"><vh>init</vh></v>
<v t="karstenw.20160619131238.59"><vh>dealloc</vh></v>
<v t="karstenw.20160619131238.60"><vh>initWithObject_type_parentNode_</vh></v>
<v t="karstenw.20160619131238.61"><vh>setOutlineView_</vh></v>
<v t="karstenw.20160619131238.62"><vh>markDirty</vh></v>
<v t="karstenw.20160619131238.63"><vh>setController_</vh></v>
<v t="karstenw.20160619131238.64"><vh>reloadData_</vh></v>
<v t="karstenw.20160619131238.65"><vh>isSubEditor</vh></v>
<v t="karstenw.20160619131238.66"><vh>appendToRoot_Value_</vh></v>
<v t="karstenw.20160619131238.67"><vh>tableView_objectValueForTableColumn_row_</vh></v>
<v t="karstenw.20160619131238.68"><vh>numberOfRowsInTableView_</vh></v>
<v t="karstenw.20160619131238.69"><vh>outlineViewColumnDidResize_</vh></v>
<v t="karstenw.20160619131238.70"><vh>tableViewColumnDidResize_</vh></v>
<v t="karstenw.20160619131238.71"><vh>outlineView_numberOfChildrenOfItem_</vh></v>
<v t="karstenw.20160619131238.72"><vh>outlineView_child_ofItem_</vh></v>
<v t="karstenw.20160619131238.73"><vh>outlineView_isItemExpandable_</vh></v>
<v t="karstenw.20160619131238.74"><vh>outlineView_objectValueForTableColumn_byItem_</vh></v>
<v t="karstenw.20160619131238.75"><vh>outlineView_setObjectValue_forTableColumn_byItem_</vh></v>
<v t="karstenw.20160619131238.76"><vh>outlineView_acceptDrop_item_childIndex_</vh></v>
<v t="karstenw.20160619131238.77"><vh>outlineView_validateDrop_proposedItem_proposedChildIndex_</vh></v>
<v t="karstenw.20160619131238.78"><vh>outlineView_writeItems_toPasteboard_</vh></v>
<v t="karstenw.20160619131238.79"><vh>outlineView_heightOfRowByItem_</vh></v>
<v t="karstenw.20160619131238.80"><vh>outlineView_shouldEditTableColumn_item_</vh></v>
<v t="karstenw.20160619131238.81"><vh>ovUpdateItem_Key_Value_</vh></v>
<v t="karstenw.20160619131238.82"><vh>outlineViewSelectionDidChange_</vh></v>
</v>
<v t="karstenw.20160619131238.83"><vh>deleteNodes</vh></v>
<v t="karstenw.20160619131238.84"><vh>createNode</vh></v>
<v t="karstenw.20160619131238.85"><vh>moveSelectionUp</vh></v>
<v t="karstenw.20160619131238.86"><vh>moveSelectionDown</vh></v>
<v t="karstenw.20160619131238.87"><vh>moveSelectionLeft</vh></v>
<v t="karstenw.20160619131238.88"><vh>moveSelectionRight</vh></v>
<v t="karstenw.20160619131238.89"><vh>unmangleFSSPecURL</vh></v>
<v t="karstenw.20160619131238.90"><vh>cleanupURL</vh></v>
<v t="karstenw.20160619131238.91"><vh>folder2Outline</vh></v>
<v t="karstenw.20160619131238.92"><vh>makeFilePropertiesNode</vh></v>
</v>
<v t="karstenw.20160619131247.1"><vh>@clean CactusOutlineDoc.py</vh>
<v t="karstenw.20160619131254.1"><vh>CactusOutlineDoc declarations</vh></v>
<v t="karstenw.20160619131254.2"><vh>boilerplateOPML</vh></v>
<v t="karstenw.20160619131254.3"><vh>class CactusOutlineDocument</vh>
<v t="karstenw.20160619131254.4"><vh>__repr__</vh></v>
<v t="karstenw.20160619131254.5"><vh>init</vh></v>
<v t="karstenw.20160619131254.6"><vh>dealloc</vh></v>
<v t="karstenw.20160619131254.7"><vh>autosavingFileType</vh></v>
<v t="karstenw.20160619131254.8"><vh>readFromURL_ofType_error_</vh></v>
<v t="karstenw.20160619131254.9"><vh>initWithContentsOfURL_ofType_error_</vh></v>
<v t="karstenw.20160619131254.10"><vh>initWithType_error_</vh></v>
<v t="karstenw.20160619131254.11"><vh>displayName</vh></v>
<v t="karstenw.20160619131254.12"><vh>awakeFromNib</vh></v>
<v t="karstenw.20160619131254.13"><vh>XXwindowNibName</vh></v>
<v t="karstenw.20160619131254.14"><vh>fileURL</vh></v>
<v t="karstenw.20160619131254.15"><vh>setFileURL_</vh></v>
<v t="karstenw.20160619131254.16"><vh>windowControllerWillLoadNib_</vh></v>
<v t="karstenw.20160619131254.17"><vh>windowControllerDidLoadNib_</vh></v>
<v t="karstenw.20160619131254.18"><vh>calculateExpansionState_</vh></v>
<v t="karstenw.20160619131254.19"><vh>dataRepresentationOfType_</vh></v>
<v t="karstenw.20160619131254.20"><vh>loadDataRepresentation_ofType_</vh></v>
<v t="karstenw.20160619131254.21"><vh>readFromData_ofType_error_</vh></v>
<v t="karstenw.20160619131254.22"><vh>showWindows</vh></v>
<v t="karstenw.20160619131254.23"><vh>makeWindowControllers</vh></v>
<v t="karstenw.20160619131254.24"><vh>windowControllers</vh></v>
<v t="karstenw.20160619131254.25"><vh>printShowingPrintPanel_</vh></v>
</v>
<v t="karstenw.20160619131254.26"><vh>class CactusOutlineWindowController</vh>
<v t="karstenw.20160619131254.27"><vh>dealloc</vh></v>
<v t="karstenw.20160619131254.28"><vh>init</vh></v>
<v t="karstenw.20160619131254.29"><vh>finishControllerInit</vh></v>
<v t="karstenw.20160619131254.30"><vh>nsurl</vh></v>
<v t="karstenw.20160619131254.31"><vh>displayName</vh></v>
<v t="karstenw.20160619131254.32"><vh>windowWillClose_</vh></v>
<v t="karstenw.20160619131254.33"><vh>doubleClick_</vh></v>
<v t="karstenw.20160619131254.34"><vh>reloadData</vh></v>
<v t="karstenw.20160619131254.35"><vh>reloadData_</vh></v>
<v t="karstenw.20160619131254.36"><vh>reloadData_reloadChildren_</vh></v>
<v t="karstenw.20160619131254.37"><vh>loadFile_</vh></v>
<v t="karstenw.20160619131254.38"><vh>applySettings_</vh></v>
</v>
</v>
<v t="karstenw.20160619131258.1"><vh>@clean CactusOutlineNode.py</vh>
<v t="karstenw.20160619131304.1"><vh>CactusOutlineNode declarations</vh></v>
<v t="karstenw.20160619131304.2"><vh>class NodeValue</vh>
<v t="karstenw.20160619131304.3"><vh>__init__</vh></v>
<v t="karstenw.20160619131304.4"><vh>displayValue</vh></v>
<v t="karstenw.20160619131304.5"><vh>listFromDisplayValue</vh></v>
<v t="karstenw.20160619131304.6"><vh>listFromDictionary</vh></v>
<v t="karstenw.20160619131304.7"><vh>isSingleValue</vh></v>
<v t="karstenw.20160619131304.8"><vh>isMultiValue</vh></v>
</v>
<v t="karstenw.20160619131304.9"><vh>class OutlineNode</vh>
<v t="karstenw.20160619131304.10"><vh>__new__</vh></v>
<v t="karstenw.20160619131304.11"><vh>__init__</vh></v>
<v t="karstenw.20160619131304.12"><vh>__repr__</vh></v>
<v t="karstenw.20160619131304.13"><vh>dealloc</vh></v>
<v t="karstenw.20160619131304.14"><vh>setMaxLineHeight</vh></v>
<v t="karstenw.20160619131304.15"><vh>setAttributes_</vh></v>
<v t="karstenw.20160619131304.16"><vh>lineHeight</vh></v>
<v t="karstenw.20160619131304.17"><vh>calcAttributesHeight</vh></v>
<v t="karstenw.20160619131304.18"><vh>setParent_</vh></v>
<v t="karstenw.20160619131304.19"><vh>setName_</vh></v>
<v t="karstenw.20160619131304.20"><vh>setValue_</vh></v>
<v t="karstenw.20160619131304.21"><vh>addValue_</vh></v>
<v t="karstenw.20160619131304.22"><vh>removeValue_</vh></v>
<v t="karstenw.20160619131304.23"><vh>updateValue_</vh></v>
<v t="karstenw.20160619131304.24"><vh>getValueDict</vh></v>
<v t="karstenw.20160619131304.25"><vh>setComment_</vh></v>
<v t="karstenw.20160619131304.26"><vh>noOfChildren</vh></v>
<v t="karstenw.20160619131304.27"><vh>addChild_</vh></v>
<v t="karstenw.20160619131304.28"><vh>addChild_atIndex_</vh></v>
<v t="karstenw.20160619131304.29"><vh>childAtIndex_</vh></v>
<v t="karstenw.20160619131304.30"><vh>removeChild_</vh></v>
<v t="karstenw.20160619131304.31"><vh>isExpandable</vh></v>
<v t="karstenw.20160619131304.32"><vh>isRoot</vh></v>
<v t="karstenw.20160619131304.33"><vh>findRoot</vh></v>
<v t="karstenw.20160619131304.34"><vh>pathFromRoot</vh></v>
<v t="karstenw.20160619131304.35"><vh>siblingCount</vh></v>
<v t="karstenw.20160619131304.36"><vh>siblingIndex</vh></v>
<v t="karstenw.20160619131304.37"><vh>previousIndex</vh></v>
<v t="karstenw.20160619131304.38"><vh>nextIndex</vh></v>
<v t="karstenw.20160619131304.39"><vh>isFirst</vh></v>
<v t="karstenw.20160619131304.40"><vh>isLast</vh></v>
<v t="karstenw.20160619131304.41"><vh>next</vh></v>
<v t="karstenw.20160619131304.42"><vh>previous</vh></v>
<v t="karstenw.20160619131304.43"><vh>isChildOf_</vh></v>
<v t="karstenw.20160619131304.44"><vh>findFirstChildWithName_</vh></v>
<v t="karstenw.20160619131304.45"><vh>makeChildOf_</vh></v>
<v t="karstenw.20160619131304.46"><vh>moveLeft</vh></v>
<v t="karstenw.20160619131304.47"><vh>moveRight</vh></v>
<v t="karstenw.20160619131304.48"><vh>copyPython</vh></v>
<v t="karstenw.20160619131304.49"><vh>copyNodesWithRoot_</vh></v>
</v>
</v>
<v t="karstenw.20160619131441.1"><vh>@clean CactusOutlineTypes.py</vh>
<v t="karstenw.20160619131522.1"><vh>CactusOutlineTypes declarations</vh></v>
</v>
<v t="karstenw.20160619131434.1"><vh>@clean CactusOutlineWindow.py</vh>
<v t="karstenw.20160619131524.1"><vh>CactusOutlineWindow declarations</vh></v>
<v t="karstenw.20160619131524.2"><vh>class CactusOutlineWindow</vh>
<v t="karstenw.20160619131524.3"><vh>awakeFromNib</vh></v>
</v>
</v>
<v t="karstenw.20160619131515.1"><vh>@clean CactusTableDocument.py</vh>
<v t="karstenw.20160619131529.1"><vh>CactusTableDocument declarations</vh></v>
</v>
<v t="karstenw.20160619131535.1"><vh>@clean CactusTableNode.py</vh>
<v t="karstenw.20160619131549.1"><vh>class CactusTableNode</vh>
<v t="karstenw.20160619131549.2"><vh>__new__</vh></v>
<v t="karstenw.20160619131549.3"><vh>__repr__</vh></v>
<v t="karstenw.20160619131549.4"><vh>__init__</vh></v>
</v>
</v>
<v t="karstenw.20160619131607.1"><vh>@clean CactusURL.py</vh>
<v t="karstenw.20160619131622.1"><vh>CactusURL declarations</vh></v>
<v t="karstenw.20160619131622.2"><vh>NSURL2str</vh></v>
<v t="karstenw.20160619131622.3"><vh>class CactusURL</vh>
<v t="karstenw.20160619131622.4"><vh>__init__</vh></v>
<v t="karstenw.20160619131622.5"><vh>ascachepath</vh></v>
</v>
</v>
<v t="karstenw.20160619131616.1" a="E"><vh>@clean CactusVersion.py</vh>
<v t="karstenw.20160619131625.1"><vh>CactusVersion declarations</vh></v>
</v>
<v t="karstenw.20160619131631.1"><vh>@clean CactusXMLProperties.py</vh>
<v t="karstenw.20160619131636.1"><vh>CactusXMLProperties declarations</vh></v>
</v>
<v t="karstenw.20160619131957.1"><vh>@clean Finder10.py</vh>
<v t="karstenw.20160619132007.1"><vh>Finder10 declarations</vh></v>
</v>
<v t="karstenw.20160619132017.1"><vh>@clean PyRSS2Gen.py</vh>
<v t="karstenw.20160619132023.1"><vh>PyRSS2Gen declarations</vh></v>
<v t="karstenw.20160619132023.2"><vh>class WriteXmlMixin</vh>
<v t="karstenw.20160619132023.3"><vh>write_xml</vh></v>
<v t="karstenw.20160619132023.4"><vh>to_xml</vh></v>
</v>
<v t="karstenw.20160619132023.5"><vh>_element</vh></v>
<v t="karstenw.20160619132023.6"><vh>_opt_element</vh></v>
<v t="karstenw.20160619132023.7"><vh>_format_date</vh></v>
<v t="karstenw.20160619132023.8"><vh>class IntElement</vh>
<v t="karstenw.20160619132023.9"><vh>__init__</vh></v>
<v t="karstenw.20160619132023.10"><vh>publish</vh></v>
</v>
<v t="karstenw.20160619132023.11"><vh>class DateElement</vh>
<v t="karstenw.20160619132023.12"><vh>__init__</vh></v>
<v t="karstenw.20160619132023.13"><vh>publish</vh></v>
</v>
<v t="karstenw.20160619132023.14"><vh>class Category</vh>
<v t="karstenw.20160619132023.15"><vh>__init__</vh></v>
<v t="karstenw.20160619132023.16"><vh>publish</vh></v>
</v>
<v t="karstenw.20160619132023.17"><vh>class Cloud</vh>
<v t="karstenw.20160619132023.18"><vh>__init__</vh></v>
<v t="karstenw.20160619132023.19"><vh>publish</vh></v>
</v>
<v t="karstenw.20160619132023.20"><vh>class Image</vh>
<v t="karstenw.20160619132023.21"><vh>__init__</vh></v>
<v t="karstenw.20160619132023.22"><vh>publish</vh></v>
</v>
<v t="karstenw.20160619132023.23"><vh>class Guid</vh>
<v t="karstenw.20160619132023.24"><vh>__init__</vh></v>
<v t="karstenw.20160619132023.25"><vh>publish</vh></v>
</v>
<v t="karstenw.20160619132023.26"><vh>class TextInput</vh>
<v t="karstenw.20160619132023.27"><vh>__init__</vh></v>
<v t="karstenw.20160619132023.28"><vh>publish</vh></v>
</v>
<v t="karstenw.20160619132023.29"><vh>class Enclosure</vh>
<v t="karstenw.20160619132023.30"><vh>__init__</vh></v>
<v t="karstenw.20160619132023.31"><vh>publish</vh></v>
</v>
<v t="karstenw.20160619132023.32"><vh>class Source</vh>
<v t="karstenw.20160619132023.33"><vh>__init__</vh></v>
<v t="karstenw.20160619132023.34"><vh>publish</vh></v>
</v>
<v t="karstenw.20160619132023.35"><vh>class SkipHours</vh>
<v t="karstenw.20160619132023.36"><vh>__init__</vh></v>
<v t="karstenw.20160619132023.37"><vh>publish</vh></v>
</v>
<v t="karstenw.20160619132023.38"><vh>class SkipDays</vh>
<v t="karstenw.20160619132023.39"><vh>__init__</vh></v>
<v t="karstenw.20160619132023.40"><vh>publish</vh></v>
</v>
<v t="karstenw.20160619132023.41"><vh>class RSS2</vh>
<v t="karstenw.20160619132023.42"><vh>__init__</vh></v>
<v t="karstenw.20160619132023.43"><vh>publish</vh></v>
<v t="karstenw.20160619132023.44"><vh>publish_extensions</vh></v>
</v>
<v t="karstenw.20160619132023.45"><vh>class RSSItem</vh>
<v t="karstenw.20160619132023.46"><vh>__init__</vh></v>
<v t="karstenw.20160619132023.47"><vh>publish</vh></v>
<v t="karstenw.20160619132023.48"><vh>publish_extensions</vh></v>
</v>
</v>
<v t="karstenw.20160619130952.1"><vh>@clean CactusAppDelegateClass.py</vh>
<v t="karstenw.20160619130959.1"><vh>CactusAppDelegateClass declarations</vh></v>
<v t="karstenw.20160619130959.2"><vh>class Document</vh>
<v t="karstenw.20160619130959.3"><vh>__init__</vh></v>
</v>
<v t="karstenw.20160619130959.4"><vh>class CactusDocumentController</vh>
<v t="karstenw.20160619130959.5"><vh>init</vh></v>
<v t="karstenw.20160619130959.6"><vh>newDocument_</vh></v>
<v t="karstenw.20160619130959.7"><vh>runModalOpenPanel_forTypes_</vh></v>
<v t="karstenw.20160619130959.8"><vh>makeDocumentWithContentsOfURL_ofType_error_</vh></v>
</v>
<v t="karstenw.20160619130959.9"><vh>class CactusAppDelegate</vh>
<v t="karstenw.20160619130959.10"><vh>initialize</vh></v>
<v t="karstenw.20160619130959.11"><vh>awakeFromNib</vh></v>
<v t="karstenw.20160619130959.12"><vh>applicationDidFinishLaunching_</vh></v>
<v t="karstenw.20160619130959.13"><vh>applicationShouldOpenUntitledFile_</vh></v>
<v t="karstenw.20160619130959.14"><vh>applicationShouldHandleReopen_hasVisibleWindows_</vh></v>
<v t="karstenw.20160619130959.15"><vh>applicationShouldTerminate_</vh></v>
<v t="karstenw.20160619130959.16"><vh>showPreferencePanel_</vh></v>
<v t="karstenw.20160619130959.17"><vh>newTableWithRoot_</vh></v>
<v t="karstenw.20160619130959.18"><vh>newTableWithRoot_title_</vh></v>
<v t="karstenw.20160619130959.19"><vh>newTableWithRoot_fromNode_</vh></v>
<v t="karstenw.20160619130959.20"><vh>newTable_</vh></v>
<v t="karstenw.20160619130959.21"><vh>newOutline_</vh></v>
<v t="karstenw.20160619130959.22"><vh>newRoot_</vh></v>
<v t="karstenw.20160619130959.23"><vh>openURL_</vh></v>
<v t="karstenw.20160619130959.24"><vh>handleNodeMenu_</vh></v>
<v t="karstenw.20160619130959.25"><vh>openMailingList_</vh></v>
<v t="karstenw.20160619130959.26"><vh>openGithubPage_</vh></v>
<v t="karstenw.20160619130959.27"><vh>openDownloadsPage_</vh></v>
<v t="karstenw.20160619130959.28"><vh>newOutlineFromURL_Type_</vh></v>
<v t="karstenw.20160619130959.29"><vh>newBrowser_</vh></v>
<v t="karstenw.20160619130959.30"><vh>openOutlineDocument_</vh></v>
<v t="karstenw.20160619130959.31"><vh>openFile_</vh></v>
<v t="karstenw.20160619130959.32"><vh>openOPML_</vh></v>
<v t="karstenw.20160619130959.33"><vh>saveAs_</vh></v>
<v t="karstenw.20160619130959.34"><vh>getCurrentAppWindow</vh></v>
<v t="karstenw.20160619130959.35"><vh>getCurrentDocument</vh></v>
<v t="karstenw.20160619130959.36"><vh>getCurrentOutlineView</vh></v>
<v t="karstenw.20160619130959.37"><vh>outlineMenuExpand_</vh></v>
<v t="karstenw.20160619130959.38"><vh>outlineMenuExpandAll_</vh></v>
<v t="karstenw.20160619130959.39"><vh>outlineMenuCollapse_</vh></v>
<v t="karstenw.20160619130959.40"><vh>outlineMenuCollapseAll_</vh></v>
<v t="karstenw.20160619130959.41"><vh>outlineMenuCollapseToParent_</vh></v>
<v t="karstenw.20160619130959.42"><vh>makeCalendar_</vh></v>
<v t="karstenw.20160619130959.43"><vh>appendNode_CurrentDoc_</vh></v>
<v t="karstenw.20160619130959.44"><vh>makeCalendarCurrentOrNewDoc_</vh></v>
</v>
<v t="karstenw.20160619130959.45"><vh>class CactusWindowController_OLD</vh>
<v t="karstenw.20160619130959.46"><vh>init</vh></v>
<v t="karstenw.20160619130959.47"><vh>initWithObject_type_</vh></v>
<v t="karstenw.20160619130959.48"><vh>windowWillClose_</vh></v>
<v t="karstenw.20160619130959.49"><vh>doubleClick_</vh></v>
<v t="karstenw.20160619130959.50"><vh>applySettings_</vh></v>
</v>
</v>
<v t="karstenw.20160619131126.1" a="E"><vh>@clean CactusMain.py</vh>
<v t="karstenw.20160619131153.1"><vh>CactusMain declarations</vh></v>
</v>
<v t="karstenw.20160619132031.1"><vh>@clean setup.py</vh>
<v t="karstenw.20160619132037.1"><vh>setup declarations</vh></v>
</v>
<v t="karstenw.20160619200133.1"><vh>LICENSES</vh>
<v t="karstenw.20160619132244.1"><vh>@clean licence_feedreader.txt</vh></v>
<v t="karstenw.20160619132253.1"><vh>@clean license_PyRSS2Gen.txt</vh></v>
<v t="karstenw.20160619132304.1"><vh>@clean licenses_lxml.txt</vh></v>
<v t="karstenw.20160619132327.1"><vh>@clean LICENSE</vh></v>
</v>
<v t="karstenw.20160619132221.1"><vh>@clean release.sh</vh></v>
<v t="karstenw.20160619132048.1"><vh>@clean edit_all.sh</vh></v>
<v t="karstenw.20160619132317.1"><vh>@clean CHANGES</vh></v>
<v t="karstenw.20160619132335.1"><vh>@clean Makefile</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="karstenw.20160619130609.2"></t>
<t tx="karstenw.20160619130856.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619130933.1"># -*- coding: utf-8 -*-

"""This is the controller for the "Open as..." menu inside the open file dialog.
"""

import sys
import os

import objc

import Foundation
NSObject = Foundation.NSObject
NSBundle = Foundation.NSBundle


</t>
<t tx="karstenw.20160619130933.2">class CactusOpenAsAccessoryController(NSObject):
    """Just a holder for some values and an action for a open panel accessory."""

    menuOpenAs = objc.IBOutlet()

    @others
</t>
<t tx="karstenw.20160619130933.3">def __new__(cls):
    return cls.alloc()

</t>
<t tx="karstenw.20160619130933.4">def init(self):
    panel = NSBundle.loadNibNamed_owner_( u"OpenAsAccessoryView", self)
    return self

</t>
<t tx="karstenw.20160619130933.5">@objc.IBAction
def menuOpenAsType_( self, sender ):
    return None
    # return self.menuOpenAs.title()
</t>
<t tx="karstenw.20160619130952.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619130959.1">
# -*- coding: utf-8 -*-

"""
"""

import sys
import os


import pdb
import pprint
pp = pprint.pprint

import CactusVersion
kwdbg = CactusVersion.developmentversion
kwlog = CactusVersion.developmentversion

cachefolder = CactusVersion.cachefolder

import objc
super = objc.super

import Foundation
NSObject = Foundation.NSObject
NSMutableDictionary = Foundation.NSMutableDictionary
NSUserDefaults = Foundation.NSUserDefaults
NSURL = Foundation.NSURL
NSBundle = Foundation.NSBundle


import AppKit
NSApplication = AppKit.NSApplication
NSWindowController = AppKit.NSWindowController
NSDocument = AppKit.NSDocument
NSDocumentController = AppKit.NSDocumentController
NSWorkspace = AppKit.NSWorkspace

NSOutlineView = AppKit.NSOutlineView
NSWindowController = AppKit.NSWindowController

NSString = AppKit.NSString
NSMutableString = AppKit.NSMutableString

# grid styles
NSTableViewGridNone = AppKit.NSTableViewGridNone
NSTableViewSolidVerticalGridLineMask = AppKit.NSTableViewSolidVerticalGridLineMask
NSTableViewSolidHorizontalGridLineMask = AppKit.NSTableViewSolidHorizontalGridLineMask


import CactusOutlineTypes
typeOutline = CactusOutlineTypes.typeOutline
typeTable = CactusOutlineTypes.typeTable
typeBrowser = CactusOutlineTypes.typeBrowser


import CactusOutline
OutlineViewDelegateDatasource = CactusOutline.OutlineViewDelegateDatasource

import CactusOutlineDoc
CactusOutlineDocument = CactusOutlineDoc.CactusOutlineDocument

import CactusOutlineNode
OutlineNode = CactusOutlineNode.OutlineNode

import CactusOPML

import CactusPreferenceController
CactusPreferenceController = CactusPreferenceController.CactusPreferenceController


import CactusAccessoryController
CactusOpenAsAccessoryController = CactusAccessoryController.CactusOpenAsAccessoryController


import CactusTools
NSURL2str = CactusTools.NSURL2str


import CactusOpenURLController
OpenURLWindowController = CactusOpenURLController.OpenURLWindowController


import CactusMakeCalendarController
MakeCalendarController = CactusMakeCalendarController.MakeCalendarController




</t>
<t tx="karstenw.20160619130959.10"># defined in mainmenu

def initialize(self):
    if kwlog:
        print "CactusAppDelegate.initialize()"
    self.visitedURLs = []
    self.documentcontroller = None
    # default settings for preferences
    userdefaults = NSMutableDictionary.dictionary()

    # application tab
    userdefaults.setObject_forKey_([],          u'lastURLsVisited')
    userdefaults.setObject_forKey_(False,       u'optCache')
    userdefaults.setObject_forKey_(cachefolder, u'txtCacheFolder')
    userdefaults.setObject_forKey_("2",         u'txtNoOfMaxRowLines')
    userdefaults.setObject_forKey_("40",        u'txtNoOfRecentURLs')
    userdefaults.setObject_forKey_(False,       u'optNewDocumentOnStart')

    # outline tab
    userdefaults.setObject_forKey_(True,        u'optAlternateLines')
    userdefaults.setObject_forKey_(True,        u'optHLines')
    userdefaults.setObject_forKey_(True,        u'optVLines')
    userdefaults.setObject_forKey_(True,        u'optVariableRowHeight')
    userdefaults.setObject_forKey_(False,       u'optCommentColumn')
    userdefaults.setObject_forKey_(False,       u'optTypeColumn')
    userdefaults.setObject_forKey_(True,        u'optValueColumn')

    # opml tab
    userdefaults.setObject_forKey_("",          u'txtUserEmail')
    userdefaults.setObject_forKey_("",          u'txtUserName')
    userdefaults.setObject_forKey_(True,        u'optAnimateOPMLOpen')
    userdefaults.setObject_forKey_(False,       u'optMergeComment')
    userdefaults.setObject_forKey_(True,        u'optIgnoreDotFiles')

    # html tab
    userdefaults.setObject_forKey_("&lt;!DOCTYPE html&gt;",   u'menDoctype')
    userdefaults.setObject_forKey_("utf-8",     u'menEncoding')
    userdefaults.setObject_forKey_("2",         u'txtIndent')

    # xml tab
    userdefaults.setObject_forKey_(False,        u'optIMLAutodetect')
    userdefaults.setObject_forKey_(False,        u'optOPMLAutodetect')
    userdefaults.setObject_forKey_(False,        u'optRSSAutodetect')
    userdefaults.setObject_forKey_(False,        u'optHTMLAutodetect')
    userdefaults.setObject_forKey_(False,        u'optPLISTAutodetect')

    # rss tab
    userdefaults.setObject_forKey_(False,        u'optRSSOpenEnclosure')

    # itunes tab
    userdefaults.setObject_forKey_(False,        u'optIMLImportSystemLibraries')

    NSUserDefaults.standardUserDefaults().registerDefaults_(userdefaults)
    self.preferenceController = None


</t>
<t tx="karstenw.20160619130959.11">def awakeFromNib(self):
    defaults = NSUserDefaults.standardUserDefaults()
    self.visitedURLs = defaults.arrayForKey_( u"lastURLsVisited" )

</t>
<t tx="karstenw.20160619130959.12">def applicationDidFinishLaunching_(self, notification):
    if kwlog:
        print "CactusAppDelegate.applicationDidFinishLaunching_()"
    self.documentcontroller = CactusDocumentController.alloc().init()
    app = NSApplication.sharedApplication()
    app.activateIgnoringOtherApps_(True)

</t>
<t tx="karstenw.20160619130959.13">@objc.IBAction
def applicationShouldOpenUntitledFile_( self, sender ):
    if kwlog:
        print "CactusAppDelegate.applicationShouldOpenUntitledFile_()"
    defaults = NSUserDefaults.standardUserDefaults()
    return defaults.objectForKey_( u"optNewDocumentOnStart" )

</t>
<t tx="karstenw.20160619130959.14">def applicationShouldHandleReopen_hasVisibleWindows_( self, theApplication, flag ):
    if kwlog:
        print "CactusAppDelegate.applicationShouldHandleReopen_hasVisibleWindows_()"
    # this is needed to prevent creating an untitled document when clicking the dock
    #
    # should really be in the (not yet existent) preferences
    return False

</t>
<t tx="karstenw.20160619130959.15">def applicationShouldTerminate_(self, aNotification):
    """Store preferences before quitting
    """

    defaults = NSUserDefaults.standardUserDefaults()
    defaults.setObject_forKey_(self.visitedURLs,
                               u'lastURLsVisited')
    return True

</t>
<t tx="karstenw.20160619130959.16">####

@objc.IBAction
def showPreferencePanel_(self, sender):
    if self.preferenceController == None:
        self.preferenceController = CactusPreferenceController.alloc().init()
    self.preferenceController.showWindow_( self.preferenceController )

</t>
<t tx="karstenw.20160619130959.17">####

""" """
def newTableWithRoot_(self, root):
    if kwlog:
        print "CactusAppDelegate.newTableWithRoot_()"
    self.newTableWithRoot_title_(root, None)

</t>
<t tx="karstenw.20160619130959.18">def newTableWithRoot_title_(self, root, title):
    if kwlog:
        print "DEPRECATED CactusAppDelegate.newTableWithRoot_title_()"
    # find owning controller here and pass on
    if not title:
        title = u"Table Editor"
    doc = Document(title, root)
    CactusWindowController_OLD.alloc().initWithObject_type_(doc, typeTable)

</t>
<t tx="karstenw.20160619130959.19">def newTableWithRoot_fromNode_(self, root, parentNode):
    if kwlog:
        print "DEPRECATED CactusAppDelegate.newTableWithRoot_fromNode_()"
    title = "Unnamed"
    if parentNode:
        title = parentNode.name
    doc = Document(title, root, parentNode)
    CactusWindowController_OLD.alloc().initWithObject_type_(doc, typeTable)

</t>
<t tx="karstenw.20160619130959.2">class Document(object):
    @others
</t>
<t tx="karstenw.20160619130959.20">""" """

# menu "New Table"
@objc.IBAction
def newTable_(self, sender):
    if kwlog:
        print "DEPRECATED CactusAppDelegate.newTable_()"
    doc = Document("Untitled Table", None)
    CactusWindowController_OLD.alloc().initWithObject_type_(doc, typeTable)

</t>
<t tx="karstenw.20160619130959.21">####

# menu "New Outline"
@objc.IBAction
def newOutline_(self, sender):
    if kwlog:
        print "DEPRECATED CactusAppDelegate.newOutline_()"

</t>
<t tx="karstenw.20160619130959.22"># UNUSED
@objc.IBAction
def newRoot_(self, sender):
    pass

</t>
<t tx="karstenw.20160619130959.23"># menu "Open URL"
@objc.IBAction
def openURL_(self, sender):
    """Open new "URL opener". Currently no measures against opening multiple of those...
    """
    OpenURLWindowController().init()

</t>
<t tx="karstenw.20160619130959.24">####

@objc.IBAction
def handleNodeMenu_(self, sender):
    if kwlog:
        print "CactusAppDelegate.handleNodeMenu_(%s)" % repr(sender)
    app = NSApplication.sharedApplication()
    win = app.keyWindow()
    if win:
        print "Save As...", win.title()
        windelg = win.delegate()
        if windelg:
            ov = windelg.outlineView
            name = sender.title()
            print name
            if name == u"Move up":
                ov.moveSelectionUp()
            elif name == u"Move down":
                ov.moveSelectionDown()
            elif name == u"Move left":
                ov.outdentSelection()
            elif name == u"Move right":
                ov.indentSelection()

            elif name == u"Include":
                pass
            elif name == u"Open in Browser":
                pass
            elif name == u"Open in QT-Player":
                pass
            elif name == u"Open linked opml":
                pass


</t>
<t tx="karstenw.20160619130959.25">@objc.IBAction
def openMailingList_(self, sender):
    workspace= NSWorkspace.sharedWorkspace()
    url = NSURL.URLWithString_( u"http://groups.google.com/group/cactus-outliner-dev" )
    workspace.openURL_( url )

</t>
<t tx="karstenw.20160619130959.26">@objc.IBAction
def openGithubPage_(self, sender):
    workspace= NSWorkspace.sharedWorkspace()
    url = NSURL.URLWithString_( u"https://github.com/karstenw/Cactus-opml-Outliner" )
    workspace.openURL_( url )

</t>
<t tx="karstenw.20160619130959.27">@objc.IBAction
def openDownloadsPage_(self, sender):
    workspace= NSWorkspace.sharedWorkspace()
    url = NSURL.URLWithString_( u"http://goo.gl/EALQi" )
    workspace.openURL_( url )

</t>
<t tx="karstenw.20160619130959.28">####


def newOutlineFromURL_Type_(self, url, type_):
    if kwlog:
        print "CactusAppDelegate.newOutlineFromURL_Type_(\n\t%s\m\t%s )" % (
            repr(url), repr(type_))

    if not isinstance(url, NSURL):
        url = NSURL.URLWithString_( url )
    # just check for local files
    docc = NSDocumentController.sharedDocumentController()
    localurl = url.isFileURL()
    loaded = True
    if localurl:
        loaded = docc.documentForURL_( url )
    if not loaded or not localurl:
        doc, err = docc.makeDocumentWithContentsOfURL_ofType_error_(url,
                                                                   type_,
                                                                   None)

</t>
<t tx="karstenw.20160619130959.29"># UNUSED but defined in class
@objc.IBAction
def newBrowser_(self, sender):
    if kwlog:
        print "CactusAppDelegate.newBrowser_()"
    # The CactusWindowController_OLD instance will retain itself,
    # so we don't (have to) keep track of all instances here.
    doc = Document("Untitled Outline", None)
    CactusWindowController_OLD.alloc().initWithObject_type_(doc, typeOutline)

</t>
<t tx="karstenw.20160619130959.3"># this should be replaced by NSDocument.
def __init__(self, fileorurl, rootNode, parentNode=None):
    self.fileorurl = fileorurl
    if not rootNode:
        self.root = OutlineNode("__ROOT__", "", None, typeOutline)
    else:
        self.root = rootNode
    self.parentNode = parentNode



</t>
<t tx="karstenw.20160619130959.30">@objc.IBAction
def openOutlineDocument_(self, sender):
    if kwlog:
        print "CactusAppDelegate.openOutlineDocument_()"
    docctrl = NSDocumentController.sharedDocumentController()
    docctrl.openDocument_(sender)

</t>
<t tx="karstenw.20160619130959.31">@objc.IBAction
def openFile_(self, sender):
    if kwlog:
        print "DEPRECATED CactusAppDelegate.openFile_()"
    # this is ugly
    f = getFileDialog(multiple=True)
    if f:
        for opmlFile in f:
            print "Reading OPML '%s'" % (opmlFile.encode("utf-8"),)
            fob = open(opmlFile, 'r')
            folder, filename = os.path.split(opmlFile)
            s = fob.read()
            fob.close()
            d = CactusOPML.opml_from_string(s)
            if d:
                root = CactusOutlineDoc.openOPML_( d )
                doc = Document(opmlFile, root)
                CactusWindowController_OLD.alloc().initWithObject_type_(doc, typeOutline)

                print "Reading OPML '%s' Done." % (opmlFile.encode("utf-8"),)
            else:
                print "Reading OPML '%s' FAILED." % (opmlFile.encode("utf-8"),)

</t>
<t tx="karstenw.20160619130959.32">def openOPML_(self, rootOPML):
    if kwlog:
        print "CactusAppDelegate.openOPML_()"
    """This builds the node tree and opens a window."""
    #
    #  Split this up.
    def getChildrenforNode(node, children):
        for c in children:
            name = c.get('name', '')
            childs = c.get('children', [])
            content = c.get('attributes', "")
            if content == "":
                content = {u'value': ""}
            content.pop('text', None)
            if content:
                l = []
                for k, v in content.items():
                    l.append( (k, v) )
                content = l
            else:
                content = u""

            newnode = OutlineNode(name, content, node, typeOutline)
            node.addChild_( newnode )
            if len(childs) &gt; 0:
                getChildrenforNode(newnode, childs)
            del newnode

    ######

    # root node for document; never visible,
    # always outline type (even for tables)
    root = OutlineNode("__ROOT__", "", None, typeOutline)

    # get opml head section
    if rootOPML['head']:

        # the outline head node
        head = OutlineNode("head", "", root, typeOutline)
        root.addChild_( head )
        for headnode in rootOPML['head']:
            k, v = headnode
            #v = {'value': v}

            node = OutlineNode(k, v, head, typeOutline)
            #print "HEAD:", node.name
            head.addChild_( node )

    # fill in missing opml attributes here
    # created, modified
    #
    # how to propagate expansionstate, windowState?
    # make a document object and pass that to docdelegate?
    #
    # get opml body section
    if rootOPML['body']:

        # the outline body node
        body = OutlineNode("body", "", root, typeOutline)
        root.addChild_( body )

        for item in rootOPML['body']:
            name = item['name']
            children = item['children']

            # make table here
            content = item.get('attributes', "")
            content.pop('text', None)
            if content:
                l = []
                for k, v in content.items():
                    l.append( (k, v) )
                content = l
            else:
                content = u""

            node = OutlineNode(name, content, body, typeOutline)
            body.addChild_( node )
            if len(children) &gt; 0:
                try:
                    getChildrenforNode( node, children )
                except Exception, err:
                    print err
                    pp(children)
                    pp(item)
    return root

</t>
<t tx="karstenw.20160619130959.33">@objc.IBAction
def saveAs_(self, sender):
    if kwlog:
        print "DEPRECATED CactusAppDelegate.saveAs_()"
    print "Save As..."
    app = NSApplication.sharedApplication()
    win = app.keyWindow()
    if win:
        print "Save As...", win.title()
        windelg = win.delegate()
        if windelg:
            path = windelg.path
            model = windelg.model
            root = model.root

            f = saveAsDialog( path )
            if f:
                rootOPML = opml.generateOPML( root, indent=1, expansion={} )
                e = etree.ElementTree( rootOPML )
                fob = open(f, 'w')
                e.write(fob, encoding="utf-8", xml_declaration=True, method="xml" )
                fob.close()

</t>
<t tx="karstenw.20160619130959.34">def getCurrentAppWindow(self):
    if kwlog:
        print "CactusAppDelegate.getCurrentAppWindow()"
    return NSApplication.sharedApplication().keyWindow()

</t>
<t tx="karstenw.20160619130959.35">def getCurrentDocument(self):
    if kwlog:
        print "CactusAppDelegate.getCurrentDocument()"
    return NSDocumentController.sharedDocumentController().currentDocument()

</t>
<t tx="karstenw.20160619130959.36">def getCurrentOutlineView(self):
    if kwlog:
        print "CactusAppDelegate.getCurrentOutlineView()"
    doc = self.getCurrentDocument()
    if isinstance(doc, CactusOutlineDocument):
        win = self.getCurrentAppWindow()
        ctrl = win.windowController()
        return ctrl.outlineView
    return False

</t>
<t tx="karstenw.20160619130959.37">@objc.IBAction
def outlineMenuExpand_(self, sender):
    if kwlog:
        print "CactusAppDelegate.outlineMenuExpand_()"
    ov = self.getCurrentOutlineView()
    if ov:
        ov.expandSelection_(sender)

</t>
<t tx="karstenw.20160619130959.38">@objc.IBAction
def outlineMenuExpandAll_(self, sender):
    if kwlog:
        print "CactusAppDelegate.outlineMenuExpandAll_()"
    ov = self.getCurrentOutlineView()
    if ov:
        ov.expandAllSelection_(sender)

</t>
<t tx="karstenw.20160619130959.39">@objc.IBAction
def outlineMenuCollapse_(self, sender):
    if kwlog:
        print "CactusAppDelegate.outlineMenuCollapse_()"
    ov = self.getCurrentOutlineView()
    if ov:
        ov.collapseSelection_(sender)

</t>
<t tx="karstenw.20160619130959.4"># instantiated in NIB
class CactusDocumentController(NSDocumentController):
    @others
</t>
<t tx="karstenw.20160619130959.40">@objc.IBAction
def outlineMenuCollapseAll_(self, sender):
    if kwlog:
        print "CactusAppDelegate.outlineMenuCollapseAll_()"
    ov = self.getCurrentOutlineView()
    if ov:
        ov.collapseAllSelection_(sender)

</t>
<t tx="karstenw.20160619130959.41">@objc.IBAction
def outlineMenuCollapseToParent_(self, sender):
    if kwlog:
        print "CactusAppDelegate.outlineMenuCollapseToParent_()"
    ov = self.getCurrentOutlineView()
    if ov:
        ov.collapseToParent_(sender)

</t>
<t tx="karstenw.20160619130959.42">@objc.IBAction
def makeCalendar_(self, sender):
    if kwlog:
        print "CactusAppDelegate.makeCalendar_()"
    MakeCalendarController().init()

</t>
<t tx="karstenw.20160619130959.43">def appendNode_CurrentDoc_(self, node, doc):
    pass

</t>
<t tx="karstenw.20160619130959.44">def makeCalendarCurrentOrNewDoc_(self, params):
    if kwlog:
        print "CactusAppDelegate.makeCalendarCurrentOrNewDoc_()"
    doc = self.getCurrentDocument()

    if not doc:
        app = NSApplication.sharedApplication()
        delg = app.delegate()
        docctrl = delg.documentcontroller
        docctrl.newDocument_(None)

    doc = self.getCurrentDocument()

    if not doc:
        return

    if not isinstance(doc, CactusOutlineDocument):
        return

    win = self.getCurrentAppWindow()
    ctrl = win.windowController()
    ov = ctrl.outlineView
    
    # find the root for the calendar
    # either the current selected node or append after last body child
    rootNode = ov.getSelectedRow()
    if rootNode == -1:
        r = ctrl.rootNode
        children = r.children
        head = body = False
        for child in children:
            if child.name == u"body":
                rootNode = body = child
                break
        if not body:
            rootNode = OutlineNode("body", "", r, typeOutline)
            r.addChild_( rootNode )

    # 
    cal, conf = params

    separateMonth = conf["separateMonth"]
    separateWeek = conf["separateWeek"]
    separateYear = conf["separateYear"]
    weekMonday = conf["weekMonday"]
    weekNumber = conf["weekNumber"]

    includeDays = conf["includeDays"]
    calDayFormat = conf["calDayFormat"]
    calHourFormat = conf["calHourFormat"]
    calMonthFormat = conf["calMonthFormat"]
    calTitle = conf["calTitle"]
    calWeekFormat = conf["calWeekFormat"]
    calYearFormat = conf["calYearFormat"]
    includeHours = conf["includeHours"]

    theRoot = rootNode.rootNode
    calRoot = OutlineNode(calTitle, "", rootNode, typeOutline, theRoot)
    
    rootNode.addChild_( calRoot )
    
    years = cal.keys()
    
    try:    years.remove('year')
    except  Exception:  pass
    
    years.sort()
    
    for yearNumber in years:
        monthd = cal[yearNumber]['months']
        yearDT = cal[yearNumber]['dt']
        yearString = yearDT.strftime(calYearFormat)

        yearNode = OutlineNode(yearString, "", calRoot, typeOutline, theRoot)
        calRoot.addChild_( yearNode )

        months = monthd.keys()
        months.sort()

        for monthNumber in months:
            daysd = monthd[monthNumber]['days']
            monthDT = monthd[monthNumber]['dt']
            monthString = monthDT.strftime(calMonthFormat)

            monthNode = OutlineNode(monthString, "", yearNode, typeOutline, theRoot)
            yearNode.addChild_( monthNode )

            days = daysd.keys()
            days.sort()
            
            currWeeks = set()
            currWeek = None

            for day in days:
                dayItemss = daysd[day]['day']
                dayDT = daysd[day]['dt']
                dayString = dayDT.strftime(calDayFormat)

                isoYear, isoWeek, isoDay = dayDT.isocalendar()

                parentNode = monthNode

                if separateWeek:
                    if not isoWeek in currWeeks:
                        currWeeks.add( isoWeek)
                        weekString = dayDT.strftime(calWeekFormat)
                        currWeek = OutlineNode( weekString,
                                                # "Week: " + str(isoWeek),
                                                "",
                                                parentNode,
                                                typeOutline,
                                                theRoot)
                        parentNode.addChild_( currWeek )
                    parentNode = currWeek

                dayNode = OutlineNode( dayString,
                                       "",
                                       parentNode,
                                       typeOutline,
                                       theRoot)
                parentNode.addChild_( dayNode )

                dayItems = list(dayItemss)
                dayItems.sort()
                
                if includeHours:
                    for dayItemDT in dayItems:
                        dayItemName = dayItemDT.strftime(calHourFormat)

                        itemNode = OutlineNode( dayItemName,
                                                "",
                                                dayNode,
                                                typeOutline,
                                                theRoot)
                        dayNode.addChild_( itemNode )
    ov.expandItem_( rootNode )
    ov.expandItem_( calRoot )
    ov.reloadData()

</t>
<t tx="karstenw.20160619130959.45">class CactusWindowController_OLD(NSWindowController):
    menRowLines = objc.IBOutlet()
    outlineView = objc.IBOutlet()
    optAlterLines = objc.IBOutlet()
    optCommentVisible = objc.IBOutlet()
    optHLines = objc.IBOutlet()
    optNameVisible = objc.IBOutlet()
    optTypeVisible = objc.IBOutlet()
    optValueVisible = objc.IBOutlet()
    optVariableRow = objc.IBOutlet()
    optVLines = objc.IBOutlet()
    txtOutlineType = objc.IBOutlet()
    txtWindowStatus = objc.IBOutlet()

    
    @others
</t>
<t tx="karstenw.20160619130959.46">#
# Can this be made for dual-use? outlines and tables?

# the actual base class is NSWindowController
# outlineView

def init(self):
    # outline or table here
    # tables are outlines with no children
    if kwlog:
        print "DEPRECATED CactusWindowController_OLD.init()"
    doc = Document("Untitled", None)
    return self.initWithObject_type_(doc, typeOutline)

</t>
<t tx="karstenw.20160619130959.47">def initWithObject_type_(self, obj, theType):
    """This controller is used for outline and table windows."""

    if kwlog:
        print "DEPRECATED CactusWindowController_OLD.initWithObject_type_()"

    if theType == typeOutline:
        self = self.initWithWindowNibName_("OutlineEditor")
        title = u"Unnamed Outline"

    elif theType == typeTable:
        self = self.initWithWindowNibName_("TableEditor")
        title = u"Unnamed Table"
    elif theType == typeBrowser:
        pass #title = u"Browser"
    else:
        pass

    self.rowLines = 2

    if not obj:
        obj = Document(title, None)

    self.path = objc.ivar()
    self.root = objc.ivar()
    self.parentNode = objc.ivar()
    self.variableRowHeight = objc.ivar()

    if isinstance(obj, Document):
        self.path = obj.fileorurl
        self.root = obj.root
        self.parentNode = obj.parentNode

    # get window name from url or path
    if os.path.exists(self.path):
        fld, fle = os.path.split(self.path)
        title = fle
    elif self.path:
        title = self.path
    else:
        # keep unnamed title
        pass

    self.window().setTitle_( title )

    self.model = OutlineViewDelegateDatasource.alloc().initWithObject_type_parentNode_(
                                            self.root, theType, self.parentNode )

    # this is evil
    self.root.model = self.model

    self.model.setController_( self )
    self.outlineView.setDataSource_(self.model)
    self.outlineView.setDelegate_(self.model)

    self.outlineView.setTarget_(self)
    # self.outlineView.setDoubleAction_("doubleClick:")

    self.window().makeFirstResponder_(self.outlineView)

    # store them columns
    self.nameColumn = self.outlineView.tableColumnWithIdentifier_( "name" )
    self.typeColumn = self.outlineView.tableColumnWithIdentifier_( "type" )
    self.valueColumn = self.outlineView.tableColumnWithIdentifier_( "value" )
    self.commentColumn = self.outlineView.tableColumnWithIdentifier_( "comment" )

    # set name column to wrap
    self.nameColumn.dataCell().setWraps_( True )
    self.commentColumn.dataCell().setWraps_( True )
    self.valueColumn.dataCell().setWraps_( True )

    # defaults to name &amp; value visible, type &amp; comment invisible
    typeVisible = self.optTypeVisible.setState_( False )
    commentVisible = self.optCommentVisible.setState_( False )
    self.applySettings_(None)

    self.showWindow_(self)

    # The window controller doesn't need to be retained (referenced)
    # anywhere, so we pretend to have a reference to ourselves to avoid
    # being garbage collected before the window is closed. The extra
    # reference will be released in self.windowWillClose_()
    self.retain()
    return self

</t>
<t tx="karstenw.20160619130959.48">def windowWillClose_(self, notification):
    if kwlog:
        print "DEPRECATED CactusWindowController_OLD.windowWillClose_()"
    # see comment in self.initWithObject_type_()
    #
    # check model.dirty
    #
    self.autorelease()

</t>
<t tx="karstenw.20160619130959.49">def doubleClick_(self, sender):
    # Open a new browser window for each selected expandable item
    print "DEPRECATED doubleClick_()"

</t>
<t tx="karstenw.20160619130959.5">def init(self):
    if kwlog:
        print "CactusDocumentController.init()"
    self = super( CactusDocumentController, self).init()
    self.selectedType = u"automatic"
    self.urllist = []
    return self

</t>
<t tx="karstenw.20160619130959.50">@objc.IBAction
def applySettings_(self, sender):
    """target of the apply button. sets some tableview settings.
    """
    # rowHeight
    self.variableRowHeight = self.optVariableRow.state()

    # menus - NOT YET USED
    # formatChoice = self.menFormat.state()
    # behaviourChoice = self.menBehaviour.state()

    # alterLines
    alterLines = self.optAlterLines.state()
    self.outlineView.setUsesAlternatingRowBackgroundColors_( alterLines )

    # columns
    tableColumns = self.outlineView.tableColumns()

    if self.optNameVisible.state():
        if not self.nameColumn in tableColumns:
            self.outlineView.addTableColumn_(self.nameColumn)
    else:
        if self.nameColumn in tableColumns:
            self.outlineView.removeTableColumn_(self.nameColumn)

    if self.optTypeVisible.state():
        if not self.typeColumn in tableColumns:
            self.outlineView.addTableColumn_(self.typeColumn)
    else:
        if self.typeColumn in tableColumns:
            self.outlineView.removeTableColumn_(self.typeColumn)

    if self.optValueVisible.state():
        if not self.valueColumn in tableColumns:
            self.outlineView.addTableColumn_(self.valueColumn)
    else:
        if self.valueColumn in tableColumns:
            self.outlineView.removeTableColumn_(self.valueColumn)

    if self.optCommentVisible.state():
        if not self.commentColumn in tableColumns:
            self.outlineView.addTableColumn_(self.commentColumn)
    else:
        if self.commentColumn in tableColumns:
            self.outlineView.removeTableColumn_(self.commentColumn)

    # lines per row menu
    try:
        l = self.menRowLines.title()
        l = int(l)
        self.rowLines = l
    except StandardError, err:
        print "\nERROR  ---  Menu Row lines '%'" % repr(l)
        self.rowLines = 4
        self.menRowLines.setTitle_( u"4" )

    # grid style
    gridStyleMask = self.outlineView.gridStyleMask()
    newStyle = NSTableViewGridNone
    if self.optVLines.state():
        newStyle |= NSTableViewSolidVerticalGridLineMask
    if self.optHLines.state():
        newStyle |= NSTableViewSolidHorizontalGridLineMask
    self.outlineView.setGridStyleMask_(newStyle)

    #
    self.outlineView.reloadData()
    self.outlineView.setNeedsDisplay_( True )
</t>
<t tx="karstenw.20160619130959.6">def newDocument_(self, sender):
    return super( CactusDocumentController, self).newDocument_(sender)

</t>
<t tx="karstenw.20160619130959.7">def runModalOpenPanel_forTypes_( self, panel, types ):
    if kwlog:
        print
        print "CactusDocumentController.runModalOpenPanel_forTypes_()",
    self.selectedType = "automatic"
    extensionCtrl = CactusOpenAsAccessoryController.alloc().init()

    if extensionCtrl.menuOpenAs != None:
        panel.setAccessoryView_( extensionCtrl.menuOpenAs )
    result = super( CactusDocumentController, self).runModalOpenPanel_forTypes_( panel, None)

    if result:
        self.selectedType = extensionCtrl.menuOpenAs.title()
        self.urllist = set([NSURL2str(t) for t in panel.URLs()])
    if kwlog:
        pp(result) 
        print
    return result

</t>
<t tx="karstenw.20160619130959.8">def makeDocumentWithContentsOfURL_ofType_error_(self, url, theType, err):
    if kwlog:
        print "CactusDocumentController.makeDocumentWithContentsOfURL_ofType_error_()"

    if self.selectedType != "automatic" and len(self.urllist) &gt; 0:
        u = NSURL2str( url )
        if u in self.urllist:
            self.urllist.discard( u )
            theType = self.selectedType
    result, error = super( CactusDocumentController, self).makeDocumentWithContentsOfURL_ofType_error_( url, theType, err)
    # self.selectedType = "automatic"
    return (result, error)


</t>
<t tx="karstenw.20160619130959.9">class CactusAppDelegate(NSObject):
    @others
</t>
<t tx="karstenw.20160619131033.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619131040.1"># -*- coding: utf-8 -*-

# the different document types

#
# ATTENTIOON: changing the string here (CactusOPMLType = u'OPML File') needs to
# change the string in "OpenURL.nib" window too!
#


# works
CactusOPMLType = u'OPML File'
CactusOPMLFileExtensions = [ 'opml' ]
CactusOPMLOSTypes = [ 'OPML', '****' ]


# works --- so far
CactusRSSType = u'RSS File'
CactusRSSFileExtensions = [ 'rss' ]
CactusRSSOSTypes = [ '****' ]


# an outliner as a xml editor
CactusXMLType = u'XML File'
CactusXMLFileExtensions = [ 'xml', '*' ]
CactusXMLOSTypes = [ '****' ]

# an outliner as a html editor
CactusHTMLType = u'HTML File'
CactusHTMLFileExtensions = [ 'html', 'htm', 'tpl' ]
CactusHTMLOSTypes = [ '****' ]

# an outliner as a property list editor
CactusPLISTType = u'PLIST File'
CactusPLISTFileExtensions = [ 'plist', 'webarchive' ]
CactusPLISTOSTypes = [ '****' ]

# an outliner as a iTunes Library editor
CactusIMLType = u'iTunes XML File'
# CactusIMLFileExtensions = [ 'xml' ]
CactusIMLOSTypes = [ '****' ]

#

CactusDocumentTypesSet = set( (CactusOPMLType,
                               CactusRSSType,
                               CactusXMLType,
                               CactusHTMLType,
                               CactusPLISTType) )


# plists don't need to be xml files
CactusDocumentXMLBasedTypesSet = set( (CactusOPMLType,
                                       CactusRSSType,
                                       CactusXMLType) )

#
# from here on it's wishful thinking
#

# don't know yet, if this is useful
#
# seems like a useful export format
# prefs indent spaces/tabs, encoding, columns
CactusTEXTType = u'Text File'
CactusTEXTFileExtensions = [ 'txt', ]
CactusTEXTOSTypes = [ 'TEXT', 'utxt' ]


# I want to have... but is it useful?
#
# seems like a useful export format
CactusSQLITEType = u'Sqlite File'
CactusSQLITEFileExtensions = [ 'sqlite', ]
CactusSQLITEOSTypes = [ '****' ]


# I want to have...
#
# after researching it a bit, this seems like a lost art...
#CactusXOXOType = u'XOXO File'
#CactusXOXOFileExtensions = [ 'xoxo', 'xml', 'html']
#CactusXOXOOSTypes = [ '****' ]


# haven't looked into it yet
CactusEMACSORGType = u'ORG File'
CactusEMACSORGFileExtensions = [ 'org', ]
CactusEMACSORGOSTypes = [  ]


# this is on the delete list; to be replaced by an outline
#CactusTABLEType = u'Cactus Table'
#CactusTABLEFileExtensions = [ 'table', ]
#CactusTABLEOSTypes = [ '****' ]

</t>
<t tx="karstenw.20160619131050.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619131056.1"># CactusExceptions.py

#
# Exceptions
#

import sys

</t>
<t tx="karstenw.20160619131056.10">class DoneException(CactusBaseException):
    pass

</t>
<t tx="karstenw.20160619131056.11">class DoneMessageException(CactusBaseException):
    pass
</t>
<t tx="karstenw.20160619131056.2">class CactusBaseException(StandardError):
    @others
</t>
<t tx="karstenw.20160619131056.3">def __init__(self, *args):
    Exception.__init__(self, *args)
    self.wrapped_exc = sys.exc_info()

</t>
<t tx="karstenw.20160619131056.4">#
# parsing documents

class OPMLParseErrorException(CactusBaseException):
    """An OPML source could not be parsed."""
    pass

</t>
<t tx="karstenw.20160619131056.5">class RSSParseErrorException(CactusBaseException):
    """A RSS source could not be parsed."""
    pass

</t>
<t tx="karstenw.20160619131056.6">class XMLParseErrorException(CactusBaseException):
    """A XML source could not be parsed."""
    pass

</t>
<t tx="karstenw.20160619131056.7">class HTMLParseErrorException(CactusBaseException):
    """A HTML source could not be parsed."""
    pass

</t>
<t tx="karstenw.20160619131056.8">class PLISTParseErrorException(CactusBaseException):
    """A PLIST source could not be parsed."""
    pass



</t>
<t tx="karstenw.20160619131056.9">#
# Misc
class CancelledException(CactusBaseException):
    pass

</t>
<t tx="karstenw.20160619131102.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619131110.1">
# -*- coding: utf-8 -*-


"""
"""

import sys
import os

import binascii

import traceback

import pdb
import pprint
pp = pprint.pprint

import CactusVersion
kwdbg = CactusVersion.developmentversion
kwlog = CactusVersion.developmentversion


import time

import feedparser

import objc

import AppKit
NSString = AppKit.NSString
NSMutableString = AppKit.NSMutableString
NSUserDefaults = AppKit.NSUserDefaults

import CactusTools
num2ostype = CactusTools.num2ostype
ostype2num = CactusTools.ostype2num

import CactusOutlineTypes
typeOutline = CactusOutlineTypes.typeOutline
typeTable = CactusOutlineTypes.typeTable
typeBrowser = CactusOutlineTypes.typeBrowser

import CactusDocumentTypes
CactusOPMLType = CactusDocumentTypes.CactusOPMLType
CactusRSSType = CactusDocumentTypes.CactusRSSType
CactusXMLType = CactusDocumentTypes.CactusXMLType
CactusHTMLType = CactusDocumentTypes.CactusHTMLType
CactusPLISTType = CactusDocumentTypes.CactusPLISTType
CactusIMLType = CactusDocumentTypes.CactusIMLType

import CactusTools
NSURL2str = CactusTools.NSURL2str

import CactusOutlineNode
OutlineNode = CactusOutlineNode.OutlineNode



</t>
<t tx="karstenw.20160619131110.2">def openOPML_(rootOPML):
    if kwlog:
        print "openOPML_()"
    return openOPML_withURLTag_(rootOPML, False)

</t>
<t tx="karstenw.20160619131110.3">def openOPML_withURLTag_(rootOPML, urltag):
    if kwlog:
        print "CactusFileOpeners.openOPML_withURLTag_()"
    """This builds the node tree and returns the root node."""

    defaults = NSUserDefaults.standardUserDefaults()
    optMergeComment = defaults.objectForKey_( u'optMergeComment')

    #
    #  Split this up.
    def getChildrenforNode(node, children, root):
        for c in children:
            name = c.get('name', '')
            childs = c.get('children', [])
            content = c.get('attributes', "")
            comment = ""
            if content == "":
                content = {u'value': ""}
            content.pop('text', None)
            if content:
                if optMergeComment:
                    c = content.get('comment', u'')
                    n = content.get('_note', u'')
                    if 'comment' in content:
                        if '_note' in content:
                            content['_note'] = u"%s\n%s" % (n, c)
                        else:
                            content['_note'] = c
                        content.pop('comment', None)

                        
                l = []
                for k, v in content.items():
                    if k == "comment":
                        if not optMergeComment:
                            comment = v
                    elif k == "_note":
                        if optMergeComment:
                            comment = v
                    else:
                        l.append( (k, v) )
                content = l
            else:
                content = u""

            newnode = OutlineNode(name, content, node, typeOutline, root)
            if comment:
                newnode.setComment_( comment )
            node.addChild_( newnode )
            if len(childs) &gt; 0:
                getChildrenforNode(newnode, childs, root)

    ######

    # root node for document; never visible,
    # always outline type (even for tables)
    root = OutlineNode("__ROOT__", "", None, typeOutline, None)

    # get opml head section
    if rootOPML['head']:

        # the outline head node
        head = OutlineNode("head", "", root, typeOutline, root)
        root.addChild_( head )
        headtags = set()
        for headnode in rootOPML['head']:
            k, v = headnode
            headtags.add( k )
            head.addChild_( OutlineNode(k, v, head, typeOutline, root) )

        if urltag:
            if 'cactusUrl' not in headtags:
                # add this url only once, not for every open
                head.addChild_(OutlineNode('cactusUrl', unicode(urltag), head,
                               typeOutline, root))
    # fill in missing opml attributes here
    # created, modified
    #
    # how to propagate expansionstate, windowState?
    # make a document object and pass that to docdelegate?
    #
    # get opml body section
    if rootOPML['body']:
        # the outline body node
        body = OutlineNode("body", "", root, typeOutline, root)
        root.addChild_( body )

        for item in rootOPML['body']:
            name = item['name']
            children = item['children']
            comment = ""


            # make table here
            content = item.get('attributes', "")
            content.pop('text', None)
            if content:
                l = []

                if optMergeComment:

                    c = content.get('comment', u'')
                    n = content.get('_note', u'')
                    if 'comment' in content:
                        if '_note' in content:
                            content['_note'] = u"%s\n%s" % (n, c)
                        else:
                            content['_note'] = c
                        content.pop('comment', None)

                for k, v in content.items():
                    if k == "comment":
                        if not optMergeComment:
                            comment = v
                    elif k == "_note":
                        if optMergeComment:
                            comment = v
                    else:
                        l.append( (k, v) )

                content = l
            else:
                content = u""

            node = OutlineNode(name, content, body, typeOutline, root)
            if comment:
                node.setComment_( comment )
            # node.setValue_(content)
            body.addChild_( node )
            if len(children) &gt; 0:
                try:
                    getChildrenforNode( node, children, root )
                except Exception, err:
                    print err
                    pp(children)
                    pp(item)
    #title = os
    return root, CactusOPMLType

</t>
<t tx="karstenw.20160619131110.4">def openXML_( rootXML):

    if kwlog:
        s = repr(rootXML)
        if len(s) &gt; 90:
            s = s[:91]
        print "openXML_( %s )" % s

    """This builds the node tree and returns the root node."""

    #
    #  Split this up.
    def getChildrenforNode(node, children, root):
        for c in children:
            name = c.get('name', '')
            tail = c.get('tail', '')
            childs = c.get('children', [])
            content = c.get('attributes', "")
            txt = c.get('text', "")

            if content == "":
                content = {u'': ""}

            if content or tail:
                l = []
                for k, v in content.items():
                    l.append( (k, v) )
                if tail != u"":
                    l.append( (u'tail', tail) )
                content = l
            else:
                content = u""

            try:
                newnode = OutlineNode(name, content, node, typeOutline, root)
            except Exception, err:
                print "\n\nERROR in openXML_()"
                tb = unicode(traceback.format_exc())
                print err
                print
                print tb
                print

            if txt != "":
                newnode.setComment_( txt )

            node.addChild_( newnode )
            try:
                n = len(childs)
            except Exception, err:
                print
                print err
            if len(childs) &gt; 0:
                getChildrenforNode(newnode, childs, root)
            newnode.release()
            del newnode

    ######

    # root node for document; never visible,
    # always outline type (even for tables)
    root = OutlineNode("__ROOT__", "", None, typeOutline, None)

    rootXML = rootXML
    name = rootXML['name']
    children = rootXML['children']
    content = rootXML.get('attributes', "")
    txt = rootXML.get('text', "")

    if content:
        l = []
        for k, v in content.items():
            l.append( (k, v) )
        content = l
    else:
        content = u""

    node = OutlineNode(name, content, root, typeOutline, root)
    if txt:
        node.setComment_( txt )

    root.addChild_( node )

    try:
        n = len(children)
    except Exception, err:
        print "CactusFileOpeners.openXML_() ERROR"
        print "childen has no length attribute!"
        print type(children)
        print err


    if n &gt; 0:
        try:
            getChildrenforNode( node, children, root )
        except Exception, err:
            print "\n\nERROR in openXML_()"
            tb = unicode(traceback.format_exc())
            print err
            print
            print tb
            print
            # pp(children)
    #title = os
    return root, CactusXMLType


</t>
<t tx="karstenw.20160619131110.5">def openRSS_(url):

    url = NSURL2str(url)

    if kwlog:
        s = repr(url)
        if len(s) &gt; 90:
            s = s[:91]
        print "openRSS_( %s )" % repr(s)
    d = feedparser.parse( url, agent=CactusVersion.user_agent )

    # make basic nodes
    root = OutlineNode("__ROOT__", "", None, typeOutline, None)

    head = OutlineNode("head", "", root, typeOutline, root)
    root.addChild_( head )

    body = OutlineNode("body", "", root, typeOutline, root)
    root.addChild_( body )

    #
    # head
    #

    # feed = docs, generator, language, link, microblog_archive,
    # microblog_endday, microblog_filename, microblog_startday, microblog_url,
    # published, subtitle, title, updated, cloud
    if d.feed:
        keys = """author authors category comments cloud description docs enclosure
                  generator generator_detail guid image language link links
                  microblog_archive microblog_endday microblog_filename
                  microblog_startday microblog_url published pubDate source
                  subtitle subtitle_detail sy_updatefrequency sy_updateperiod
                  title title_detail updated updated_parsed""".split()

        feedkeys = d.feed.keys()
        feedkeys.sort()

        for k in feedkeys:

            if k in ('links', 'tags', 'updated_parsed', 'authors'):
                continue

            v = d.feed[k]
            if type(v) in (list,):
                if len(v) &gt; 1:
                    print "Large header list"
                    print k
                    print repr(v)
                elif len(v) == 1:
                    v = v[0]

            if type(v) not in (str, unicode, NSString,
                               NSMutableString, objc.pyobjc_unicode):
                if isinstance(v, dict):
                    l = []
                    for key, val in v.items():
                        l.append( (key,val) )
                    v = l
                elif type(v) == time.struct_time:
                    v = time.asctime(v)
                else:
                    # if k in ('',)
                    if 1:
                        print "ATTENTION RSS Head values"
                        print "KEY:", k
                        print "TYPE:", type(v)
                        print "REPR:", repr(v)
                        print
                    v = repr(v)
            node = OutlineNode(k, v, head, typeOutline, root)
            head.addChild_( node )

    otherkeys = d.keys()

    if 'feed' in otherkeys:
        otherkeys.remove("feed")

    if 'entries' in otherkeys:
        otherkeys.remove("entries")

    otherkeys.sort()
    for k in otherkeys:
        v = d[k]
        if type(v) not in (str, unicode, NSString, NSMutableString,
                           objc.pyobjc_unicode,
                           dict, feedparser.FeedParserDict):
            v = repr(v)
        node = OutlineNode(k, v, head, typeOutline, root)
        head.addChild_( node )

    if 0:
        # encoding
        if 'encoding' in d:
            node = OutlineNode('encoding', d.encoding, head, typeOutline, root)
            head.addChild_( node )

        # bozo
        if 'bozo' in d:
            node = OutlineNode('bozo', str(d.bozo), head, typeOutline, root)
            head.addChild_( node )

        # etag
        if 'etag' in d:
            node = OutlineNode('etag', d.etag, head, typeOutline, root)
            head.addChild_( node )

        # headers dict
        if 'headers' in d:
            node = OutlineNode('headers', d.headers, head, typeOutline, root)
            head.addChild_( node )

        # href
        if 'href' in d:
            node = OutlineNode('href', d.href, head, typeOutline, root)
            head.addChild_( node )

        # namespaces
        if 'namespaces' in d:
            node = OutlineNode('namespaces', d.namespaces, head, typeOutline, root)
            head.addChild_( node )

        # version
        if 'version' in d:
            node = OutlineNode('version', d.version, head, typeOutline, root)
            head.addChild_( node )

    #
    # body
    #
    for entry in d.entries:
        name = ""
        if 'title' in entry:
            # name = entry.title + "\n\n"
            name = entry.title
        elif 'summary' in entry:
            name = entry.summary

        #if 'summary' in entry:
        #    name = name + entry.summary
        value = entry
        killkeys = ['links', 'authors', 'tags']
        value['type'] = "rssentry"
        #
        # killing items which have a dictionary as value
        #
        # too much detail for now
        for k, v in value.items():
            if isinstance(v, dict) or isinstance(v, list) :
                killkeys.append(k)
            if k.endswith('_parsed'):
                killkeys.append(k)

        # extract enclosure
        if 'links' in value:
            links = value['links']
            for link in links:
                rel = link.get('rel', False)
                if rel == 'enclosure':
                    s = "%s&lt;&lt;&lt;%s;%s" % (link.get('url',''),
                                        str(link.get('length','')),
                                        link.get('type', ""))
                    value['enclosure'] = s
        for k in killkeys:
            value.pop( k, None )

        node = OutlineNode(name, value, body, typeOutline, root)
        body.addChild_( node )
    return root, CactusRSSType


</t>
<t tx="karstenw.20160619131110.6">def getPLISTValue(nsvalue):
    valueType = type(nsvalue)
    value = ""
    valueTypeName = ""
    if valueType == bool:
        # print "BOOLVALUE: '%s' --&gt; '%s'" % (repr(nsvalue), repr(bool(nsvalue)) )
        value = repr(bool(nsvalue))
        valueTypeName = [ ('cactusNodeType', "bool") ]

    # number
    elif hasattr(nsvalue, "descriptionWithLocale_"):
        value = unicode(nsvalue.descriptionWithLocale_( None ))
        valueTypeName = [ ('cactusNodeType', "number") ]

    # data
    elif hasattr(nsvalue, "bytes"):
        value = unicode( binascii.hexlify(nsvalue.bytes()) )
        valueTypeName = [ ('cactusNodeType', "data") ]

    # anything else
    elif hasattr(nsvalue, "description"):
        value = unicode(nsvalue.description())
        valueTypeName = [ ('cactusNodeType', "string") ]
    else:
        print "BOGATIVE VALUE TYPE:", repr(valueType)
        print
    return value, valueTypeName


</t>
<t tx="karstenw.20160619131110.7">#
cactusBool = [ ('cactusNodeType', "bool") ]
cactusString = [ ('cactusNodeType', "string") ]
cactusNumber = [ ('cactusNodeType', "number") ]
cactusDictionary = [ ('cactusNodeType', "dictionary") ]
cactusData = [ ('cactusNodeType', "data") ]


def openIML_( nsdict ):
    if kwlog:
        s = repr(nsdict)
        if len(s) &gt; 90:
            s = s[:91]
        print "openPLIST_( %s )" % s

    """This builds the node tree and returns the root node."""

    ######

    # root node for document; never visible,
    # always outline type (even for tables)
    root = OutlineNode("__ROOT__", "", None, typeOutline, None)

    progressCount = 0

    def getTracks( nsdict, parent ):
        i = 0
        id_trackname = {}
        for trackItem in nsdict:
            trackData = nsdict.objectForKey_( trackItem )
            trackNode = OutlineNode("", "", parent, typeOutline, root)
            trackAttributes = []
            trackName = ""
            trackAlbum = ""
            trackArtist = ""
            trackID = ""
            for trackAttribute in trackData:
                nsvalue = trackData.objectForKey_( trackAttribute )
                value, valueType = getPLISTValue( nsvalue)

                if trackAttribute == u"Track ID":
                    trackID = value

                elif trackAttribute == u"Name":
                    trackName = value

                elif trackAttribute == u"Album":
                    trackAlbum = value

                elif trackAttribute in (u"File Creator", u"File Type"):
                    value = num2ostype( long(value) )

                elif trackAttribute == u"Total Time":
                    # formatted duration hack
                    secondsTotal = int(value) / 1000.0
                    minutes = secondsTotal // 60
                    seconds = round(secondsTotal % 60, 1)
                    seconds = "0%.1f" % seconds
                    value = u"%i:%s" % (minutes, seconds[-4:])

                trackAttributes.append( (trackAttribute, value) )
                id_trackname[ trackID ] = trackName

            # itemName = u"%s - %s" % (trackAlbum, trackName)
            itemName = trackName

            # print repr(itemName)
            trackNode.setName_( itemName )
            trackNode.setValue_( trackAttributes )
            trackNode.setMaxLineHeight()
            parent.addChild_( trackNode )
            i += 1
            if i % 1000 == 0:
                sys.stdout.write('.')
                sys.stdout.flush()
                if i % 100000 == 0:
                    sys.stdout.write('\n')
                    sys.stdout.flush()
        print
        print "%i Tracks." % i
        return id_trackname

    def makePlaylistNode( name, curPlaylist, value, parent, root, type_):
        if name in curPlaylist:

            if type_ == cactusData:
                value = unicode( binascii.hexlify(value.bytes()) )
            elif type_ == cactusBool:
                value = repr(bool(value))
            elif type_ == cactusNumber:
                value = unicode(value.descriptionWithLocale_( None ))
            # elif type_ == cactusDictionary:

            node = OutlineNode( name,
                                type_,
                                parent,
                                typeOutline,
                                root)
            if value != "":
                node.setComment_( unicode(value) )
            parent.addChild_( node )
            return node

    def getPlaylists( nsdict, parent, id_track_dict ):

        defaults = NSUserDefaults.standardUserDefaults()
        optIMLImportSystemLibraries = defaults.objectForKey_( u'optIMLImportSystemLibraries')
        systemLibraries = (
            u"Library",
            u"Music",
            u"Movies",
            u"Podcasts",
            u"iTunes U",
            u"Books")

        root = parent.rootNode
        # add the standard playlist attributes
        i = 0
        for playlist in nsdict:

            #
            # check for keys not listed here
            #

            playlistName = playlist.get( u"Name", "")

            playlistNode = OutlineNode( playlistName, "", parent, typeOutline, root)
            parent.addChild_( playlistNode )

            # drop out if AllItems pref is false
            if playlistName in systemLibraries:
                if not optIMLImportSystemLibraries:
                    continue

            makePlaylistNode( u"Name", playlist,
                              playlistName,
                              playlistNode, root, cactusString)

            makePlaylistNode( u"Master", playlist,
                              playlist.get( u"Master", "False"),
                              playlistNode, root, cactusBool)

            makePlaylistNode( u"Playlist ID", playlist,
                              playlist.get( u"Playlist ID", "0"),
                              playlistNode, root, cactusNumber)

            makePlaylistNode( u"Playlist Persistent ID", playlist,
                              playlist.get( u"Playlist Persistent ID", ""),
                              playlistNode, root, cactusString)

            makePlaylistNode( u"Parent Persistent ID", playlist,
                              playlist.get( u"Playlist Persistent ID", ""),
                              playlistNode, root, cactusString)

            makePlaylistNode( u"Distinguished Kind", playlist,
                              playlist.get( u"Distinguished Kind", 0),
                              playlistNode, root, cactusNumber)

            makePlaylistNode( u"Movies", playlist,
                              playlist.get( u"Movies", "False"),
                              playlistNode, root, cactusBool)

            makePlaylistNode( u"Podcasts", playlist,
                              playlist.get( u"Podcasts", "False"),
                              playlistNode, root, cactusBool)

            makePlaylistNode( u"iTunesU", playlist,
                              playlist.get( u"iTunesU", "False"),
                              playlistNode, root, cactusBool)

            makePlaylistNode( u"Audiobooks", playlist,
                              playlist.get( u"Audiobooks", "False"),
                              playlistNode, root, cactusBool)

            makePlaylistNode( u"Smart Info", playlist,
                              playlist.get( u"Smart Info", ""),
                              playlistNode, root, cactusData)

            makePlaylistNode( u"Smart Criteria", playlist,
                              playlist.get( u"Smart Criteria", ""),
                              playlistNode, root, cactusData)

            makePlaylistNode( u"Visible", playlist,
                              playlist.get( u"Visible", "False"),
                              playlistNode, root, cactusBool)

            makePlaylistNode( u"All Items", playlist,
                              playlist.get( u"All Items", "False"),
                              playlistNode, root, cactusBool)

            makePlaylistNode( u"Folder", playlist,
                              playlist.get( u"Folder", "False"),
                              playlistNode, root, cactusBool)

            plnode = makePlaylistNode( u"Playlist Items", playlist,
                                       "",
                                       playlistNode, root, cactusDictionary)

            i += 7
            j = 0

            if not u"Playlist Items" in playlist:
                continue

            for item in playlist[ u"Playlist Items" ]:
                id_ = item[u"Track ID"]
                attrs = {
                    u"Track ID": id_
                }

                name = id_track_dict.get(unicode(id_), "###Noname###")

                node = OutlineNode( name, attrs, plnode, typeOutline, root)
                plnode.addChild_( node )

                i += 1
                j += 1
                if i % 1000 == 0:
                    sys.stdout.write('.')
                    sys.stdout.flush()
                    if i % 100000 == 0:
                        sys.stdout.write('\n')
                        sys.stdout.flush()
            print
            print "%s has %i Playlist Items." % (repr(playlistName), j)
        print
        print "A total of %i Playlist Items." % i


    def dispatchLevel( nsdict, parent, root, progressCount ):
        # array or dict
        i = 0
        selfTypeName = "None"
        if hasattr(nsdict, "objectForKey_"):
            selfTypeName = "dictionary"
        elif hasattr(nsdict, "objectAtIndex_"):
            selfTypeName = "list"

        selfType = [ ('cactusNodeType', selfTypeName) ]

        parent.setValue_( selfType )

        id_track_dict = {}
        for key in nsdict:
            i += 1

            typeAttribute = ""
            value = ""

            if selfTypeName == "list":
                itemName = str(i)
                nsvalue = nsdict.objectAtIndex_( i-1 )
            else:
                itemName = unicode(key)
                nsvalue = nsdict.objectForKey_(key)

            valueType = type(nsvalue)

            node = OutlineNode(itemName, "", parent, typeOutline, root)

            if itemName == u"Tracks":
                id_track_dict = getTracks( nsvalue, node )
            elif itemName == u"Playlists":
                getPlaylists( nsvalue, node, id_track_dict )
            else:
                # dict
                if hasattr(nsvalue, "objectForKey_"):
                    progressCount = dispatchLevel(nsvalue, node, root, progressCount)

                # list
                elif hasattr(nsvalue, "objectAtIndex_"):
                    progressCount = dispatchLevel(nsvalue, node, root, progressCount)

                else:
                    value, valueType = getPLISTValue( nsvalue )
                    node.setValue_( valueType )
            node.setComment_( value )
            parent.addChild_(node)
            progressCount += 1
            if kwlog:
                if progressCount % 1000 == 0:
                    sys.stdout.write('.')
                    sys.stdout.flush()
                    if progressCount % 100000 == 0:
                        sys.stdout.write('\n')
                        sys.stdout.flush()
        return progressCount

    dispatchLevel(nsdict, root, root, progressCount)
    return root, CactusIMLType

</t>
<t tx="karstenw.20160619131110.8">###
#
# plist tools
#
###

def openPLIST_( nsdict ):

    if kwlog:
        s = repr(nsdict)
        if len(s) &gt; 90:
            s = s[:91]
        print "openPLIST_( %s )" % s

    """This builds the node tree and returns the root node."""

    ######

    # check for itunes xml file
    defaults = NSUserDefaults.standardUserDefaults()
    optIMLAutodetect = defaults.objectForKey_( u'optIMLAutodetect')

    if optIMLAutodetect:
        isIML = True
        for key in (u"Music Folder", u"Application Version",
                    u"Tracks", u"Playlists",
                    u"Minor Version", u"Major Version"):
            if key not in nsdict:
                isIML = False
                break
        if isIML:
            return openIML_( nsdict )

    # root node for document; never visible,
    # always outline type (even for tables)
    root = OutlineNode("__ROOT__", "", None, typeOutline, None)

    progressCount = 0

    def dispatchLevel( nsdict, parent, root, progressCount ):
        # array or dict
        i = 0

        if hasattr(nsdict, "objectForKey_"):
            selfTypeName = "dictionary"
        elif hasattr(nsdict, "objectAtIndex_"):
            selfTypeName = "list"
        else:
            selfTypeName = "None"
        selfType = [ ('cactusNodeType', selfTypeName) ]

        parent.setValue_( selfType )

        for key in nsdict:
            i += 1

            typeAttribute = ""
            value = ""

            if selfTypeName == "list":
                itemName = str(i)
                nsvalue = nsdict.objectAtIndex_( i-1 )
            else:
                itemName = unicode(key)
                nsvalue = nsdict.objectForKey_(key)

            valueType = type(nsvalue)

            node = OutlineNode(itemName, "", parent, typeOutline, root)

            if valueType == bool:
                # print "BOOLVALUE: '%s' --&gt; '%s'" % (repr(nsvalue), repr(bool(nsvalue)) )
                value = repr(bool(nsvalue))
                node.setValue_( [ ('cactusNodeType', "bool") ] )

            # dict
            elif hasattr(nsvalue, "objectForKey_"):
                dispatchLevel(nsvalue, node, root, progressCount)

            # list
            elif hasattr(nsvalue, "objectAtIndex_"):
                dispatchLevel(nsvalue, node, root, progressCount)

            # number
            elif hasattr(nsvalue, "descriptionWithLocale_"):
                value = unicode(nsvalue.descriptionWithLocale_( None ))
                node.setValue_( [ ('cactusNodeType', "number") ] )

            # data
            elif hasattr(nsvalue, "bytes"):
                value = unicode( binascii.hexlify(nsvalue.bytes()) )
                node.setValue_( [ ('cactusNodeType', "data") ] )

            # anything else
            elif hasattr(nsvalue, "description"):
                value = unicode(nsvalue.description())
                node.setValue_( [ ('cactusNodeType', "string") ] )
            else:
                print "BOGATIVE VALUE TYPE:", repr(valueType)
                print

            node.setComment_( value )
            parent.addChild_(node)
            progressCount += 1
            if kwlog:
                if progressCount % 1000 == 0:
                    sys.stdout.write('.')
                    sys.stdout.flush()
                    if progressCount % 100000 == 0:
                        sys.stdout.write('\n')
                        sys.stdout.flush()
    dispatchLevel(nsdict, root, root, progressCount)
    return root, CactusPLISTType
</t>
<t tx="karstenw.20160619131126.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619131136.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619131140.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619131153.1">
# -*- coding: utf-8 -*-


import PyObjCTools

import PyObjCTools.AppHelper
AppHelper = PyObjCTools.AppHelper


import CactusVersion
devVersion = CactusVersion.developmentversion

import CactusOutline
import CactusAppDelegateClass

import CactusOutlineWindow

import CactusOutlineDoc
import CactusTableDocument

if CactusVersion.developmentversion:
    import PyObjCTools.Debugging
    PyObjCTools.Debugging.installVerboseExceptionHandler()

if __name__ == "__main__":
    AppHelper.runEventLoop(pdb=devVersion)


</t>
<t tx="karstenw.20160619131155.1"># -*- coding: utf-8 -*-

"""
"""

import datetime

import pprint
pp = pprint.pprint

import pdb

import objc

import Foundation
NSObject = Foundation.NSObject
NSURL = Foundation.NSURL
NSMutableDictionary = Foundation.NSMutableDictionary
NSUserDefaults = Foundation.NSUserDefaults
NSBundle = Foundation.NSBundle


import AppKit
NSApplication = AppKit.NSApplication
NSWindowController = AppKit.NSWindowController


import CactusOutlineDoc



</t>
<t tx="karstenw.20160619131155.2">def daterange(start, stop, step_days=1):
    # John Machin 
    # http://stackoverflow.com/questions/1060279/iterating-through-a-range-of-dates-in-python
    current = start
    step = datetime.timedelta(step_days)
    if step_days &gt; 0:
        #forward
        while current &lt;= stop:
            yield current
            current += step
    elif step_days &lt; 0:
        # backward
        while current &gt;= stop:
            yield current
            current += step
    else:
        raise ValueError("daterange() step_days argument must not be zero")

</t>
<t tx="karstenw.20160619131155.3">def timerange( starttime, stoptime, increment):
    # generate the hourly entries per day
    # attn 22:00-02:00 becomes 2 ranges:
    # 00:00-02:00 and 22:00-00:00
    current = starttime
    delta = datetime.timedelta(minutes=increment)
    if stoptime &lt; starttime:
        pass
    else:
        yield current
        while current &lt; stoptime:
            current += delta
            # print "CURRENT:", current
            yield current

</t>
<t tx="karstenw.20160619131155.4">#
# Calendar Creator Interface
#
class MakeCalendarController(NSWindowController):
    """Present a dialog for entering a URL for http document retrieval."""

    dateFrom = objc.IBOutlet()
    dateUntil = objc.IBOutlet()
    includeDays = objc.IBOutlet()
    includeHours = objc.IBOutlet()
    includeHoursFrom = objc.IBOutlet()
    includeHoursIntervall = objc.IBOutlet()
    includeHoursUntil = objc.IBOutlet()
    separateMonth = objc.IBOutlet()
    separateWeek = objc.IBOutlet()
    separateYear = objc.IBOutlet()
    weekMonday = objc.IBOutlet()
    weekNumber = objc.IBOutlet()
    calDayFormat = objc.IBOutlet()
    calHourFormat = objc.IBOutlet()
    calMonthFormat = objc.IBOutlet()
    calTitle = objc.IBOutlet()
    calWeekFormat = objc.IBOutlet()
    calYearFormat = objc.IBOutlet()

    @others
</t>
<t tx="karstenw.20160619131155.5">def __new__(cls):
    return cls.alloc()

</t>
<t tx="karstenw.20160619131155.6">def init(self):
    self = self.initWithWindowNibName_("CalendarCreator")
    window = self.window()
    window.setDelegate_( self )
    window.setTitle_( u"Define Calendar Spec" )
    
    window.makeFirstResponder_(self.dateFrom)

    self.showWindow_(self)
    self.retain()
    return self

</t>
<t tx="karstenw.20160619131155.7">@objc.IBAction
def makeItSo_(self, sender):

    def getInt(n):
        s = 0
        try:
            s = int(n)
        except ValueError:
            return 0
        return s

    def calInsert( cal, date):
        y = date.year
        m = date.month
        d = date.day
        
        cur = cal
        if not y in cur:
            cur[y] = {'dt':date,
                      'months':{}}
        cur = cur[y]['months']

        if not m in cur:
            cur[m] = {'dt':date,
                      'days': {}}
        cur = cur[m]['days']
        
        if not d in cur:
            cur[d] = {'dt': date,
                      'day': set()}
        cur = cur[d]['day']
        
        if isinstance(date, datetime.datetime):
            #h = str(date.hour).zfill(2)
            #m = str(date.minute).zfill(2)
            #s = u"%s:%s" % (h,m)
            #if not date in cur:
            #    cur[s] = date
            cur.add( date )

    dateFrom = datetime.datetime.strptime(
                    str(self.dateFrom.dateValue())[:10],
                    "%Y-%m-%d")
    yearStart = dateFrom.year
    monthStart = dateFrom.month

    dateUntil = datetime.datetime.strptime(
                    str(self.dateUntil.dateValue())[:10],
                    "%Y-%m-%d")
    yearEnd = dateUntil.year
    monthEnd = dateUntil.month

    includeDays = bool(int(self.includeDays.state()))
    includeHours = bool(int(self.includeHours.state()))
    includeHoursFrom = getInt(str(self.includeHoursFrom.stringValue()))
    includeHoursIntervall = getInt(str(self.includeHoursIntervall.stringValue()))
    includeHoursUntil = getInt(str(self.includeHoursUntil.stringValue()))

    params = {
        "separateMonth": bool(int(self.separateMonth.state())),
        "separateWeek": bool(int(self.separateWeek.state())),
        "separateYear": bool(int(self.separateYear.state())),
        "weekMonday": bool(int(self.weekMonday.state())),
        "weekNumber": bool(int(self.weekNumber.state())),

        "includeDays": bool(int(self.includeDays.state())),
        "calDayFormat": self.calDayFormat.stringValue(),
        "calHourFormat": self.calHourFormat.stringValue(),
        "calMonthFormat": self.calMonthFormat.stringValue(),
        "calTitle": self.calTitle.stringValue(),
        "calWeekFormat": self.calWeekFormat.stringValue(),
        "calYearFormat": self.calYearFormat.stringValue(),
        "includeHours": bool(int(self.includeHours.state()))
        }

    days = daterange(dateFrom, dateUntil, step_days=1)
    result = []
    
    cal = {}
    
    for day in days:
        dayStart = day.replace(hour=includeHoursFrom)
        dayEnd = day.replace(hour=includeHoursUntil)
        
        if includeHours:
            dayItems = timerange( dayStart, dayEnd, includeHoursIntervall)
            for dayItem in dayItems:
                #result.append( dayItem )
                calInsert( cal, dayItem)
        else:
            # result.append( day.date() )
            # pp( cal )
            calInsert( cal, day.date())

    app = NSApplication.sharedApplication()
    delg = app.delegate()
    # delg.makeCalendarCurrentOrNewDoc_( cal )
    self.close()
    delg.makeCalendarCurrentOrNewDoc_( (cal, params) )

</t>
<t tx="karstenw.20160619131155.8">def windowWillClose_(self, notification):
    self.autorelease()

</t>
<t tx="karstenw.20160619131155.9">@objc.IBAction
def Cancel_(self, sender):
    self.close()

</t>
<t tx="karstenw.20160619131158.1"># -*- coding: utf-8 -*-

"""
"""



import objc

import Foundation
NSObject = Foundation.NSObject
NSURL = Foundation.NSURL
NSMutableDictionary = Foundation.NSMutableDictionary
NSUserDefaults = Foundation.NSUserDefaults
NSBundle = Foundation.NSBundle


import AppKit
NSApplication = AppKit.NSApplication
NSWindowController = AppKit.NSWindowController


import CactusDocumentTypes
CactusOPMLType = CactusDocumentTypes.CactusOPMLType
CactusRSSType = CactusDocumentTypes.CactusRSSType
CactusXMLType = CactusDocumentTypes.CactusXMLType


</t>
<t tx="karstenw.20160619131158.10">@objc.IBAction
def Cancel_(self, sender):
    self.close()

</t>
<t tx="karstenw.20160619131158.2">#
# Open URL Delegate
#
class OpenURLWindowController(NSWindowController):
    """Present a dialog for entering a URL for http document retrieval."""

    label = objc.IBOutlet()
    textfield = objc.IBOutlet()
    menuLastVisited = objc.IBOutlet()
    menuOpenAs = objc.IBOutlet()

    @others
</t>
<t tx="karstenw.20160619131158.3"># class defined in OpenURL.nib
# OpenURLWindowController(NSWindowController)
#
#
# actions
#
# OK:
# Cancel:
# clearMenu:
# lastVisitedMenuSelection:
#
# label
# textfield
#
#
# visitedURLs
# menuLastVisited
def __new__(cls):
    return cls.alloc()

</t>
<t tx="karstenw.20160619131158.4">def init(self):
    self = self.initWithWindowNibName_("OpenURL")
    window = self.window()
    window.setDelegate_( self )
    window.setTitle_( u"Open URL" )
    window.makeFirstResponder_(self.textfield)

    app = NSApplication.sharedApplication()
    delg = app.delegate()

    self.readAsType = CactusOPMLType
    self.visitedURLs = delg.visitedURLs[:]
    self.menuLastVisited.removeAllItems()

    defaults = NSUserDefaults.standardUserDefaults()
    self.noOfRecentURLs = 40
    try:
        self.noOfRecentURLs = int(defaults.objectForKey_( u'txtNoOfRecentURLs'))
    except StandardError, err:
        print "ERROR reading defaults.", repr(err)

    # cap recentURLs to max size
    if len(self.visitedURLs) &gt; self.noOfRecentURLs:
        self.visitedURLs = self.visitedURLs[:self.noOfRecentURLs]

    for url in self.visitedURLs:
        self.menuLastVisited.addItemWithTitle_( url )
    self.showWindow_(self)
    self.retain()
    return self

</t>
<t tx="karstenw.20160619131158.5">@objc.IBAction
def clearMenu_(self, sender):
    self.visitedURLs = []
    app = NSApplication.sharedApplication()
    delg = app.delegate()
    delg.visitedURLs = self.visitedURLs
    self.menuLastVisited.removeAllItems()

</t>
<t tx="karstenw.20160619131158.6">@objc.IBAction
def lastVisitedMenuSelection_(self, sender):
    urlSelected = self.menuLastVisited.title()
    self.textfield.setStringValue_( urlSelected )

</t>
<t tx="karstenw.20160619131158.7">@objc.IBAction
def openAsMenuSelection_(self, sender):
    self.readAsType = self.menuOpenAs.title()

</t>
<t tx="karstenw.20160619131158.8">def windowWillClose_(self, notification):
    self.autorelease()

</t>
<t tx="karstenw.20160619131158.9">@objc.IBAction
def OK_(self, sender):
    "User pressed OK button. Get data and try to open that stuff."

    app = NSApplication.sharedApplication()
    delg = app.delegate()
    t_url = self.textfield.stringValue()
    url = NSURL.URLWithString_( t_url )
    self.readAsType = self.menuOpenAs.title()
    if t_url == u"":
        self.close()
        return
    if t_url not in self.visitedURLs:
        self.visitedURLs.insert( 0, t_url )
        n = len(self.visitedURLs)
        if n &gt; self.noOfRecentURLs:
            self.visitedURLs = self.visitedURLs[:self.noOfRecentURLs]
    else:
        # put visited url at top
        self.visitedURLs.remove( t_url )
        self.visitedURLs.insert( 0, t_url )
        self.menuLastVisited.removeAllItems()
        for menuItem in self.visitedURLs:
            self.menuLastVisited.addItemWithTitle_( menuItem )
    delg.visitedURLs = self.visitedURLs[:]
    delg.newOutlineFromURL_Type_( url, str(self.readAsType) )
    self.close()

</t>
<t tx="karstenw.20160619131220.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619131225.1"># -*- coding: utf-8 -*-

import os
import datetime

import cStringIO
import binascii

import urllib2
urlopen = urllib2.urlopen

import pprint
pp = pprint.pprint

import traceback

import CactusVersion
kwdbg = CactusVersion.developmentversion
kwlog = CactusVersion.developmentversion

import pdb

import lxml
import lxml.etree
lxmletree = lxml.etree

import xml.etree.cElementTree
etree = xml.etree.cElementTree

import lxml.html
#import lxml.html.builder
CommentNode = lxml.etree.Comment


import PyRSS2Gen

import CactusExceptions
OPMLParseErrorException = CactusExceptions.OPMLParseErrorException
XMLParseErrorException = CactusExceptions.XMLParseErrorException
HTMLParseErrorException = CactusExceptions.HTMLParseErrorException
PLISTParseErrorException = CactusExceptions.PLISTParseErrorException

import Foundation
NSURL = Foundation.NSURL
NSDictionary = Foundation.NSDictionary
NSUserDefaults = Foundation.NSUserDefaults
NSMutableDictionary = Foundation.NSMutableDictionary
NSMutableArray = Foundation.NSMutableArray
NSData = Foundation.NSData
NSNumber = Foundation.NSNumber
NSMutableData = Foundation.NSMutableData
NSKeyedArchiver = Foundation.NSKeyedArchiver


# some globals for opml analyzing
keyTypes = {}
opmlTags = {}
nodeTypes = {}
urls = {}


</t>
<t tx="karstenw.20160619131225.10">def getXML_( etRootnode ):
    d = []

    keys = etRootnode.attrib.keys()

    b = {
        'name': unicode(etRootnode.tag),
        'text': unicode(etRootnode.text),
        'tail': unicode(etRootnode.tail),
        'children': [],
        
        'attributes': {}}

    for k in keys:
        b['attributes'][k] = etRootnode.attrib.get(k, "")
    subs = list(etRootnode)
    if subs:
        s = getXMLNodes(etRootnode)
        b['children'] = s
    d.append(b)
    return b


</t>
<t tx="karstenw.20160619131225.11">def getHTML_( etRootnode ):
    d = []

    docinfokeys = (
        'doctype',
        'encoding',
        'externalDTD',
        'internalDTD',
        'public_id',
        'root_name',
        'standalone',
        'system_url',
        'xml_version')
    docinfo = etRootnode.docinfo
    rootnode = etRootnode.getroot()
    keys = rootnode.attrib.keys()

    name = rootnode.tag
    if not name:
        name = u""
    name = unicode(name)

    comment = False
    if rootnode.tag in (CommentNode,):
        name = u"COMMENT"
        comment = True

    text = rootnode.text
    if not text:
        text = u""
    text = unicode(text)

    b = {
        'name': name,
        'text': text,
        'children': [],
        
        'attributes': {}}

    for k in keys:
        b['attributes'][k] = rootnode.attrib.get(k, "")
    if comment:
        b['attributes']['cactustype'] = u"comment"
    subs = list(rootnode)
    if subs:
        s = getXMLNodes(rootnode)
        b['children'] = s
    d.append(b)
    return b


</t>
<t tx="karstenw.20160619131225.12"># these should be unified
def xml_from_string(xml_text):

    try:
        s = etree.fromstring(xml_text)
    except StandardError, v:
        raise XMLParseErrorException, "The XML file could not be parsed.\n%s" % v
    return getXML_( s )


</t>
<t tx="karstenw.20160619131225.13">def html_from_url( htmlurl ):
    if isinstance(htmlurl, NSURL):
        htmlurl = str(htmlurl.absoluteString())
    parser = lxmletree.HTMLParser()
    try:
        # s = lxmletree.parse(htmlurl, parser)
        s = lxmletree.parse(urlopen(htmlurl), parser)
    except StandardError, v:
        raise HTMLParseErrorException, "The HTML file could not be parsed.\n%s" % v
    return getHTML_( s )


</t>
<t tx="karstenw.20160619131225.14">def createSubNodesXML(OPnode, ETnode, level):
    # do attributes

    attrib = OPnode.getValueDict()
    if 'cactustype' in attrib and attrib["cactustype"] == u"comment":
        ETnode.append( etree.Comment( OPnode.comment ) )
    else:
        ETnode.text = OPnode.comment
        for key in attrib:
            if key == u'tail':
                ETnode.tail = attrib[key]
            else:
                ETnode.attrib[key] = attrib[key]

        # ETnode.attrib = attrib

    if len(OPnode.children) &gt; 0:
        
        # do children
        for child in OPnode.children:
            attrib = child.getValueDict()
            ETSub = etree.SubElement( ETnode, child.name)
            s = createSubNodesXML( child, ETSub, level+1 )
    return ETnode


</t>
<t tx="karstenw.20160619131225.15">def reorderAttribKeys( d ):
    keys = d.keys()
    if 'name' in keys:
        keys.remove( 'name' )
        keys.insert( 0, 'name' )
    if 'content' in keys:
        keys.remove( 'content' )
        keys.append( 'content' )
    return keys    


</t>
<t tx="karstenw.20160619131225.16">def createSubNodesHTML(OPnode, ETnode, level, indent=0):

    attrib = OPnode.getValueDict()
    attrib_keys = reorderAttribKeys( attrib )
    
    ETnode.text = OPnode.comment
    if indent:
        ETnode.text.rstrip(u"\r\n")

    for key in attrib_keys:
        if key == u'tail':
            ETnode.tail = attrib[key]
        else:
            ETnode.attrib[key] = attrib[key]

    # if indenting, force 1 element per line
    if not ETnode.tail and indent:
        ETnode.tail = u"\n"

    if len(OPnode.children) &gt; 0:
        # do children
        for child in OPnode.children:
            attrib = child.getValueDict()
            pp(attrib)
            if 'cactustype' in attrib and attrib["cactustype"] == u"comment":
                ETSub = lxmletree.Comment( child.comment )
                ETnode.append( ETSub )
            else:
                ETSub = lxmletree.SubElement( ETnode, child.name)
                s = createSubNodesHTML( child, ETSub, level+1, indent )
    return ETnode


</t>
<t tx="karstenw.20160619131225.17">def generateHTML( rootNode, doctype, encoding, indent=0 ):

    baseOP = rootNode.children[0]

    rootElement = lxmletree.Element("html")
    rootElement.tail = u"\n"

    page = lxmletree.ElementTree( rootElement )

    now = str(datetime.datetime.now())
    now = now[:19]
    now = now.replace(" ", "_")

    c = lxmletree.Comment( CactusVersion.document_creator + " on %s." % (now,))
    c.tail = u"\n"
    
    if 0:
        # deactivated for now
        # creates a new comment each time and what's needed is setting
        # the same comment over and over again
        #
        # OTOH leaving it in leaves a save trail...
        rootElement.append(c)

    # throws up on html save
    #rootElement.attrib.update( baseOP.getValueDict() )
    
    # so;
    d = baseOP.getValueDict()
    for e in d:
        if ':' in e:
            continue
        try:
            rootElement.attrib[e] = d[e]
        except ValueError, err:
            print
            print "ERROR ON ATTRIB UPDATE"
            print err
    comment = baseOP.comment
    if comment:
        rootElement.text = comment

    try:
        nodes = createSubNodesHTML(baseOP, rootElement, 1, indent)
    except Exception, err:
        print 
        print err
        print

    if indent:
        indentXML(rootElement, level=0, width=indent)

    return lxml.html.tostring( page,
                               pretty_print=False,
                               include_meta_content_type=True,
                               encoding=encoding,
                               doctype=doctype)


</t>
<t tx="karstenw.20160619131225.18">def generateXML( rootNode, indent=False ):
    """Generate an OPML/XML tree from OutlineNode rootNode.
    
    parameters:
     indent   - if &gt; 0 indent with indent spaces per level
    return
     etree.Element of rootNode
    """

    #
    # WARNING: The following dereference needs to be removed if the
    #          OPML code is ever cleaned up. Currently the rootNode
    #          is invisible and attached to the document.
    #
    #          That needs to change but not for now.
    #
    #   In the case of XML there are 2 chained roots
    #
    #   Cactus OPML files ommit the &lt;opml&gt; element!
    #

    # ignore the opml element
    baseOP = rootNode.children[0]

    rootXML = etree.Element( baseOP.name )
    rootXML.tail = u"\n"

    now = str(datetime.datetime.now())
    now = now[:19]
    now = now.replace(" ", "_")

    c = etree.Comment( CactusVersion.document_creator + " on %s." % (now,))
    if 0:
        rootXML.append(c)

    rootXML.attrib = baseOP.getValueDict()

    # value = baseOP.getValueDict()
    if 0: #value:
        # filter out empty {'value':""} items
        if len(value)&gt;1:
            rootXML.attrib = value
        elif len(value) == 1:
            if value.keys()[0] == u"value" and value[ u"value" ] != u"":
                rootXML.attrib = value

    comment = baseOP.comment
    if comment:
        baseOP.text = comment
    
    nodes = createSubNodesXML(baseOP, rootXML, 1)

    indentXML(rootXML)

    return rootXML

</t>
<t tx="karstenw.20160619131225.19"># -----------------------------------------------

def generateRSS( rootNode, indent=2 ):
    """Generate an OPML/XML tree from OutlineNode rootNode.
    
    parameters:
     filepath - unused since file writing has been factored out
     indent   - if &gt; 0 indent with indent spaces per level
    return
     etree.Element of rootNode
    """

    valid_RSSChannel = ( "title", "link", "description", "language",
            "copyright", "managingEditor", "webMaster", "pubDate",
            "lastBuildDate", "categories", "generator", "docs",
            "cloud", "ttl", "image", "rating", "textInput",
            "skipHours", "skipDays", "items")

    valid_RSSItems = ( "title", "link", "description", "author",
            "categories", "comments", "enclosure", "guid",
            "pubDate", "source" )

    backTranslator = {
        'subtitle': 'description',
        'title': 'title',
        'published': 'pubDate',
        'id': 'guid'
    }

    now = str(datetime.datetime.now())
    now = now[:19]
    now = now.replace(" ", "_")

    # unused
    creator = CactusVersion.document_creator + " on %s." % (now,)

    # defaults
    head_d = {
        'title': "No Channel Title",
        'description': "No Channel description.",
        'link':  ""}

    headOP = rootNode.findFirstChildWithName_( "head" )

    if headOP:
        for headsub in headOP.children:
            name = headsub.name
            name = backTranslator.get(name, name)
            if name in valid_RSSChannel:
                value = headsub.getValueDict()
                if name == 'cloud':
                    cloud = PyRSS2Gen.Cloud(
                            value.get('domain', ""),
                            value.get('port', ""),
                            value.get('path', ""),
                            value.get('registerProcedure', ""),
                            value.get('protocol', ""))
                    head_d[ 'cloud' ] = cloud
                elif name == 'image':
                    image = PyRSS2Gen.Image(
                            value.get('href', ""),
                            value.get('title', ""),
                            value.get('link', ""),
                            value.get('width', None),
                            value.get('height', None),
                            value.get('description', None))
                    head_d[ 'image' ] = image

                else:
                    if len(value) == 1:
                        head_d[name] = value.values()[0]
                    else:
                        
                        head_d[name] = value
        print "HEAD:"
        pp(head_d)
    body_l = []
    bodyOP = rootNode.findFirstChildWithName_( "body" )

    if bodyOP:
        for bodysub in bodyOP.children:
            name = bodysub.name
            value = bodysub.getValueDict()
            d = {'title': "No Item Title",
                 'description': "No Item description."}

            for key in value:
                v = value[key]
                k = backTranslator.get(key, key)
                if k == "summary":
                    k = "description"
                if k in valid_RSSItems:

                    if k == 'enclosure':
                        url, rest = value[key].split('&lt;&lt;&lt;')
                        length, type_ = rest.split(';', 1)
                        try:
                            length = int(length)
                        except ValueError, err:
                            if kwlog:
                                print "BOGUS ENCLOSURE LENGTH: %s" % repr(length)
                            length = 0
                        enc = PyRSS2Gen.Enclosure( url, length, type_)
                        d[k] = enc
                    else:
                        # TODO: check for type here; dicts and lists may be bad
                        d[ k ] = v #value[key]
                        if type(d[ k ]) in (list, dict, tuple):
                            print "\ngenerateRSS() type error.\n"
                        
            #print "ITEM:"
            #pp( d )
            body_l.append( PyRSS2Gen.RSSItem( **d ) )

    head_d[ 'items' ] = body_l

    rss = PyRSS2Gen.RSS2( **head_d )
    f = cStringIO.StringIO()
    rss.write_xml( f, encoding='utf-8')
    s = f.getvalue()
    f.close()
    return s


</t>
<t tx="karstenw.20160619131225.2"># -----------------------------------------------

def getOutlineNodes(node):
    """Read the outline nodes in OPML/body
    """
    global keyTypes, opmlTags, nodeTypes, urls
    result = []
    for n in list(node):
        keys = n.attrib.keys()

        if kwlog:
            # gather some stuff for debugging and opml analyzing
            keys.sort()
            keys = tuple(keys)
            if not keys in keyTypes:
                keyTypes[ keys ] = 1
            else:
                keyTypes[ keys ] += 1
            for key in keys:
                if not key in opmlTags:
                    opmlTags[ key ] = 1
                else:
                    opmlTags[ key ] += 1
            if 'type' in keys:
                theType = n.attrib['type']
                if theType not in nodeTypes:
                    nodeTypes[theType] = 1
                else:
                    nodeTypes[theType] += 1
        name = n.attrib.get('text', '')
        nchild = len(n)
        b = {
            'name': name,
            'children': [],
            'attributes': {}}

        for k in keys:
            b['attributes'][k] = n.attrib.get(k, "")
        subs = list(n)
        if subs:
            s = getOutlineNodes(n)
            b['children'] = s
        result.append(b)
    return result


</t>
<t tx="karstenw.20160619131225.20">def serializePLISTOutline_( rootNode ):
    nsdict = generatePLISTDict_( rootNode )
    p = "/tmp/tmp.plist"
    ok = nsdict.writeToFile_atomically_(p, True)
    if ok:
        f = open( p, 'rb')
        s = f.read()
        f.close()
        data = NSData.dataWithBytes_length_(s, len(s) )
        return data
    return False


</t>
<t tx="karstenw.20160619131225.21">def generatePLISTDict_( rootNode ):
    plist = NSMutableDictionary.dictionaryWithCapacity_(rootNode.noOfChildren())
    
    for child in rootNode.children:
        attrs = child.getValueDict()
        name = child.name
        cactusType = attrs.get( 'cactusNodeType', None)
        immediateValue = unicode(child.comment)
        if cactusType == 'bool':
            plist[ name ] = False
            if immediateValue != u"False":
                plist[ name ] = True
        elif cactusType == 'number':
            if '.' in str(immediateValue):
                plist[ name ] = NSNumber.numberWithFloat_( float(immediateValue) )
            else:
                # plist[ name ] = long(immediateValue)
                plist[ name ] = NSNumber.numberWithLongLong_( long(immediateValue) )
        elif cactusType == 'string':
            plist[ name ] = immediateValue
        elif cactusType == 'data':
            s = binascii.unhexlify(immediateValue)
            l = len(s)
            plist[ name ] = NSData.dataWithBytes_length_(s, l)
        elif cactusType == 'list':
            plist[ name ] = generatePLISTArray_( child )
        elif cactusType == 'dictionary':
            plist[ name ] = generatePLISTDict_( child )
    return plist


</t>
<t tx="karstenw.20160619131225.22">def generatePLISTArray_( rootNode ):
    plist = NSMutableArray.arrayWithCapacity_(rootNode.noOfChildren())
    
    for child in rootNode.children:
        attrs = child.getValueDict()
        name = child.name
        cactusType = attrs.get( 'cactusNodeType', None)
        immediateValue = unicode(child.comment)
        if cactusType == 'bool':
            b = False
            if immediateValue != u"False":
                b = True
            plist.append( b )
        elif cactusType == 'number':
            if '.' in str(immediateValue):
                plist.append( float(immediateValue) )
            else:
                plist.append( long(immediateValue) )
        elif cactusType == 'string':
            plist.append( immediateValue )
        elif cactusType == 'data':
            s = binascii.unhexlify(immediateValue)
            l = len(s)
            plist.append( NSData.dataWithBytes_length_(s, l) )
        elif cactusType == 'list':
            plist.append( generatePLISTArray_( child ) )
        elif cactusType == 'dictionary':
            plist.append( generatePLISTDict_( child ) )
    return plist


</t>
<t tx="karstenw.20160619131225.23">def generateOPML( rootNode, indent=2, expansion={} ):
    """Generate an OPML/XML tree from OutlineNode rootNode.
    
    parameters:
     filepath - unused since file writing has been factored out
     indent   - if &gt; 0 indent with indent spaces per level
     expansion- a string that will be the value of head.expansionState 

    return
     etree.Element of rootNode
    """
    print "opml.generateOPML( %s, %s )" % (rootNode, repr(expansion))

    defaults = NSUserDefaults.standardUserDefaults()
    merge = defaults.objectForKey_( u'optMergeComment')


    rootOPML = etree.Element("opml")
    rootOPML.attrib["version"] = "2.0"

    now = str(datetime.datetime.now())
    now = now[:19]
    now = now.replace(" ", "_")

    c = etree.Comment( CactusVersion.document_creator + " on %s." % (now,))
    if 0:
        rootOPML.append(c)

    headOP = rootNode.findFirstChildWithName_( "head" )

    head = etree.SubElement(rootOPML, "head")

    expandCreated = set()
    if headOP:
        for headsub in headOP.children:
            name = headsub.name
            value = headsub.getValueDict()
            comment = headsub.comment
            v = ""

            if name in expansion:
                value = { u"": unicode(expansion[name]) }
                expandCreated.add(name)

            node = etree.SubElement( head, name)

            if value: # != "":
                v = value[ value.keys()[0] ]

                # node.text = value
                # node.text = unicode(value.get('value', ''))

                # node.text = unicode(value.get( u'', ''))
                node.text = unicode(v)
            
            if comment != "":
                if merge:
                    node.attrib["_note"] = comment
                else:
                    node.attrib["comment"] = comment
            print "HEAD: '%s': '%s' " % (repr(name), repr(v))
        # add missing keys
        if expansion:
            for key in expansion:
                if key not in expandCreated:
                    node = etree.SubElement( head, key)
                    node.text = unicode(expansion[key])
                
    else:
        # create generic head here
        if expansion:
            for key in expansion:
                if key not in expandCreated:
                    node = etree.SubElement( head, key)
                    node.text = unicode(expansion[key])

    body = etree.SubElement(rootOPML, "body")
    bodyOP = rootNode.findFirstChildWithName_( "body" )

    try:
        if bodyOP:
            nodes = createSubNodesOPML(bodyOP, body, 1, merge=merge)
        else:
            # an outline without body
            nodes = createSubNodesOPML(rootNode, body, 1, merge=merge)
    except Exception, err:
        tb = unicode(traceback.format_exc())
        print tb
        print 

    if indent:
        indentXML(rootOPML, 0, indent)

    return rootOPML


</t>
<t tx="karstenw.20160619131225.24">def photo_from_string( photo_text ):
    return getPhotoXML( etree.fromstring(photo_text) )


</t>
<t tx="karstenw.20160619131225.25">def getPhotoXML( rootNode ):

    title = description = whenUploaded = whenArchived = license = urlFolder = ""

    node = rootNode.find("title")
    if node != None:
        title = node.text

    node = rootNode.find("description")
    if node != None:
        description = node.text

    node = rootNode.find("whenUploaded")
    if node != None:
        whenUploaded = node.text

    node = rootNode.find("whenArchived")
    if node != None:
        whenArchived = node.text

    node = rootNode.find("license")
    if node != None:
        license = node.text

    node = rootNode.find("urlFolder")
    if node != None:
        urlFolder = node.text

    sizes = rootNode.find("sizes")

    picts = {}

    picture = {
        'title': title,
        'urlFolder': urlFolder,
        'description': description,
        'whenUploaded': whenUploaded,
        'whenArchived': whenArchived,
        'license': license,
        'sizes': []
    }

    sortedSizes = []

    if urlFolder:
        for i, size in enumerate(list(sizes)):
            picture['sizes'].append(size.attrib)

            maxWH = max(int(size.attrib.get('width', 0)),
                        int(size.attrib.get('height', 0)) )

            sortedSizes.append( (maxWH, i) )

            if 'fname' in size.attrib:
                name = size.attrib['fname']
                url = urlFolder + name
                picts[ name ] = url

    sortedSizes.sort()
    sortedSizes.reverse()
    picture['sortedSizes'] = sortedSizes
    return picture
</t>
<t tx="karstenw.20160619131225.3">def getOPML( etRootnode ):
    global keyTypes, opmlTags, nodeTypes, urls
    
    d = {
        'head': [],
        'body':[]
        }

    # get head
    head = etRootnode.find("head")

    # get body
    body = etRootnode.find("body")

    if head:
        for item in list(head):
            #print "head:", item.tag, item.text
            d['head'].append( (item.tag, item.text) )

    if body:
        d['body'] = getOutlineNodes(body)

    if kwlog:
        print
        print "KeyTypes", len(keyTypes)
        pp(keyTypes)
        print
        print "OPMPTags", len(opmlTags)
        pp(opmlTags)
        print
        print "types", len(nodeTypes)
        pp(nodeTypes)
        
    return  d


</t>
<t tx="karstenw.20160619131225.4">def opml_from_string(opml_text):
    try:
        s = etree.fromstring(opml_text)
    except StandardError, v:
        raise OPMLParseErrorException, "The OPML file could not be parsed.\n%s" % v
    return getOPML( s )


</t>
<t tx="karstenw.20160619131225.5">def parse_plist( nsurl ):
    try:
        nsdict = NSDictionary.dictionaryWithContentsOfURL_( nsurl )
    except StandardError, v:
        raise PLISTParseErrorException, "The PLIST file could not be parsed.\n%s" % v
    return nsdict


</t>
<t tx="karstenw.20160619131225.6"># UNUSED
def parse(opml_url):
    return getOPML(etree.parse(opml_url))


</t>
<t tx="karstenw.20160619131225.7">def indentXML(elem, level=0, width=2):
    i = "\n" + level * (" " * width)
    if len(elem):

        if not elem.text or not elem.text.strip():
            elem.text = i + "  "

        if not elem.tail or not elem.tail.strip():
            elem.tail = i

        for elem in elem:
            indentXML(elem, level+1, width)

        if not elem.tail or not elem.tail.strip():
            elem.tail = i
    else:
        if level and (not elem.tail or not elem.tail.strip()):
            elem.tail = i


</t>
<t tx="karstenw.20160619131225.8">def createSubNodesOPML(OPnode, ETnode, level, merge=False):
    # do attributes
    name = OPnode.name
    value = OPnode.getValueDict()
    for k, v in value.items():
        if type(v) not in (str, unicode):
            value[k] = unicode(v)
    comment = OPnode.comment

    # update attributes
    if ETnode.tag != "body":
        #d = dictFromValue( value )
        ETnode.attrib['text'] = name
        
        # don't have an empty value: tag
        if len(value) == 1:
            # if 'value' in value:
            if u'' in value:
                # value.pop('value')
                # value.pop( u'' )
                value = {}

        ETnode.attrib.update( value )

        if comment != "":
            if merge:
                ETnode.attrib['_note'] = comment
            else:
                ETnode.attrib['comment'] = comment

    if len(OPnode.children) &gt; 0:
        
        # do children
        for child in OPnode.children:
            ETSub = etree.SubElement( ETnode, "outline")
            s = createSubNodesOPML( child, ETSub, level+1, merge=merge )
    return ETnode


</t>
<t tx="karstenw.20160619131225.9"># -----------------------------------------------

stop = 1

def getXMLNodes( node ):
    """Read the outline nodes in XML
    """
    result = []
    for n in list(node):

        name = n.tag
        if not name:
            name = u""
        name = unicode(name)

        text = n.text
        if not text:
            text = u""
        text = unicode(text)
        fulltext = text
        #text = text.strip(u" \t\r\n")

        tail = n.tail
        if not tail:
            tail = u""
        tail = unicode(tail)
        fulltail = tail
        #tail = tail.strip(u" \t\r\n")

        if kwlog and kwdbg:
            if tail:
                if name == u"a":
                    print
                    print "NAME:", repr(name)
                    print "TEXT:", repr(text)
                    print "TAIL:", repr(tail)
                
        comment = False
        if n.tag in (CommentNode,):
            name = u"COMMENT"
            comment = True
            # dont strip comments
            text = fulltext
            tail = fulltail

        b = {
            'name': name,
            'text': text,
            'tail': tail,
            'children': [],
            
            'attributes': {}}

        keys = n.attrib.keys()

        for k in keys:
            b['attributes'][k] = unicode(n.attrib.get(k, ""))

        if comment:
            b['attributes']['cactustype'] = u"comment"

        subs = list(n)
        if subs:
            s = getXMLNodes(n)
            b['children'] = s
        result.append(b)
    return result


</t>
<t tx="karstenw.20160619131230.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619131238.1">
# -*- coding: utf-8 -*-


"""A collection of outline related stuff
"""

import sys
import os

import re

import cPickle

import traceback

import time
import datetime

import urllib
import urlparse

import math
import feedparser

import CactusVersion
kwdbg = CactusVersion.developmentversion
kwlog = CactusVersion.developmentversion

import pdb
import pprint
pp = pprint.pprint



import bs4
BeautifulSoup = bs4.BeautifulSoup

import appscript

import CactusOPML

import CactusOutlineTypes
typeOutline = CactusOutlineTypes.typeOutline

import objc


import Foundation
NSObject = Foundation.NSObject
NSAutoreleasePool = Foundation.NSAutoreleasePool
NSMutableDictionary = Foundation.NSMutableDictionary
NSMakeRange = Foundation.NSMakeRange
NSAttributedString = Foundation.NSAttributedString
NSThread = Foundation.NSThread
NSNotificationCenter = Foundation.NSNotificationCenter
NSNotification = Foundation.NSNotification

NSNotFound = Foundation.NSNotFound
NSIndexSet = Foundation.NSIndexSet
NSMutableIndexSet = Foundation.NSMutableIndexSet

NSNumber = Foundation.NSNumber

NSURL = Foundation.NSURL

NSMakePoint = Foundation.NSMakePoint


import AppKit
NSUserDefaults = AppKit.NSUserDefaults
NSApplication = AppKit.NSApplication
NSOpenPanel = AppKit.NSOpenPanel
NSDocumentController = AppKit.NSDocumentController
NSOutlineView = AppKit.NSOutlineView
NSWindowController = AppKit.NSWindowController

NSData = AppKit.NSData

NSMenu = AppKit.NSMenu

NSPasteboard = AppKit.NSPasteboard
NSWorkspace = AppKit.NSWorkspace

NSString = AppKit.NSString
NSMutableString = AppKit.NSMutableString

NSTableView = AppKit.NSTableView
NSText = AppKit.NSText

# the characters to test against
NSBackspaceCharacter = AppKit.NSBackspaceCharacter
NSDeleteCharacter = AppKit.NSDeleteCharacter
NSCarriageReturnCharacter = AppKit.NSCarriageReturnCharacter
NSEnterCharacter = AppKit.NSEnterCharacter
NSTabCharacter = AppKit.NSTabCharacter
NSBackTabCharacter = AppKit.NSBackTabCharacter

NSDownArrowFunctionKey = AppKit.NSDownArrowFunctionKey
NSLeftArrowFunctionKey = AppKit.NSLeftArrowFunctionKey
NSRightArrowFunctionKey = AppKit.NSRightArrowFunctionKey
NSUpArrowFunctionKey = AppKit.NSUpArrowFunctionKey
NSUpTextMovement = AppKit.NSUpTextMovement


# text movements
NSReturnTextMovement = AppKit.NSReturnTextMovement
NSTabTextMovement = AppKit.NSTabTextMovement
NSBacktabTextMovement = AppKit.NSBacktabTextMovement
NSIllegalTextMovement = AppKit.NSIllegalTextMovement
NSCancelTextMovement = AppKit.NSCancelTextMovement
NSLeftTextMovement = AppKit.NSLeftTextMovement
NSRightTextMovement = AppKit.NSRightTextMovement
NSUpTextMovement = AppKit.NSUpTextMovement
NSDownTextMovement = AppKit.NSDownTextMovement
NSOtherTextMovement = AppKit.NSOtherTextMovement


# modifiers
# shift lock
NSAlphaShiftKeyMask = AppKit.NSAlphaShiftKeyMask

# shift key
NSShiftKeyMask = AppKit.NSShiftKeyMask

# control
NSControlKeyMask = AppKit.NSControlKeyMask

# alt
NSAlternateKeyMask = AppKit.NSAlternateKeyMask

# cmd
NSCommandKeyMask = AppKit.NSCommandKeyMask

# F
NSFunctionKeyMask = AppKit.NSFunctionKeyMask

NSDeviceIndependentModifierFlagsMask = AppKit.NSDeviceIndependentModifierFlagsMask


# undo manager constants
NSChangeDone = AppKit.NSChangeDone
NSChangeUndone = AppKit.NSChangeUndone
NSChangeCleared = AppKit.NSChangeCleared
NSChangeReadOtherContents = AppKit.NSChangeReadOtherContents
NSChangeAutosaved = AppKit.NSChangeAutosaved

# drag and drop
NSDragOperationNone = AppKit.NSDragOperationNone
NSDragOperationCopy = AppKit.NSDragOperationCopy
NSDragOperationLink = AppKit.NSDragOperationLink
NSDragOperationGeneric = AppKit.NSDragOperationGeneric
NSDragOperationMove = AppKit.NSDragOperationMove
NSDragOperationEvery = AppKit.NSDragOperationEvery
NSDragOperationDelete = AppKit.NSDragOperationDelete

NSDragOperationAll_Obsolete = AppKit.NSDragOperationAll_Obsolete

NSOutlineViewDropOnItemIndex = AppKit.NSOutlineViewDropOnItemIndex

NSStringPboardType = AppKit.NSStringPboardType
NSFilenamesPboardType = AppKit.NSFilenamesPboardType
NSFilesPromisePboardType = AppKit.NSFilesPromisePboardType

# printing
NSPrintOperation = AppKit.NSPrintOperation


import CactusOutlineNode
OutlineNode = CactusOutlineNode.OutlineNode

import CactusTools
NSURL2str = CactusTools.NSURL2str
readURL = CactusTools.readURL
getFileProperties = CactusTools.getFileProperties
setFileProperties = CactusTools.setFileProperties
datestring_nsdate = CactusTools.datestring_nsdate
makeunicode = CactusTools.makeunicode
mergeURLs = CactusTools.mergeURLs
getURLExtension = CactusTools.getURLExtension
num2ostype = CactusTools.num2ostype


import CactusDocumentTypes
CactusOPMLType = CactusDocumentTypes.CactusOPMLType
CactusRSSType = CactusDocumentTypes.CactusRSSType
CactusXMLType = CactusDocumentTypes.CactusXMLType
CactusHTMLType = CactusDocumentTypes.CactusHTMLType

CactusDocumentTypesSet = CactusDocumentTypes.CactusDocumentTypesSet
CactusDocumentXMLBasedTypesSet = CactusDocumentTypes.CactusDocumentXMLBasedTypesSet


import CactusExceptions
OPMLParseErrorException = CactusExceptions.OPMLParseErrorException

import CactusXMLProperties
re_bogusCharacters = CactusXMLProperties.re_bogusCharacters


import CactusFileOpeners


DragDropCactusPboardType = "CactusKWOutlineViewPboardType"




# simple dict for opening outline nodes

# to be used, not now
g_opmplnodetypes = {
    # typename: (urlname, openfunction)
    'blogpost': ('url', ),
    'code': (),
    'howto': (),
    'html': (),
    'include': (),
    'link': (),
    'outline': (),
    'photo': (),
    'redirect': (),
    'river': (),
    'rss': (),
    'scripting2Post': (),
    'thumbList':()
    }

g_preview_extensions = ("pdf ai ps epi eps epsf epsi "
                        "tiff tif "
                        "crw cr2 nef raf orf mrw srf dcr arw pef raw mos "
                        "dng xbm exr bmp gif ico jpg jpeg jpe thm "
                        "png qtif tga targa sgi psd pntg fpx fax jfx jfax icns jp2 "
                        "pic hdr ")
                        # not anymore
                        # "pict pct " 
g_preview_extensions = g_preview_extensions.split()

g_qtplayer_extensions = ("aac aifc aiff aif au ulw snd caf gsm kar mid smf midi "
                         "mp3 swa wav 3gp 3g2 amc avi vfw dif dv fli mp2 m1s m75 "
                         "m15 m2p mpg mpeg mp4 mpg4 mqv qtz mov qt qtl rtsp sd2 "
                         "sdp sml m1a mpa mpm m1v m2v m4a m4p m4b m4v amr cdda "
                         "dvd atr sdv pls qmed ")
g_qtplayer_extensions = g_qtplayer_extensions.split()


</t>
<t tx="karstenw.20160619131238.10">def insertSafariLinks_(self, sender):
    if kwlog:
        print "KWOutlineView.insertSafariLinks_()"
    row = self.clickedRow()
    selection = self.getSelectionItems()
    if not selection:
        return
    result = []

    item = selection[0]
    idx = item.siblingIndex()

    parent = item.parent

    safari = appscript.app("Safari.app")
    if not safari.isrunning():
        return

    src = ""
    try:
        src = safari.windows[1].current_tab.source()
        url = safari.windows[1].current_tab.URL()
    except Exception, err:
        print err
    if not src:
        return
    soup = BeautifulSoup( src )
    links = soup.find_all( 'a' )

    purl = urlparse.urlparse( url )

    listroot = OutlineNode(url, "", parent, typeOutline, item.rootNode)
    parent.addChild_atIndex_( listroot, idx+1 )

    for link in links:
        d = { 'type': 'link' }
        dest = link.get('href', False)
        if not dest:
            continue
        name = link.text
        d['name'] = name
        pdest = urlparse.urlparse( dest )
        target = mergeURLs( url, dest )
        d['url'] = target

        node = OutlineNode(name, d, listroot, typeOutline, item.rootNode)
        listroot.addChild_( node )
    self.reloadData()
    self.setNeedsDisplay_( True )


def insertSafarimages_(self, sender):
    if kwlog:
        print "KWOutlineView.insertSafariLinks_()"
    row = self.clickedRow()
    selection = self.getSelectionItems()
    if not selection:
        return
    result = []

    item = selection[0]
    idx = item.siblingIndex()

    parent = item.parent

    safari = appscript.app("Safari.app")
    if not safari.isrunning():
        return

    src = ""
    try:
        src = safari.windows[1].current_tab.source()
        url = safari.windows[1].current_tab.URL()
    except Exception, err:
        print err
    if not src:
        return
    soup = BeautifulSoup( src )
    links = soup.find_all( 'img' )

    purl = urlparse.urlparse( url )

    listroot = OutlineNode(url, "", parent, typeOutline, item.rootNode)
    parent.addChild_atIndex_( listroot, idx+1 )

    # pdb.set_trace()

    for link in links:
        d = { 'type': 'link' }
        dest = link.get('src', False)
        if not dest:
            continue
        name = link.text
        d['name'] = name
        pdest = urlparse.urlparse( dest )
        target = mergeURLs( url, dest )
        d['url'] = target

        node = OutlineNode(name, d, listroot, typeOutline, item.rootNode)
        listroot.addChild_( node )
    self.reloadData()
    self.setNeedsDisplay_( True )



</t>
<t tx="karstenw.20160619131238.11">def copySelectionPython_(self, sender):
    if kwlog:
        print "KWOutlineView.copySelectionPython_()"
    row = self.clickedRow()
    selection = self.getSelectionItems()
    result = []
    for contextItem in selection:
        result.append( contextItem.copyPython() )
    s = pprint.pformat(result)
    pb = NSPasteboard.generalPasteboard()
    pb.declareTypes_owner_( [AppKit.NSStringPboardType,], self )
    pb.setString_forType_(s, AppKit.NSStringPboardType)

</t>
<t tx="karstenw.20160619131238.12">def copySelectionNodes_(self, sender):
    print "KWOutlineView.copySelectionPython_()"
    selection = self.getSelectionItems()
    result = []
    for contextItem in selection:
        self.clipboardRoot.addChild_(
                contextItem.copyNodesWithRoot_(self.clipboardRoot) )

</t>
<t tx="karstenw.20160619131238.13">def pasteSelectionNodes_(self, sender):
    selection = self.getSelectionItems()
    if not selection:
        return
    item = selection[0]
    idx = item.siblingIndex()
    parent = item.parent

    def setRoot(item, root):
        item.rootNode = root
        for child in item.children:
            child.rootNode = root
            setRoot(child, root)

    def addChildren( item, target):
        pass

    for child in self.clipboardRoot.children:
        idx += 1
        parent.addChild_atIndex_(child, idx)
        setRoot( child, parent.rootNode)
    self.clipboardRoot.children.removeAllObjects()
    self.reloadData()
    self.setNeedsDisplay_( True )


</t>
<t tx="karstenw.20160619131238.14">def contextMenuInclude_(self, sender):
    if kwlog:
        print "KWOutlineView.contextMenuInclude_()"

    # TBD: check selection
    # if right-click in selection:
    #   use selection
    # else
    #   use clicked row only

    row = self.clickedRow()
    selection = self.getSelectionItems()

    importedNodes = 0
    for contextItem in selection:

        if not contextItem:
            continue

        if contextItem.noOfChildren() &gt; 1:
            continue

        attributes = contextItem.getValueDict()
        theType = attributes.get("type", "")
        url = attributes.get("url", "")
        url = cleanupURL( url )
        if theType in ( 'include', 'outline', 'thumbList', 'code',
                         'thumbListVarCol', 'thumbList', 'blogpost', 'link'):

            d = None
            try:
                d = CactusOPML.opml_from_string(
                            readURL( NSURL.URLWithString_( url ),
                                     CactusOPMLType ) )

            except OPMLParseErrorException, err:
                print traceback.format_exc()
                print err

            if d:
                #
                # TBD: import here to circumvent circular import
                #
                
                root, type_ = CactusFileOpeners.openOPML_( d )
                for node in root.children:
                    if node.name == u"body":
                        for i in node.children:
                            contextItem.addChild_(i)
                            node.removeChild_(i)
                            importedNodes += 1
                        break
                # do I really need to kill the link?
                #
                # attrs = contextItem.getValueDict()
                # attrs.pop( u"url" )
                # attrs.pop( u"type" )
                # contextItem.setValue_( attrs )
                #
                del root
                del d
    if importedNodes &gt; 0:
        self.delegate().markDirty()

    self.reloadData()
    self.setNeedsDisplay_( True )

</t>
<t tx="karstenw.20160619131238.15">#
# drag and drop
#

#
# drag destination
#

def XdraggingEntered_( self, dragInfo ):
    print "draggingEntered_"
    pboard = dragInfo.draggingPasteboard()
    mask = dragInfo.draggingSourceOperationMask()
    types = pboard.types()
    opType = NSDragOperationNone
    self.setDraggingDestinationFeedbackStyle_(1)
    if DragDropCactusPboardType in types:
        opType = NSDragOperationMove
        
        return NSDragOperationMove

    elif NSFilenamesPboardType in types:
        print "NSFilenamesPboardType entered"
        return NSDragOperationNone

        if mask &amp; NSDragOperationLink:
            return  NSDragOperationLink

        elif mask &amp; NSDragOperationCopy:
            return  NSDragOperationCopy
    self.setNeedsDisplay_(True)
    return NSDragOperationNone


</t>
<t tx="karstenw.20160619131238.16">def XdraggingUpdated_( self, dragInfo ):
    #print "draggingUpdated_",
    if dragInfo.draggingSource():
        pp(dragInfo)
        return NSDragOperationMove
    else:
        print "external"
        return NSDragOperationCopy

</t>
<t tx="karstenw.20160619131238.17">@objc.IBAction
def XdraggingExited_( self, dragInfo ):
    print "draggingExited_"
    objc.super(KWOutlineView, self).draggingExited_(dragInfo)

</t>
<t tx="karstenw.20160619131238.18">def XprepareForDragOperation_( self, dragInfo ):
    print "KWOutlineView.prepareForDragOperation_"
    self.currentDragItems = self.getSelectionItems()
    pp( self.currentDragItems )
    # self.setNeedsDisplay_(True)
    return 1

</t>
<t tx="karstenw.20160619131238.19">def XperformDragOperation_( self, dragInfo ):
    print "KWOutlineView.performDragOperation_"
    pboard = dragInfo.draggingPasteboard()
    successful = 0
    types = pboard.types()
    sender = dragInfo.draggingSource()
    pp(dragInfo)
    return successful

</t>
<t tx="karstenw.20160619131238.2">def open_photo( url, open_=True ):
    """opens 2nd biggest picture"""
    print "CactusOutline.open_photo( %s )" % repr(url)

    defaults = NSUserDefaults.standardUserDefaults()
    cache = False
    try:
        cache = bool(defaults.objectForKey_( u'optCache'))
    except StandardError, err:
        print "ERROR reading defaults.", repr(err)

    s = CactusTools.readURL( NSURL.URLWithString_( url ) )

    #
    d = CactusOPML.photo_from_string( s )

    # sortedSizes contains all picture sizes in descensing order
    # first pict will be max size. size large is usually good but
    # not always present

    # so we pick the second biggest pict, except when there's only
    # one pict, then the first
    if d['sortedSizes']:
        # make a pick
        if len(d['sortedSizes']) &gt; 1:
            s, idx = d['sortedSizes'][1]
        else:
            s, idx = d['sortedSizes'][0]
        # grab the picture record

        picture = d['sizes'][idx]

        workspace= NSWorkspace.sharedWorkspace()

        url = d['urlFolder'] + picture['fname']

        nsurl = NSURL.URLWithString_( url )

        # if opened from cache, open in preview
        # else in safari since preview can't urlopen
        target = u'com.apple.Safari'
        if cache:
            target = u'com.apple.Preview'
            nsurl = CactusTools.cache_url( nsurl, None )
        else:
            target = u'com.apple.Safari'

        if open_:
            workspace.openURLs_withAppBundleIdentifier_options_additionalEventParamDescriptor_launchIdentifiers_(
                [ nsurl ],
                target,
                0,
                None,
                None )


</t>
<t tx="karstenw.20160619131238.20">@objc.IBAction
def XconcludeDragOPeration_( self, dragInfo ):
    print "concludeDragOPeration_", repr(dragInfo)
    self.setNeedsDisplay_(True)


</t>
<t tx="karstenw.20160619131238.21">def XsetDropItem_dropChildIndex_(self, item, index):
    print "KWOutlineView.setDropItem_dropChildIndex_(%s), %s" % (repr(item), repr(index))
    # get's called if updateDrop_ is not defined
    
    


</t>
<t tx="karstenw.20160619131238.22">#def wantsPeriodicDraggingUpdates(self):
#    # if present crashes at startup
#    # perhaps try it when methods are fleshed out
#    return False

#
# drag source
#

def XmouseDragged_(self, event):
    # from hillegass book
    pass

</t>
<t tx="karstenw.20160619131238.23">@objc.IBAction
def cut_(self, sender):
    self.copy_(sender)
    deleteNodes(self, selection=True)
    self.deselectAll_( None )

</t>
<t tx="karstenw.20160619131238.24">@objc.IBAction
def copy_(self, sender):
    pb = NSPasteboard.generalPasteboard()
    self.copyNodesToPasteboard_( pb )

</t>
<t tx="karstenw.20160619131238.25">@objc.IBAction
def paste_(self, sender):
    pb = NSPasteboard.generalPasteboard()
    pastedItems = self.readNodesFromPasteboard_parent_index_( pb, False, False )
    if pastedItems:
        self.reloadData()
        self.selectItems_(pastedItems)

</t>
<t tx="karstenw.20160619131238.26">def copyNodesToPasteboard_( self, pb ):
    print "KWOutlineView.copyNodesToPasteboard_"

    pb.declareTypes_owner_( [DragDropCactusPboardType,
                             NSStringPboardType],
                             # NSFilenamesPboardType],
                            self)

    items = self.getSelectionItems()

    # pack items
    result = []
    names = []
    noduplicates = set(items)
    for item in items:
        ancestors = set(item.pathFromRoot())
        if ancestors.isdisjoint(noduplicates):
            result.append( item.copyPython())
        row = self.rowForItem_( item )
        level = self.levelForRow_( row )
        indent = u"\t" * level
        s = u"%s%s" % (indent, item.name)
        names.append( s )
    data = cPickle.dumps( result )
    l = len(data)
    nsdata = NSData.dataWithBytes_length_(data, l)

    pb.setData_forType_( nsdata, DragDropCactusPboardType)

    t = u"\n".join( names )
    s = NSString.stringWithCharacters_length_(t, len(t))
    pb.setString_forType_( s, NSStringPboardType)


</t>
<t tx="karstenw.20160619131238.27">def readNodesFromPasteboard_parent_index_(self, pb, insertParent, afterIndex):
    """Insert NSData(pickle) nodes from a pasteboard.
    
    if insertParent:
        make children of parent (append)
    if afterIndex:
        insert after index
        
    - deletion of original nodes (d&amp;d) should occur after insertion to get the
    selection right.
    
    return a set of inserted items.
    """
    if 1: #kwlog:
        print "KWOutlineView.readNodesFromPasteboard_parent_index_"

    types = pb.types()
    t = None
    mystringtype = "public.utf8-plain-text"

    if DragDropCactusPboardType in types:
        t = DragDropCactusPboardType

    elif NSFilenamesPboardType in types:
        t = NSFilenamesPboardType

    elif mystringtype in types:
        t = mystringtype

    if not t:
        return False

    delg = self.delegate()
    typ = delg.typ
    root = delg.root

    data = pb.dataForType_(t)
    nodes = []
    if t == DragDropCactusPboardType:
        nodes = cPickle.loads( data.bytes().tobytes() )
    elif t == NSFilenamesPboardType:
        # list of paths
        paths = pb.propertyListForType_(NSFilenamesPboardType)
        for path in paths:
            typ = "file"
            if os.path.isdir( path ):
                typ = "folder"
            prop = getFileProperties( path )
            typ, currnode = makeFilePropertiesNode( path )
            if typ == "folder":
                folder2Outline( path, currnode )
            
            nodes.append( currnode )

    elif t == mystringtype:
        nodes = []
        s = makeunicode(data.bytes().tobytes())
        if u"\r" in s:
            r = s.split( u"\r" )
        else:
            r = s.split( u"\n" )

        for i in r:
            i = i.strip(u"\r\n\t ")
            nodes.append( { 
                'name': i,
                'value': u"",
                'typ': CactusOutlineTypes.typeOutline,
                'children': [] } )

    if not insertParent:
        selection = self.getSelectionItems()
        if selection:
            item = selection[-1]
            pasteParent = item.parent
            afterIndex = item.siblingIndex() + 1
        else:
            # append to root.children
            pasteParent = root
    else:
        pasteParent = insertParent

    itemsPasted = 0

    def doChildren( item, children ):
        for node in children:
            n = OutlineNode(node['name'], node['value'], item, node['typ'], root)
            item.addChild_( n )
            doChildren( n, node['children'])

    pastedItems = set()
    
    for node in nodes:
        # a dict per node
        n = OutlineNode(node['name'], node['value'], pasteParent, node['typ'], root)

        if afterIndex &gt;= 0:
            pasteParent.addChild_atIndex_( n, afterIndex )
            afterIndex += 1
        elif afterIndex == -1:
            pasteParent.addChild_( n )
        elif afterIndex == False:
            pasteParent.addChild_( n )

        doChildren( n, node['children'])
        itemsPasted += 1
        pastedItems.add( n )

    self.expandItem_( pasteParent )
    self.deselectAll_( None )

    if itemsPasted &gt; 0:
        delg.markDirty()
    return pastedItems


</t>
<t tx="karstenw.20160619131238.28">def draggingSourceOperationMaskForLocal_(self, isLocal):
    print "KWoutlineView.draggingSourceOperationMaskForLocal_(%s)" % repr(isLocal)
    if isLocal:
        return NSDragOperationMove
    else:
        return NSDragOperationCopy

</t>
<t tx="karstenw.20160619131238.29">def draggedImage_endedAt_operation_( self, theImage, theLocation, theOperation):
    print "KWoutlineView.draggedImage_endedAt_operation_(%s)" % theOperation
    if theOperation in (NSDragOperationDelete, NSDragOperationMove):
        # print "lastDrag:"
        # pp(KWOutlineView.lastDrag)
        #deleteNodes(self, nodes=KWOutlineView.lastDrag)
        pass
    # KWOutlineView.lastDrag = []

</t>
<t tx="karstenw.20160619131238.3"># TODO: change parameter to node!
def open_node( url, nodeType=None, open_=False, supressCache=False ):
    if kwdbg:
        print "CactusOutline.open_node()", repr(url)
        # pp( (url,nodeType,open_, supressCache) )

    if chr(10) in url or chr(13) in url:
        return

    # pdb.set_trace()

    # manual quoting
    analyzeEncoding = re.compile(r'[\x00-\x22\x24\x80-\xFF]')
    while True:
        m = analyzeEncoding.search( url )
        if m:
            c = ord(m.group())
            h = hex(c)[2:]
            h = h.rjust(2, '0')
            url = url.replace(m.group(), '%'+h)
        else:
            break
    url = url.replace(" ", '%20')

    purl = urlparse.urlparse( url )
    if m:
        path = purl.path #urllib.quote( purl.path )
        url = urlparse.ParseResult( scheme = purl.scheme, netloc = purl.netloc,
                                    path = path, params = purl.params,
                                    query = purl.query, fragment = purl.fragment)
        # for c in url
        print m
        print repr(url)
        print

    nsurl = NSURL.URLWithString_( url )

    if nsurl == None:
        return

    defaults = NSUserDefaults.standardUserDefaults()
    cache = False
    try:
        cache = bool(defaults.objectForKey_( u'optCache'))
    except StandardError, err:
        print "ERROR reading defaults.", repr(err)

    appl = NSApplication.sharedApplication()
    appdelg = appl.delegate()
    workspace = NSWorkspace.sharedWorkspace()

    basename, ext = getURLExtension( url )
    ext = ext.replace( '.', '', 1)
    ext = ext.lower()

    # do not cache local files
    if url.startswith('file://localhost/') or url.startswith('file:///'):
        supressCache = True

    if nodeType == "OPML" or ext == "opml":
        if cache and not supressCache:
            dummy = CactusTools.cache_url( nsurl, ext )
        if open_:
            appdelg.newOutlineFromURL_Type_( nsurl, CactusOPMLType )
    elif nodeType == "RSS" or ext == "rss":
        if cache and not supressCache:
            dummy = CactusTools.cache_url( nsurl, ext )
        if open_:
            appdelg.newOutlineFromURL_Type_( nsurl, CactusRSSType )
    elif nodeType == "XML" or ext == "xml":
        if cache and not supressCache:
            dummy = CactusTools.cache_url( nsurl, ext )
        if open_:
            appdelg.newOutlineFromURL_Type_( nsurl, CactusXMLType )
    elif nodeType == "HTML" or ext == "html":
        if cache and not supressCache:
            dummy = CactusTools.cache_url( nsurl, ext )
        if open_:
            appdelg.newOutlineFromURL_Type_( nsurl, CactusHTMLType )
            workspace.openURL_( nsurl )

    elif nodeType == "hook":
        if open_:
            workspace.openURLs_withAppBundleIdentifier_options_additionalEventParamDescriptor_launchIdentifiers_(
                [ nsurl ],
                u'com.apple.itunes',
                0,
                None,
                None )
    elif ext in g_qtplayer_extensions or nodeType == "QTPL":
        # qtplayer can do http:
        if cache and not supressCache:
            nsurl = CactusTools.cache_url( nsurl, ext )
        if open_:
            workspace.openURLs_withAppBundleIdentifier_options_additionalEventParamDescriptor_launchIdentifiers_(
                [ nsurl ],
                u'com.apple.quicktimeplayer',
                # u'com.apple.QuickTimePlayerX',
                0,
                None,
                None )
    elif ext in g_preview_extensions:
        if nsurl.isFileURL():
            if open_:
                workspace.openURLs_withAppBundleIdentifier_options_additionalEventParamDescriptor_launchIdentifiers_(
                    [ nsurl ],
                    u'com.apple.Preview',
                    0,
                    None,
                    None )
        else:
            # preview can't do http so open it in the std browser:
            if cache and not supressCache:
                nsurl = CactusTools.cache_url( nsurl, ext )
            if open_:
                workspace.openURL_( nsurl )
    else:
        if cache and not supressCache:
            nsurl = CactusTools.cache_url( nsurl, ext )
        if open_:
            workspace.openURL_( nsurl )

</t>
<t tx="karstenw.20160619131238.30">#
# cell editor notifications
#
def textDidBeginEditing_(self, aNotification):
    print "KWOutlineView.textDidBeginEditing_()"
    """Notification."""
    self.editSession = True

    userInfo = aNotification.userInfo()
    if userInfo:
        pp(userInfo)
    objc.super( KWOutlineView, self).textDidBeginEditing_(aNotification)
    #self.window().makeFirstResponder_(self)


</t>
<t tx="karstenw.20160619131238.31">def textDidChange_(self, aNotification):
    print "KWOutlineView.textDidChange_()"
    """Notification."""
    self.editSession = True
    userInfo = aNotification.userInfo()
    if userInfo:
        textMovement = userInfo.valueForKey_( u"NSTextMovement" ).intValue()

        # NSCancelTextMovement
        if textMovement == NSReturnTextMovement:
            print "RETURN MOVEMENT"
        elif textMovement == NSCancelTextMovement:
            print "CANCEL MOVEMENT"
        elif textMovement == NSTabTextMovement:
            print "NSTabTextMovement"
        elif textMovement == NSBacktabTextMovement:
            print "NSBacktabTextMovement"
        elif textMovement == NSLeftTextMovement:
            print "NSLeftTextMovement"
        elif textMovement == NSRightTextMovement:
            print "NSRightTextMovement"
        elif textMovement == NSUpTextMovement:
            print "NSUpTextMovement"
        elif textMovement == NSDownTextMovement:
            print "NSDownTextMovement"
        elif textMovement == NSOtherTextMovement:
            print "NSOtherTextMovement"
        elif textMovement == NSIllegalTextMovement:
            print "NSIllegalTextMovement"

    objc.super( KWOutlineView, self).textDidChange_(aNotification)
    #self.window().makeFirstResponder_(self)


</t>
<t tx="karstenw.20160619131238.32">def textDidEndEditing_(self, aNotification):
    """Notification. Text editing ended."""

    print "KWOutlineView.textDidEndEditing_()"

    if kwlog and kwdbg:
        print "Edit END"
    userInfo = aNotification.userInfo()
    if kwlog and kwdbg:
        pp(userInfo)
    #textMovement = userInfo.valueForKey_( str("NSTextMovement") ).intValue()

    cancelled = False
    returnContinue = False

    # hm, i want to continue editing with a new node if a return is pressed
    # it looks like the cell editor handles return and enter as the same.

    textMovement = userInfo.valueForKey_( u"NSTextMovement" ).intValue()

    print "TextMovement: %i" % textMovement,

    # check for table/outline editing modes here

    returnInfo = NSMutableDictionary.dictionaryWithDictionary_(userInfo)

    # NSCancelTextMovement
    if textMovement == NSReturnTextMovement:
        print "RETURN MOVEMENT"
        returnContinue = True
        newTextActionCode = NSNumber.numberWithInt_(NSDownTextMovement)
        returnInfo.setObject_forKey_( newTextActionCode, str("NSTextMovement"))
        aNotification = NSNotification.notificationWithName_object_userInfo_(
                    aNotification.name(),
                    aNotification.object(),
                    returnInfo)

    elif textMovement == NSCancelTextMovement:
        print "CANCEL MOVEMENT"
        cancelled = True
        newTextActionCode = NSNumber.numberWithInt_(NSOtherTextMovement)
        returnInfo.setObject_forKey_( newTextActionCode, str("NSTextMovement"))
        aNotification = NSNotification.notificationWithName_object_userInfo_(
                    aNotification.name(),
                    aNotification.object(),
                    returnInfo)

    elif textMovement == NSTabTextMovement:
        print "NSTabTextMovement"
    elif textMovement == NSBacktabTextMovement:
        print "NSBacktabTextMovement"
    elif textMovement == NSLeftTextMovement:
        print "NSLeftTextMovement"
    elif textMovement == NSRightTextMovement:
        print "NSRightTextMovement"
    elif textMovement == NSUpTextMovement:
        print "NSUpTextMovement"
    elif textMovement == NSDownTextMovement:
        print "NSDownTextMovement"
    elif textMovement == NSOtherTextMovement:
        print "NSOtherTextMovement"
    elif textMovement == NSIllegalTextMovement:
        print "NSIllegalTextMovement"
    else:
        print "UNHANDLED MOVEMENT"

    # finish current cell
    objc.super( KWOutlineView, self).textDidEndEditing_(aNotification)

    if returnContinue:
        self.window().makeFirstResponder_(self)
        selRow = self.getSelectedRowIndex()
        item = self.itemAtRow_(selRow)

        if item:
            last = item.isLast()
            if last:
                # we are at the end of the outline
                createNode(self, item, startEditing=True)
            else:
                row = self.rowForItem_( item.next() )
                self.reloadData()
                self.editColumn_row_withEvent_select_(0, row, None, True)
            return
    if cancelled:
        self.editSession = False
        self.reloadData()
        self.window().makeFirstResponder_(self)

</t>
<t tx="karstenw.20160619131238.33">def cancelOperation_(self, sender):
    print "KWOutlineView.cancelOperation_()"
    if self.currentEditor():
        # self.abortEditing()
        self.validateEditing()
    # We lose focus so re-establish
    self.window().makeFirstResponder_(self)

</t>
<t tx="karstenw.20160619131238.34">def setWindowStatus_(self, status):
    ctrl = self.delegate().controller
    ctrl.txtWindowStatus.setStringValue_( unicode(status) )


</t>
<t tx="karstenw.20160619131238.35">#
# event capture
#
def keyDown_(self, theEvent):
    """Catch events for the outline and tableviews. """

    eventCharacters = theEvent.characters()
    eventCharacter = ""
    if eventCharacters:
        eventCharacter = eventCharacters[0]
    eventModifiers = int(theEvent.modifierFlags())
    eventCharNum = ord(eventCharacters)

    mykeys = (ord(NSBackspaceCharacter),
              ord(NSDeleteCharacter),

              ord(NSCarriageReturnCharacter),
              ord(NSEnterCharacter),

              ord(NSTabCharacter),
              ord(NSBackTabCharacter),

              ord(NSUpArrowFunctionKey),
              ord(NSDownArrowFunctionKey),
              ord(NSLeftArrowFunctionKey),
              ord(NSRightArrowFunctionKey) )

    if 0: #eventCharNum in mykeys:
        # pass
        print "mykeys"
        pp(mykeys)
        print "Event characters:", repr(eventCharacters), eventCharNum


    # tab has       0x09/0x00100
    # shift tab has 0x19/0x20102
    # alt   tab has 0x09/0x80120

    # shftalttab    0x19/0xa0122 10.4
    # shftalttab    0x19/0x20102 10.4
    
    # ctrl up 0xf700 0xa40101

    # ctrl opt enter 0x3 0x2c0121
    # enter 0x3 0x200100

    # NSDownArrowFunctionKey
    # NSLeftArrowFunctionKey
    # NSRightArrowFunctionKey
    # NSUpArrowFunctionKey
    # NSUpTextMovement
    #
    # NSBacktabTextMovement
    # NSCancelTextMovement
    # NSDownTextMovement
    # NSIllegalTextMovement
    # NSLeftTextMovement
    # NSOtherTextMovement
    # NSReturnTextMovement
    # NSRightTextMovement
    # NSTabTextMovement
    # NSUpTextMovement

    # unused, just a scribbled idea
    dispatch ={
        # NSCarriageReturnCharacter + SHIFT | ALT | CTRL
        # make a key consisting of char+modifiers
        None: {
            NSBackspaceCharacter: (),
            NSDeleteCharacter: (),
            NSCarriageReturnCharacter: ()
        },

        NSCommandKeyMask: {},
        NSShiftKeyMask: {},
        NSAlternateKeyMask: {},
        NSControlKeyMask: {}
    }

    editor = self.currentEditor()
    if editor:
        print "EDITOR:", editor
    
    if 0:
        print "eventCharNum", eventCharNum

    if eventCharNum not in mykeys:
        objc.super(KWOutlineView, self).keyDown_( theEvent )
        return None

    delg = self.delegate()
    # did we swallow the event or does it need propagation?
    consumed = False

    #
    cmdShiftAlt = NSCommandKeyMask | NSShiftKeyMask | NSAlternateKeyMask

    # filter out other stuff
    eventModifiers &amp;= NSDeviceIndependentModifierFlagsMask

    if kwlog and 0: #kwdbg:
        print "Key: ", hex(eventCharNum), hex(eventModifiers)

    ###########################################################################
    #
    # Deleting
    if eventCharacter in (NSBackspaceCharacter, NSDeleteCharacter):
        if kwlog and kwdbg:
            print "DELETE KEY HANDLED"

        # while editing, will be handled elsewhere
        # outline: delete selection (saving to a pasteboard stack) TBD
        # table: delete selection (saving to a pasteboard stack) Tables will be
        #        deleted in the future
        deleteNodes(self, selection=True)

        # deselect all or find a good way to select the next item
        delg.markDirty()
        self.deselectAll_( None )

    ###########################################################################
    #
    # Create new node
    elif eventCharacter == NSCarriageReturnCharacter:
        if eventModifiers &amp; NSShiftKeyMask:
            if kwlog and kwdbg:
                print "SHIFT Return"
        else:
            if kwlog and kwdbg:
                print "KEY: Return"
            # open new line and start editing

            # TODO: if already editing, start new line, continue editing

            #
            sel = self.getSelectedRow()
            createNode(self, sel)
            consumed = True

    ###########################################################################
    #
    # Enter
    elif eventCharacter == NSEnterCharacter:
        # cmd+alt enter
        # cmd enter
        # cmd shift enter
        # cmd alt shift enter

        if eventModifiers &amp; (cmdShiftAlt | NSControlKeyMask):

            appl = NSApplication.sharedApplication()
            appdelg = appl.delegate()
            workspace= NSWorkspace.sharedWorkspace()

            ###################################################################
            #
            # Control (Alt) Enter
            if eventModifiers &amp; NSControlKeyMask:

                ###############################################################
                #
                # Control Alt Enter
                #
                # open a node
                #
                #
                # This stuff needs serious refactoring. Opening nodes was and still
                # is a great idea but this ad hoc implementation has too many
                # repetitions and logic holes.
                #
                # A separate function that analyses the node, perhaps sets a menu,
                # and opens it should do the trick.
                #
                
                if eventModifiers &amp; NSAlternateKeyMask:

                    # get node selection
                    items = self.getSelectionItems()
                    
                    # get base url
                    # should be used later on
                    baseurl = ""
                    try:
                        ctrl = self.delegate().controller
                        doc = ctrl.document()
                        baseurl = doc.url
                    except:
                        pass
                    # do the selection
                    for item in items:
                        name = item.name

                        url = u""

                        #
                        # make a handler here
                        #
                        # opml, html, rss, js, xml(generic)
                        #
                        # for generic xml make getOPML a getXML with params
                        #

                        # in a table or in html
                        
                        #
                        # CHECK DOCUMENT TYPE HERE
                        #

                        # TABLE, HTML
                        if name == 'link':
                            d = item.getValueDict()
                            type = d.get('type', '')
                            href = d.get('href', '')
                            url = cleanupURL( href )
                            nodetype = None
                            # some of the mediatypes listed at en.wikipedia.org
                            if type == u"application/rss+xml":
                                nodetype = "RSS"
                            elif type == u"application/opml+xml":
                                nodetype = "RSS"
                            elif type == u"application/atom+xml":
                                nodetype = "RSS"
                            elif type == u"application/xhtml+xml":
                                nodetype = "HTML"
                            elif type == u"application/xml":
                                # perhaps xml, perhaps opml, perhaps rss
                                if "rss" in title.lower():
                                    nodetype = "RSS"
                                elif "outline" in title.lower():
                                    nodetype = "OPML"
                                else:
                                    nodetype = "XML"

                            if not url.startswith( 'http' ):
                                # get base url via controller
                                root = item.rootNode
                                ctrl = root.controller
                                urlbase = False
                                if ctrl != None:
                                    urlbase = ctrl.nsurl()
                                    if urlbase:
                                        target = NSURL2str(urlbase.absoluteString())
                                        url = mergeURLs( target, url )
                            open_node( url, nodetype )

                        elif name in ('script', 'source'):
                            d = item.getValueDict()
                            href = d.get('src', '')
                            url = cleanupURL( href )

                            # code duplication
                            if not url.startswith( 'http' ):
                                # get base url via controller
                                root = item.rootNode
                                ctrl = root.controller
                                urlbase = False
                                if ctrl != None:
                                    urlbase = ctrl.nsurl()
                                    if urlbase:
                                        target = NSURL2str(urlbase.absoluteString())
                                        url = mergeURLs( target, url )
                            open_node(url)

                        elif name in ('a', 'img'):
                            d = item.getValueDict()
                            href = d.get('href', '')
                            if name == 'img':
                                href = d.get('src', '')
                            url = cleanupURL( href )

                            # code duplication
                            if not url.startswith( 'http' ):
                                # get base url via controller
                                root = item.rootNode
                                ctrl = root.controller
                                urlbase = False
                                if ctrl != None:
                                    urlbase = ctrl.nsurl()
                                    if urlbase:
                                        target = NSURL2str(urlbase.absoluteString())
                                        url = mergeURLs( target, url )

                            basename, extension = getURLExtension(url)
                            if extension:
                                extension = extension.replace('.', '')

                            if extension in g_qtplayer_extensions:
                                open_node(url, 'QTPL')
                            elif extension in g_preview_extensions:
                                open_node(url)
                            elif extension == '':
                                open_node(url, 'HTML')
                            else:
                                # here should be automatic content handling
                                open_node(url)
                        
                        elif name in ('url', 'htmlUrl', 'xmlUrl', 'xmlurl'):
                            #
                            # FIXING HACK
                            # url = item.value
                            url = item.displayValue
                            url = cleanupURL( url )
                            open_node( url )

                        elif name[:3] in ("&lt;im", "&lt;ht", "&lt;a " ):
                            # for now this seems like a speciality of FC...
                            # no attributes but a &lt;img&gt; in name
                            d = item.getValueDict()
                            if not d:
                                print name
                                soup = BeautifulSoup(name)
                                for link in soup.find_all('img'):
                                    dest = link.get('src')
                                    # print dest
                                    open_node(dest)
                                for link in soup.find_all('a'):
                                    dest = link.get('href')
                                    # print dest
                                    open_node(dest)
                            else:
                                type = d.get('type', '')
                                href = d.get('url', '')
                                open_node(href)
                                # http://example.com/elsie
                                # http://example.com/lacie

                        # in an outline
                        else:
                            #
                            v = item.getValueDict()
                            theType = v.get("type", "")
                            url = ""
                            if 'url' in v:
                                url = v.get("url", "")
                            elif 'link' in v:
                                url = v.get("link", "")
                            elif 'URL' in v:
                                url = v.get("URL", "")

                            url = cleanupURL( url )

                            if theType == "blogpost":
                                if not url:
                                    url = v.get("urlTemplate", "")
                                    url = cleanupURL( url )
                                if url:
                                    open_node( url )
                            elif theType in ( 'redirect', ):
                                open_node( url, "HTML" )

                            elif theType in ( 'howto', 'html', 'include', 'outline',
                                              'redirect', 'thumbList', 'import',
                                              'thumbListVarCol', 'code', 'audio'):
                                open_node( url )

                            elif theType in ('link', ):
                                nodeType=None
                                if "opml.radiotime.com" in url:
                                    nodeType = "OPML"
                                open_node( url, nodeType )

                            elif theType in ('audio', ):
                                #
                                # make this it's own function
                                #
                                # see urllib._urlopener,
                                #
                                # sometimes the stream is indirected several layers...

                                audiourl, info = urllib.urlretrieve( url )
                                faudio = open(audiourl)
                                url = faudio.read()
                                url = url.strip('\r\n')
                                faudio.close()
                                # baseurl, ext = os.path.splitext(url)
                                if '\n' in url:
                                    url = url.split('\n')[0]
                                open_node( url,
                                           "hook",
                                           open_=True,
                                           supressCache=True)

                            elif theType == "photo":
                                url = v.get("xmlUrl", "")
                                open_photo( url )

                            elif theType == "rssentry":
                            
                                # find pref for opening enclosures
                                defaults = NSUserDefaults.standardUserDefaults()
                                openAttach = False
                                try:
                                    openAttach = bool(defaults.objectForKey_( u'optRSSOpenEnclosure'))
                                except Exception ,err:
                                    print "Error reading defaults:", err

                                # extract enclosure URL
                                enc = v.get("enclosure", "")
                                url1 = ""
                                if enc:
                                    url1, rest = enc.split('&lt;&lt;&lt;')

                                # extract webpage url
                                url2 = v.get("link", "")
                                url2 = cleanupURL( url2 )

                                # open the stuff
                                if url1 and openAttach:
                                    open_node( url1 )
                                if url2:
                                    open_node( url2, nodeType="HTML" )

                            elif theType == "river":
                                opmlUrl = v.get("opmlUrl", "")
                                if opmlUrl:
                                    opmlUrl = cleanupURL( opmlUrl )
                                    appdelg.newOutlineFromURL_Type_( opmlUrl,
                                                                     CactusOPMLType )

                            elif theType == "rss":

                                # open website
                                htmlUrl = v.get("htmlUrl", "")
                                htmlUrl = cleanupURL( htmlUrl )
                                if htmlUrl:
                                    open_node( htmlUrl, nodeType="HTML")

                                # open rss
                                xmlUrl = v.get("xmlUrl", "")
                                xmlUrl = cleanupURL( xmlUrl )
                                if xmlUrl:
                                    open_node( xmlUrl, nodeType="RSS")

                            elif theType == "scripting2Post":
                                open_node( url, nodeType="HTML")
                            else:
                                #print "Unhandled Node open\ntype: '%s'\nurl: '%s'" % (repr(theType), repr(url))
                                open_node( url )

                        consumed = True

                ###############################################################
                #
                # Control Enter
                else:
                    # ctrl enter
                    items = self.getSelectionItems()
                    for item in items:
                        if item.value:
                            title = item.name

                            # stop it if we are in a table
                            if item.typ not in CactusOutlineTypes.hierarchicalTypes:
                                continue

                            # build a new document from current attributes
                            root = OutlineNode(u"__root__", u"", None,
                                               CactusOutlineTypes.typeOutline, None)
                            for t in item.value:
                                if isinstance(t, tuple):
                                    name, value = t
                                elif isinstance(t, str):
                                    name = u"value"
                                    value = t
                                node = OutlineNode(name, value, root, CactusOutlineTypes.typeTable, root)
                                root.addChild_(node)

                            #
                            # TBD: eliminate tables, move to outlines, reactivate next line
                            #
                            appdelg.newTableWithRoot_fromNode_(root, item)
                    consumed = True

            ###################################################################
            #
            # not control but some combination of cmdShiftAlt
            else:
                pass

            ###################################################################
            #
            #
            if eventModifiers &amp; NSShiftKeyMask:
                if eventModifiers &amp; NSAlternateKeyMask:
                    if kwlog and kwdbg:
                        print "SHIFT ALT Enter"
                else:
                    if kwlog and kwdbg:
                        print "SHIFT Enter"

                    nodes = visitOutline(delg.root)
                    consumed = True

        #######################################################################
        #
        # Enter
        else:
            # start editing

            # current row
            index = self.getSelectedRowIndex()

            #
            edited = self.editedRow()
            if edited == -1:
                if index != -1:
                    #start editing
                    if kwdbg:
                        print "Edit START"
                    self.editColumn_row_withEvent_select_(0, index, None, True)
                    consumed = True
                else:
                    # empty selection
                    pass
            else:
                # editing in progreess with row 'edited'
                # how to stop?
                pass

    ###########################################################################
    #
    # Outdenting
    elif eventCharacter == NSBackTabCharacter:
        # shift tab has it's own character
        if eventModifiers &amp; NSShiftKeyMask:
            consumed = self.outdentSelection()

    ###########################################################################
    #
    # Indenting
    elif eventCharacter == NSTabCharacter:
        # indent selection
        consumed = self.indentSelection()

    ###########################################################################
    #
    # Move selection up
    elif eventCharacter == NSUpArrowFunctionKey:
        if eventModifiers &amp; NSControlKeyMask:
            consumed = self.moveSelectionUp()

    ###########################################################################
    #
    # Move selection down
    elif eventCharacter == NSDownArrowFunctionKey:
        if eventModifiers &amp; NSControlKeyMask:
            consumed = self.moveSelectionDown()

    ###########################################################################
    # ctrl-left
    # select parent node
    #
    # ctrl-alt-left
    # select parent node and colapse all
    #
    elif eventCharacter == NSLeftArrowFunctionKey:
        if eventModifiers &amp; NSControlKeyMask:

            # get selected rows
            items = self.getSelectionItems()
            selection = []
            collapse = eventModifiers &amp; NSAlternateKeyMask
            for item in items:
                parent = item.parent
                if parent:
                    selection.append( parent )
            if selection:
                if collapse:
                    for item in selection:
                        self.collapseItem_collapseChildren_(item, True)
                selection = [self.rowForItem_(i) for i in selection]
                self.selectItemRows_( selection )

                # make first selection item visible
                if selection:
                    first = selection[0]
                    rowRect = self.rectOfRow_( first )
                    self.scrollRowToVisible_( first )

            self.setNeedsDisplay_( True )
            consumed = True

    ###########################################################################
    # ctrl-right
    # select children
    #
    # ctrl-alt-right
    # select children and expand
    #
    elif eventCharacter == NSRightArrowFunctionKey:
        if eventModifiers &amp; NSControlKeyMask:

            # get selected rows
            items = self.getSelectionItems()

            selection = []

            expandChildren = eventModifiers &amp; NSAlternateKeyMask

            for item in items:
                children = item.children
                if children:
                    self.expandItem_( item )
                    selection.extend( children )
            if len(selection) &gt; 0:
                if expandChildren:
                    for child in selection:
                        if self.isExpandable_( child ):
                            self.expandItem_expandChildren_(child, False)
                # convert items back to indices
                selection = [self.rowForItem_(i) for i in selection]
                self.selectItemRows_( selection )

                # make first selection item visible
                if selection:
                    first = selection[0]
                    rowRect = self.rectOfRow_( first )
                    ##
                    # an attempt to scroll top selection
                    #
                    # x, y = rowRect.origin.x, rowRect.origin.y
                    # selfRect = self.bounds()
                    # deltaH = selfRect.size.height / 2
                    # y += deltaH
                    # 
                    # print "ScrollTo_( %s, %s )" % (repr(x), repr(y))
                    # self.superview().scrollToPoint_( NSMakePoint( x, y ) )
                    self.scrollRowToVisible_( first )

            self.setNeedsDisplay_( True )
            consumed = True
    if not consumed:
        objc.super(KWOutlineView, self).keyDown_( theEvent )

</t>
<t tx="karstenw.20160619131238.36">#
# key event handlers
#
def moveSelectionDown(self):
    delegate = self.delegate()
    # get selected rows
    items = self.getSelectionItems()
    if not items:
        return False
    #
    moveSelectionDown(self, items)
    delegate.markDirty()
    self.reloadData()

    selection = [self.rowForItem_(i) for i in items]
    if selection:
        self.selectItemRows_( selection )

    self.setNeedsDisplay_( True )
    return True

</t>
<t tx="karstenw.20160619131238.37">def moveSelectionUp(self):
    delegate = self.delegate()
    # get selected rows
    items = self.getSelectionItems()
    if not items:
        return False
    moveSelectionUp(self, items)
    #
    delegate.markDirty()
    self.reloadData()

    selection = [self.rowForItem_(i) for i in items]
    if selection:
        self.selectItemRows_( selection )

    self.setNeedsDisplay_( True )
    return True
    


</t>
<t tx="karstenw.20160619131238.38">def indentSelection(self):

    delegate = self.delegate()

    # get selected rows
    consumed = False
    if delegate.typ in CactusOutlineTypes.hierarchicalTypes:
        sel = self.getSelectionItems()
        # indent each row one level
        postselect = set()
        for item in sel:
            if not item:
                continue
            parent = item.parent
            previous = item.previous()

            # ignore command if item is first Child
            if previous != -1:
                item.retain()
                previous.addChild_( item )
                parent.removeChild_(item)
                item.release()
                postselect.add(item)
                self.reloadItem_reloadChildren_( previous, True )
                self.expandItem_( previous )
                self.reloadItem_reloadChildren_( parent, True )

        # restore selection
        postselect = [self.rowForItem_(i) for i in postselect]
        if postselect:
            self.selectItemRows_( postselect )
            delegate.markDirty()
            consumed = True
        self.reloadData()
        return consumed

</t>
<t tx="karstenw.20160619131238.39">def outdentSelection(self):
    if kwlog:
        print "SHIFT Tab"

    delegate = self.delegate()

    consumed = False
    if delegate.typ in CactusOutlineTypes.hierarchicalTypes:
        # get selected rows
        sel = self.getSelectionItems()
        if not sel:
            return

        # working from the end
        sel.reverse()

        # dedent each row one level
        for item in sel:
            item.moveLeft()

        self.reloadData()

        # restore selection
        postselect = [self.rowForItem_(i) for i in sel]
        if postselect:
            self.selectItemRows_( postselect )

        consumed = True
        delegate.markDirty()
        # self.reloadData()
    return consumed
</t>
<t tx="karstenw.20160619131238.4">def handleEventReturnKeyOV_Event_( ov, event ):
    pass


</t>
<t tx="karstenw.20160619131238.40">#
# utilities
#
def getSelectionItems(self):
    if kwlog:
        print "getSelectionItems"
    """The actual nodes of the current selection are returned."""
    sel = self.selectedRowIndexes()
    result = []
    n = 0
    if sel:
        n = sel.count()
        if not n:
            return result
    next = sel.firstIndex()
    result.append( self.itemAtRow_(next) )

    for i in range(1, n):
        next = sel.indexGreaterThanIndex_(next)
        result.append( self.itemAtRow_(next) )
    return result

</t>
<t tx="karstenw.20160619131238.41">def getSelectedRow(self):
    sel = self.getSelectedRowIndex()
    if sel == -1:
        return sel
    item = self.itemAtRow_(sel)
    return item

</t>
<t tx="karstenw.20160619131238.42">def getSelectedRowIndex(self):
    return self.selectedRow()

</t>
<t tx="karstenw.20160619131238.43">def selectItemRows_( self, itemIndices ):
    s = NSMutableIndexSet.indexSet()
    for i in itemIndices:
        if i &gt;= 0:
            s.addIndex_( i )
    self.selectRowIndexes_byExtendingSelection_(s, False)

</t>
<t tx="karstenw.20160619131238.44">def selectItems_(self, items):
    self.deselectAll_( None )
    indexes = NSMutableIndexSet.alloc().init()
    for item in items:
        idx = self.rowForItem_( item )
        if idx != -1:
            indexes.addIndex_( idx )
    self.selectRowIndexes_byExtendingSelection_(indexes, False)


</t>
<t tx="karstenw.20160619131238.45">def selectRowItem_(self, item):
    index = self.rowForItem_( item )
    s = NSIndexSet.indexSetWithIndex_( index )
    self.selectRowIndexes_byExtendingSelection_(s, False)

</t>
<t tx="karstenw.20160619131238.46">@objc.IBAction
def expandSelection_(self, sender):
    items = self.getSelectionItems()
    for item in items:
        self.expandItem_(item)

</t>
<t tx="karstenw.20160619131238.47">@objc.IBAction
def expandAllSelection_(self, sender):
    items = self.getSelectionItems()
    for item in items:
        self.expandItem_expandChildren_(item, True)

</t>
<t tx="karstenw.20160619131238.48">def collapseSelection_(self, sender):
    items = self.getSelectionItems()
    for item in items:
        self.collapse_(item)

</t>
<t tx="karstenw.20160619131238.49">def collapseAllSelection_(self, sender):
    items = self.getSelectionItems()
    for item in items:
        self.collapseItem_collapseChildren_(item, True)

</t>
<t tx="karstenw.20160619131238.5">class KWOutlineView(NSOutlineView):
    """Subclass of NSOutlineView; to catch keys."""

    lastDrag = []

    @others
</t>
<t tx="karstenw.20160619131238.50">def collapseToParent_(self, sender):
    items = self.getSelectionItems()
    parents = []
    for item in items:
        parents.append( item.parent )
        self.collapseItem_collapseChildren_(item, True)
    for parent in parents:
        self.collapseItem_collapseChildren_(parent, True)
    postselect = [self.rowForItem_(item) for item in parents]
    self.selectItemRows_( postselect )


</t>
<t tx="karstenw.20160619131238.51">class NiceError(object):
    """Wrapper for an exception so we can display it nicely in the browser."""
    @others
</t>
<t tx="karstenw.20160619131238.52">
def __init__(self, exc_info):
    self.exc_info = exc_info

</t>
<t tx="karstenw.20160619131238.53">def __repr__(self):
    from traceback import format_exception_only
    lines = format_exception_only(*self.exc_info[:2])
    assert len(lines) == 1
    error = lines[0].strip()
    return "*** error *** %s" %error

</t>
<t tx="karstenw.20160619131238.54">#
# Nodewalk
#
def stdAction( node, level ):
    # Debugging HACK
    s = "  " * level
    s = s + unicode(node)
    n = str(node.retainCount())
    n = n.ljust(4)
    s = n + s
    print s.encode("utf-8")


</t>
<t tx="karstenw.20160619131238.55">def visitOutline(startnode, startlevel=0, depthFirst=False, action=stdAction):
    # Debugging HACK
    action(startnode, startlevel)
    if len(startnode.children) &gt; 0:
        for p in startnode.children:
            visitOutline(p, startlevel+1, depthFirst, action)
    return

</t>
<t tx="karstenw.20160619131238.56"># UNUSED
def dfid(T,children,callback=stdAction):
    # some ActiveState snippet
    def visit(node,i):
        if i == 0:
            callback(node, i)
        else:
            for c in node.children:
                visit(c,i-1)
    i = 0
    while 1:
        visit(T,i)
        i += 1


</t>
<t tx="karstenw.20160619131238.57">#
# Outline Document Model
#
class OutlineViewDelegateDatasource(NSObject):
    """This is a delegate as well as a data source for NSOutlineViews."""
    @others
    #def outlineView_didClickTableColumn_(self, view, tablecolumn):
    #    pass

    # interresting delegate methods:
    # Delegate
    # outlineView:dataCellForTableColumn:item:
    # outlineView:didClickTableColumn:
    # outlineView:heightOfRowByItem:
    # outlineView:isGroupItem: 10.5
    # outlineView:shouldCollapseItem:
    # outlineView:shouldExpandItem:
    # outlineView:shouldSelectItem:
    # outlineView:shouldSelectTableColumn:
    # outlineView:shouldShowCellExpansionForTableColumn:item: 10.5
    # outlineView:shouldTrackCell:forTableColumn:item: 10.5
    # outlineView:toolTipForCell:rect:tableColumn:item:mouseLocation:
    # outlineView:willDisplayCell:forTableColumn:item:
    # outlineView:willDisplayOutlineCell:forTableColumn:item:
    # outlineViewColumnDidMove:
    # outlineViewColumnDidResize:
    # outlineViewItemDidCollapse:
    # outlineViewItemDidExpand:
    # outlineViewItemWillCollapse:
    # outlineViewItemWillExpand:
    # outlineViewSelectionDidChange:
    # outlineViewSelectionIsChanging:
    # selectionShouldChangeInOutlineView:

    # Notifications
    # NSOutlineViewColumnDidMoveNotification
    # NSOutlineViewColumnDidResizeNotification
    # NSOutlineViewItemDidCollapseNotification
    # NSOutlineViewItemDidExpandNotification
    # NSOutlineViewItemWillCollapseNotification
    # NSOutlineViewItemWillExpandNotification
    # NSOutlineViewSelectionDidChangeNotification
    # NSOutlineViewSelectionIsChangingNotification


</t>
<t tx="karstenw.20160619131238.58">
#
# instantiated from AppDelegate
#
# no bindings
#
# ivars
#
#   typ
#   parentNode
#   root
#   controller
#   document
#   outlineView
#   restricted

def init(self):
    self = objc.super(OutlineViewDelegateDatasource, self).init()
    if not self:
        return None
    self.typ = None
    self.parentNode = None
    self.root = None
    self.controller = None
    self.document = None
    self.outlineView = None

    # not yet used; it's an idea for rss documents to constrain node movements.
    self.restricted = False
    return self

</t>
<t tx="karstenw.20160619131238.59">def dealloc(self):
    print "OutlineViewDelegateDatasource.dealloc()"
    #if self.parentNode:
    #    self.parentNode.release()
    if self.root:
        # this is evil and does not work
        n = self.root.retainCount()
        for i in range(n):
            self.root.release()
        self.root=None
    if self.controller:
        print "TODO OutlineViewDelegateDatasource.controller.release()", self.controller.retainCount()

    #    self.controller.release()
    if self.document:
        print "TODO OutlineViewDelegateDatasource.document.release()", self.document.retainCount()
    #    self.document.release()
    objc.super(OutlineViewDelegateDatasource, self).dealloc()

</t>
<t tx="karstenw.20160619131238.6">def awakeFromNib(self):
    self.editSession = False

    # manual en- &amp; disabling menu items
    self.clipboardRoot = OutlineNode("Clipboard root", "", None, typeOutline, None)
    menu = NSMenu.alloc().initWithTitle_( u"" )
    menu.setDelegate_(self)
    menu.addItemWithTitle_action_keyEquivalent_( u"Include",
                                                  "contextMenuInclude:", u"")
    #
    # deactivated since regular cut, copy and paste have arrived
    #
    #menu.addItemWithTitle_action_keyEquivalent_( u"Python Copy",
    #                                              "copySelectionPython:", u"")
    #menu.addItemWithTitle_action_keyEquivalent_( u"Node Copy",
    #                                              "copySelectionNodes:", u"")
    #menu.addItemWithTitle_action_keyEquivalent_( u"Node paste",
    #                                              "pasteSelectionNodes:", u"")

    menu.addItemWithTitle_action_keyEquivalent_( u"Insert Safari links",
                                                  "insertSafariLinks:", u"")
    menu.addItemWithTitle_action_keyEquivalent_( u"Insert Safari images",
                                                  "insertSafarimages:", u"")
    # copySelectionPython_
    menu.setAutoenablesItems_(False)
    self.registerForDraggedTypes_( [DragDropCactusPboardType,
                                    NSFilenamesPboardType,
                                    NSStringPboardType] )
    self.setVerticalMotionCanBeginDrag_( False )
    #self.setDraggingSourceOperationMask_forLocal_( NSDragOperationEvery, True )
    #self.setDraggingSourceOperationMask_forLocal_( NSDragOperationAll_Obsolete, False )
    
    self.setMenu_(menu)

</t>
<t tx="karstenw.20160619131238.60">def initWithObject_type_parentNode_(self, obj, typ, parentNode):
    self = self.init()

    if not self:
        return None

    self.typ = typ
    self.parentNode = parentNode

    if not isinstance(obj, OutlineNode):
        obj = OutlineNode(unicode(obj), "", None, CactusOutlineTypes.typeOutline, None)
    self.root = obj

    return self

</t>
<t tx="karstenw.20160619131238.61">def setOutlineView_(self, ov):
    if self.outlineView:
        self.outlineView.release()
    self.outlineView = ov

</t>
<t tx="karstenw.20160619131238.62">def markDirty(self):
    doc = self.controller.document()
    if doc:
        doc.updateChangeCount_( NSChangeDone )


</t>
<t tx="karstenw.20160619131238.63">def setController_(self, controller):
    self.controller = controller

</t>
<t tx="karstenw.20160619131238.64">def reloadData_(self, item):
    if self.controller:
        self.controller.reloadData_(item)
    else:
        if kwlog:
            print "FAILED: reloadData_(%s)" % repr(item)

</t>
<t tx="karstenw.20160619131238.65">def isSubEditor(self):
    return self.parentNode != None

</t>
<t tx="karstenw.20160619131238.66">def appendToRoot_Value_(self, name, value):
    node = OutlineNode(name, value, self.root, self.typ, self.root)
    self.root.addChild_( node )
    # need to reload all so the new node gets recognized
    self.reloadData_( node )
    idx = self.controller.outlineView.rowForItem_( node )
    return idx

</t>
<t tx="karstenw.20160619131238.67">#
# tableview delegate
#
# numberOfRowsInTableView:
def tableView_objectValueForTableColumn_row_(self, tv, column, row):
    c = col.identifier()
    item = self.root.childAtIndex_( row )
    if c == u"type":
        return item.type
    elif c == u"value":
        return item.displayValue
    elif c == u"name":
        return item.name
    elif c == u"comment":
        return item.comment


</t>
<t tx="karstenw.20160619131238.68">def numberOfRowsInTableView_(self, tv):
    print "numberOfRowsInTableView_"
    return self.root.children.count()


</t>
<t tx="karstenw.20160619131238.69">def outlineViewColumnDidResize_(self, aNotification):
    userInfo = aNotification.userInfo()
    column = userInfo.valueForKey_( u"NSTableColumn" )
    oldWidth = userInfo.valueForKey_( u"NSOldWidth" ).intValue()
    newWidth = column.width()
    # print "COL: '%s' changed from: %i  to  %i" % (column.identifier(),
    #                                               oldWidth, newWidth)

</t>
<t tx="karstenw.20160619131238.7">#
# context menu handlers
#
# The initial and currently static context menu is defined in awakeFromNib
#

def menuForEvent_(self, theEvent):
    """This makes the selection include the right-click row"""
    row = self.rowAtPoint_( self.convertPoint_fromView_(
                            theEvent.locationInWindow(),
                            None ))
    if row != -1:
        s = NSIndexSet.indexSetWithIndex_( row )
        self.selectRowIndexes_byExtendingSelection_(s, True)
        # self.selectRow_byExtendingSelection_(row, True)
    return objc.super( KWOutlineView, self).menuForEvent_(theEvent)

</t>
<t tx="karstenw.20160619131238.70">def tableViewColumnDidResize_(self, aNotification):
    # for some reaon only th outlineView delegate is called. Even for tables
    pass

</t>
<t tx="karstenw.20160619131238.71">#
# NSOutlineViewDataSource  methods
#
def outlineView_numberOfChildrenOfItem_(self, view, item):
    if not item:
        item = self.root
    return item.noOfChildren()

</t>
<t tx="karstenw.20160619131238.72">def outlineView_child_ofItem_(self, view, child, item):
    if not item:
        item = self.root
    return item.childAtIndex_( child )

</t>
<t tx="karstenw.20160619131238.73">def outlineView_isItemExpandable_(self, view, item):
    if not self.typ in CactusOutlineTypes.hierarchicalTypes:
        return False
    if not hasattr(item, 'noOfChildren'):
        print
        print "ITEM", repr(item)
        return False
    return item.noOfChildren() &gt; 0

</t>
<t tx="karstenw.20160619131238.74">def outlineView_objectValueForTableColumn_byItem_(self, view, col, item):
    c = col.identifier()
    if not item:
        item = self.root
    if c == u"type":
        return item.type
    elif c == u"value":
        return item.displayValue
    elif c == u"name":
        return item.name
    elif c == u"comment":
        return item.comment


</t>
<t tx="karstenw.20160619131238.75">def outlineView_setObjectValue_forTableColumn_byItem_(self, view, value, col, item):
    columnName = col.identifier()

    if not item:
        return

    if columnName == u"type":
        pass

    elif columnName == u"value":
        if value != item.displayValue:
            # if it has a parentNode it's edited attributes
            if self.parentNode != None:
                name = item.name
                self.parentNode.updateValue_( (name, unicode(value)) )
            item.setValue_( value )
            self.markDirty()

    elif columnName == u"name":
        if value != item.name:
            item.setName_(value)
            self.markDirty()

    elif columnName == u"comment":
        if value != item.comment:
            item.setComment_(value)
            self.markDirty()


</t>
<t tx="karstenw.20160619131238.76">#
# drag and drop
#
def outlineView_acceptDrop_item_childIndex_(self, ov, info, targetItem, index):
    print "DELG.outlineView_acceptDrop_item_childIndex_"

    pb = info.draggingPasteboard()
    # pp(info)

    if 1:
        print "targetItem:", repr(targetItem)
        print "index", repr(index)
        print "info", repr(info)

    if targetItem:
        # drop on item
        targetIndex = targetItem.siblingIndex()
        if index &gt;= 0:
            # between two nodes
            pass
        else:
            # on a node
            pass
    else:
        targetIndex = None
        # drop in view
        # append to last
        if index &gt;= 0:
            pass
        else:
            pass

    # check source here
    insertedItems = ov.readNodesFromPasteboard_parent_index_(pb, targetItem, index)

    # delete origin - feels hackish accessing a class variable
    # originals must be deleted after insertion
    # 
    deleteNodes(ov, nodes=KWOutlineView.lastDrag)
    KWOutlineView.lastDrag = []
    ov.selectItems_( insertedItems )

    if 0:
        for item in insertedItems:
            index = ov.rowForItem_( item )
            print "selectionIndex:", index, item
            if index != -1:
                s = NSIndexSet.indexSetWithIndex_( index )
                ov.selectRowIndexes_byExtendingSelection_(s, True)

    ov.reloadData()
    ov.setNeedsDisplay_( True )
    ov.reloadItem_reloadChildren_(None, True)


    return True


</t>
<t tx="karstenw.20160619131238.77">def outlineView_validateDrop_proposedItem_proposedChildIndex_(self, ov, dragInfo, item, index):
    if 0 and kwdbg:
        # deactivated. very noysy
        print "DELG.outlineView_validateDrop_proposedItem_proposedChildIndex_"

    if dragInfo.draggingSource() == self.outlineView:
        # print "drag in outlineView()!"
        # print item
        # pp(dragInfo)
        #if index == NSOutlineViewDropOnItemIndex:
        #    return NSDragOperationMove
        #else:
        #    return NSDragOperationNone

        #if not item:
        #    pass
        # self.setDropItem_dropChildIndex_(item, NSOutlineViewDropOnItemIndex)
        return NSDragOperationMove
    else:
        # external drop - not now
        # print "source:", dragInfo.draggingSource()
        return NSDragOperationCopy

    return NSDragOperationNone


</t>
<t tx="karstenw.20160619131238.78">def outlineView_writeItems_toPasteboard_(self, ov, items, pb):
    if kwdbg:
        print "DELG.outlineView_writeItems_toPasteboard_"

    pb.declareTypes_owner_( [DragDropCactusPboardType],
                            self)
    # items = ov.getSelectionItems()

    # pack items
    result = []
    names = []
    for item in items:
        result.append( item.copyPython())
        names.append( item.name )

    data = cPickle.dumps( result )
    l = len(data)
    nsdata = NSData.dataWithBytes_length_(data, l)
    pb.setData_forType_(
        nsdata,
        DragDropCactusPboardType)
    KWOutlineView.lastDrag = list(items)
    #pb.setString_forType_(
    #    u"\n".join(names),
    #    NSStringPboardType)
    
    return True


</t>
<t tx="karstenw.20160619131238.79"># delegate method

def outlineView_heightOfRowByItem_(self, ov, item):
    lineheight = 14
    maxLines = self.controller.rowLines

    if not self.controller.variableRowHeight:
        return lineheight

    lines = min( maxLines, int(item.maxHeight))
    lines = max(1, lines)
    return lines * lineheight

</t>
<t tx="karstenw.20160619131238.8">def validateMenuItem_(self, sender):
    # row = self.selectedRow()
    if kwlog:
        print "KWOutlineView.validateMenuItem_( %s )" % repr(sender)
    return True

</t>
<t tx="karstenw.20160619131238.80">def outlineView_shouldEditTableColumn_item_(self, ov, col, item):
    columnName = col.identifier()
    if columnName == u"type":
        return False
    return True

</t>
<t tx="karstenw.20160619131238.81"># UNUSED
def ovUpdateItem_Key_Value_(self, item, key, value):
    # update a single key value pair in the value dict
    pass

</t>
<t tx="karstenw.20160619131238.82">def outlineViewSelectionDidChange_( self, aNotification ):
    if kwdbg:
        print "outlineViewSelectionDidChange_()"
    ov = None
    if aNotification:
        #print aNotification
        ov = aNotification.object()
        if not isinstance(ov, KWOutlineView):
            ov = False
    if ov:
        sel = ov.selectedRowIndexes()
        n = sel.count()

        if n == 1:
            # show node info
            next = sel.firstIndex()
            item = ov.itemAtRow_(next)
            level = ov.levelForRow_( next )
            name = item.name
            if len(name) &gt; 33:
                name = name[:30] + "..."
            s = "Lev: %i  height: %i %s" % (level, item.maxHeight, name)
        else:
            # show selection info
            s = u"%i nodes selected" % (n,)
        ov.setWindowStatus_( s )


</t>
<t tx="karstenw.20160619131238.83">#
# node editing
#
# TODO: deleting does not update correctly.
# line stays visible in parent view. needsRedraw_?
#
def deleteNodes(ov, nodes=(), selection=False):
    if kwdbg:
        print "CactusOutline.deleteNodes()"
    if selection:
        sel = ov.getSelectionItems()
    else:
        sel = nodes
    delg = ov.delegate()
    parentNode = delg.parentNode
    for item in sel:
        p = item.parent
        deleted = True
        if parentNode:
            deleted = parentNode.removeValue_( (item.name, item.value) )
        if deleted:
            p.removeChild_( item )
            delg.markDirty()
    ov.reloadData()

</t>
<t tx="karstenw.20160619131238.84">def createNode(ov, selection, startEditing=True):
    if kwdbg:
        print "CactusOutline.createNode()"
    # create node at selection and start editing

    # open new line and start editing
    # if already editing, start new line, continue editing
    delg = ov.delegate()
    typ = delg.typ
    root = delg.root

    # no selection - make new node at end
    if selection == -1:
        node = OutlineNode( u"", u"", root, typ, root)
        root.addChild_( node )
        # need to reload all so the new node gets recognized
        ov.reloadData()
        rowIndex = ov.rowForItem_( node )

    else:
        p = selection.parent
        # root = p.rootNode
        node = OutlineNode(u"", "", p, typ, root)
        targetIdx = selection.nextIndex()
        if targetIdx == -1:
            p.addChild_( node )
        else:
            p.addChild_atIndex_( node, targetIdx )
        ov.reloadData()
        ov.selectRowItem_( node )
        rowIndex = ov.rowForItem_( node )

    if startEditing:
        s = NSIndexSet.indexSetWithIndex_( rowIndex )
        ov.selectRowIndexes_byExtendingSelection_(s, False)
        ov.reloadData()
        ov.editColumn_row_withEvent_select_(0, rowIndex, None, True)
    delg.markDirty()


</t>
<t tx="karstenw.20160619131238.85">def moveSelectionUp(ov, items):
    if kwdbg:
        print "CactusOutline.moveSelectionUp()"
    delg = ov.delegate()
    for item in items:
        # move item before previous
        #  get grandparent
        #  insert at index of previous

        if not item:
            continue
        previous = item.previous()
        if previous == -1:
            return
        parent = item.parent
        if parent == None:
            return
        previousIndex = previous.siblingIndex()
        item.retain()

        # don't swap these two
        parent.removeChild_( item )
        parent.addChild_atIndex_(item, previousIndex)

        delg.markDirty()


</t>
<t tx="karstenw.20160619131238.86">def moveSelectionDown(ov, items):
    if kwdbg:
        print "CactusOutline.moveSelectionDown()"
    #
    # this really needs to be sorted down; use indices
    # otherwise there will be overlapping moves destroying
    # sortorder
    delg = ov.delegate()
    items.reverse()
    for item in items:
        # retain item 0
        if not item:
            continue
        parent = item.parent
        if parent == None:
            return
        next = item.next()
        if next == -1:
            return

        item.retain()
        parent.removeChild_( item )

        # after removal of item, nexitndex changes
        nextIndex = next.nextIndex()
        if nextIndex == -1:
            parent.addChild_( item )
        else:
            parent.addChild_atIndex_(item, nextIndex)
        item.release()
        delg.markDirty()


</t>
<t tx="karstenw.20160619131238.87">def moveSelectionLeft(ov, selection):
    if kwdbg:
        print "EMPTY: CactusOutline.moveSelectionLeft()"
    pass

</t>
<t tx="karstenw.20160619131238.88">def moveSelectionRight(ov, selection):
    if kwdbg:
        print "EMPTY: CactusOutline.moveSelectionRight()"
    pass


</t>
<t tx="karstenw.20160619131238.89">def unmangleFSSPecURL( url ):
    orgurl = url
    # clean up fsspec mangled names in URLs

    if '#' in url:
        # escape OS9 mangled filenames; Frontier produces such links
        os9namepart = re.compile( r"^(.+)#([0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]\....)$" )
        m = os9namepart.match( url )
        if m:
            pre, post = m.groups()
            pre = urllib.quote( pre, "/:?" )
            post = urllib.quote( post, "/:?" )
            url = "%s%%23%s" % (pre, post)
    if kwdbg:
        print "CactusOutline.unmangleFSSpecURL(%s) -&gt; %s" % (repr(orgurl), repr(url) )
    return url


</t>
<t tx="karstenw.20160619131238.9">def menuNeedsUpdate_(self, sender):
    if 0: #kwlog:
        print "KWOutlineView.menuNeedsUpdate_( %s )" % repr(sender)

</t>
<t tx="karstenw.20160619131238.90">def cleanupURL( url ):
    if kwdbg:
        print "CactusOutline.cleanupURL()"
    # lots of URLs contain spaces, &amp;, '
    return unmangleFSSPecURL( url )

    mangled = False
    url = NSURL2str(url)
    if '#' in url:
        # escape OS9 mangled filenames; Frontier produces such links
        os9namepart = re.compile( r"(.*)#([0-9A-F]{7,7}\.{3,3}]*)" )
        m = os9namepart.match( url )
        if m:
            mangled = True
            l = m.groups()
            url = "%s%%23%s" % l
            # url = re.sub(os9namepart, "\1%23\2.\3", url)
        if mangled:
            return url

    if not mangled:
        # what did i smoke when i wrote that?
        #
        # this mess needs serious cleaning
        #

        # purl = urlparse.urlparse( url )
        purl = urlparse.urlsplit( url, allow_fragments=False )
        path = purl.path
        purl = list( purl )

        path = urllib.unquote( 'http://' + path )
        try:
            path = urllib.quote( path )
        except KeyError, err:
            print "ERROR"
            print repr(path)
            print err
        path = path[9:]
        purl[2] = path
        #
        purl.append("")
        purl = urlparse.urlunparse( purl )
        purl = unicode(purl)
        return purl


</t>
<t tx="karstenw.20160619131238.91"># VAGUELY TESTED...
def folder2Outline( folder, node, filter=None):
    """Create an outline from a folder.
    
    For each file or folder create a node with properties.
    
    For folders recursively create children.
    """
    defaults = NSUserDefaults.standardUserDefaults()
    ignoredot = False
    try:
        ignoredot = bool(defaults.objectForKey_( u'optIgnoreDotFiles'))
    except:
        pass
    root, directories, files = os.walk( folder ).next()
    if ignoredot:
        files[:] = [f for f in files if not f.startswith('.')]
        directories[:] = [f for f in directories if not f.startswith('.')]
    result = []
    items = files[:]
    items.extend( directories )
    items.sort()
    for item in items:
        path = os.path.join( root, item)
        typ, currnode = makeFilePropertiesNode( path )
        if typ == "folder":
            folder2Outline( path, currnode )
        node['children'].append( currnode )

</t>
<t tx="karstenw.20160619131238.92">def makeFilePropertiesNode( path ):
    prop = getFileProperties( path )
    parent, item = os.path.split( path )
    typ = "file"
    if os.path.isdir( path ):
        typ = "folder"
    url = NSURL2str( NSURL.fileURLWithPath_(path))

    currnode = { 
        'name': item,
        'value': {
            'url': url,
            'type': typ,
            'size': str(prop.get("NSFileSize", "")),
            'created': str(prop.get("NSFileCreationDate", "")),
            'modified': str(prop.get("NSFileModificationDate", "")),
            'fileID': str(prop.get("NSFileSystemFileNumber", "-1"))
            },
        'typ': CactusOutlineTypes.typeOutline,
        'children': [] }

    # add type &amp; creator if set
    hfstype = int(prop.get("NSFileHFSTypeCode", "0"))
    if hfstype:
        hfstype_s = num2ostype( hfstype )

        # check for XML illegal characters here
        m = re_bogusCharacters.match( hfstype_s )
        if m:
            currnode['value']['HFSType'] = hex(hfstype)
        else:
            currnode['value']['HFSType'] = hfstype_s

    hfscreator = int(prop.get("NSFileHFSCreatorCode", "0"))
    if hfscreator:
        hfscreator_s = num2ostype( hfscreator )

        # check for XML illegal characters here
        m = re_bogusCharacters.match( hfscreator_s )
        if m:
            currnode['value']['HFSCreator'] = hex(hfscreator)
        else:
            currnode['value']['HFSCreator'] = hfscreator_s

    return typ, currnode
</t>
<t tx="karstenw.20160619131247.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619131254.1">
# -*- coding: utf-8 -*-


"""
"""

import sys
import os
import traceback

import time
import datetime
import urllib
import binascii
import struct

import xml.etree.cElementTree
etree = xml.etree.cElementTree

import cStringIO

import pdb
import pprint
pp = pprint.pprint
kwdbg = False
kwlog = True

import feedparser

import CactusOPML

import CactusVersion

import CactusTools
readURL = CactusTools.readURL
errorDialog = CactusTools.errorDialog
NSURL2str = CactusTools.NSURL2str
makeunicode = CactusTools.makeunicode

import CactusExceptions
OPMLParseErrorException = CactusExceptions.OPMLParseErrorException
XMLParseErrorException = CactusExceptions.XMLParseErrorException
HTMLParseErrorException = CactusExceptions.HTMLParseErrorException
PLISTParseErrorException = CactusExceptions.PLISTParseErrorException

import objc

import Foundation
NSObject = Foundation.NSObject
NSURL = Foundation.NSURL
NSMakeRect = Foundation.NSMakeRect

# NSDate, NSNumber, NSArray, or NSDictionary
NSData = Foundation.NSData
NSDate = Foundation.NSDate

NSNumber = Foundation.NSNumber
NSArray = Foundation.NSArray
NSDictionary = Foundation.NSDictionary
NSUserDefaults = Foundation.NSUserDefaults
NSMutableData = Foundation.NSMutableData
NSKeyedArchiver = Foundation.NSKeyedArchiver

import AppKit
NSApplication = AppKit.NSApplication
NSDocument = AppKit.NSDocument
NSDocumentController = AppKit.NSDocumentController
NSWorkspace = AppKit.NSWorkspace
NSString = AppKit.NSString
NSMutableString = AppKit.NSMutableString
NSWindowController = AppKit.NSWindowController
NSPrintOperation = AppKit.NSPrintOperation

# grid styles
NSTableViewGridNone = AppKit.NSTableViewGridNone
NSTableViewSolidVerticalGridLineMask = AppKit.NSTableViewSolidVerticalGridLineMask
NSTableViewSolidHorizontalGridLineMask = AppKit.NSTableViewSolidHorizontalGridLineMask

# undo manager constants
NSChangeDone = AppKit.NSChangeDone
NSChangeUndone = AppKit.NSChangeUndone
NSChangeCleared = AppKit.NSChangeCleared
NSChangeReadOtherContents = AppKit.NSChangeReadOtherContents
NSChangeAutosaved = AppKit.NSChangeAutosaved


import PyObjCTools
#import PyObjCTools.NibClassBuilder
#extractClasses = PyObjCTools.NibClassBuilder.extractClasses
#AutoBaseClass = PyObjCTools.NibClassBuilder.AutoBaseClass


import CactusOutlineTypes
typeOutline = CactusOutlineTypes.typeOutline
typeTable = CactusOutlineTypes.typeTable
typeBrowser = CactusOutlineTypes.typeBrowser


import CactusOutline
OutlineViewDelegateDatasource = CactusOutline.OutlineViewDelegateDatasource

import CactusOutlineNode
OutlineNode = CactusOutlineNode.OutlineNode

import CactusDocumentTypes
CactusOPMLType = CactusDocumentTypes.CactusOPMLType
CactusRSSType = CactusDocumentTypes.CactusRSSType
CactusXMLType = CactusDocumentTypes.CactusXMLType
CactusHTMLType = CactusDocumentTypes.CactusHTMLType
CactusPLISTType = CactusDocumentTypes.CactusPLISTType
CactusIMLType = CactusDocumentTypes.CactusIMLType

# extractClasses("OutlineEditor")

import CactusFileOpeners

openOPML_ = CactusFileOpeners.openOPML_
openOPML_withURLTag_ = CactusFileOpeners.openOPML_withURLTag_
openXML_ = CactusFileOpeners.openXML_
openRSS_ = CactusFileOpeners.openRSS_
getPLISTValue = CactusFileOpeners.getPLISTValue
openIML_ = CactusFileOpeners.openIML_
openPLIST_ = CactusFileOpeners.openPLIST_


</t>
<t tx="karstenw.20160619131254.10">def initWithType_error_(self, theType, err):
    if kwlog:
        print "CactusOutlineDocument.initWithType_error_( %s )" % (repr(theType),)

    self = self.init()
    if not self:
        return (None, None)

    self.setFileType_( theType )

    self.rootNode = OutlineNode("__ROOT__", "", None, typeOutline, None)
    if kwlog:
        print "    .initWithType_error_ rootRetaines %i " % (self.rootNode.retainCount(),)
    boilerplateOPML( self.rootNode )
    if kwlog:
        print "    .initWithType_error_ boilerplate rootRetaines %i " % (self.rootNode.retainCount(),)
    self.updateChangeCount_( NSChangeCleared )

    self.variableRowHeight = True
    return (self, None)


</t>
<t tx="karstenw.20160619131254.11">def displayName(self):
    if kwlog:
        print "CactusOutlineDocument.displayName() -&gt;",
    title = objc.super( CactusOutlineDocument, self).displayName()

    if 0:
        title = self.title
        fullpath = self.fileURL()
        if fullpath:
            fullpath = fullpath.path()

        if not fullpath:
            fullpath = self.url
        else:
            self.url = fullpath

        fullpath = NSURL2str(fullpath)

        try:
            t = os.path.split( fullpath )[1]
            if t:
                title = t
        except Exception, err:
            print
            print "displayName CRASHED!"
            print err
            print
        finally:
            pass

    if kwlog:
        print repr(title)
    self.title = title
    return title


</t>
<t tx="karstenw.20160619131254.12">def awakeFromNib(self):
    if kwlog:
        print "CactusOutlineDocument.awakeFromNib()"


</t>
<t tx="karstenw.20160619131254.13">def XXwindowNibName(self):
    # deactivated
    if kwlog:
        print "CactusOutlineDocument.windowNibName()"
    return u"OutlineEditor"


</t>
<t tx="karstenw.20160619131254.14">def fileURL( self ):
    # do nothing the superclass wouldn't do
    if kwlog:
        print "SUPER CactusOutlineDocument.fileURL()"
    return objc.super( CactusOutlineDocument, self).fileURL()


</t>
<t tx="karstenw.20160619131254.15">def setFileURL_( self, theURL ):
    # print "URLType:", type(theURL)
    if not isinstance( theURL, NSURL ):
        theURL = NSURL.URLWithString_( theURL )
    # do nothing the superclass wouldn't do
    if kwlog:
        print "SUPER CactusOutlineDocument.setFileURL()", repr(NSURL2str(theURL))
    objc.super( CactusOutlineDocument, self).setFileURL_( theURL )
    self.url = theURL




</t>
<t tx="karstenw.20160619131254.16">def windowControllerWillLoadNib_( self, aController):
    # do nothing the superclass wouldn't do
    if kwlog:
        print "SUPER CactusOutlineDocument.windowControllerWillLoadNib_( %s )" % repr(aController)
    objc.super( CactusOutlineDocument, self).windowControllerWillLoadNib_(aController)


</t>
<t tx="karstenw.20160619131254.17">def windowControllerDidLoadNib_( self, aController):
    # do nothing the superclass wouldn't do
    if kwlog:
        print "SUPER CactusOutlineDocument.windowControllerDidLoadNib_( %s )" % repr(aController)
    objc.super( CactusOutlineDocument, self).windowControllerDidLoadNib_(aController)


</t>
<t tx="karstenw.20160619131254.18">def calculateExpansionState_( self, rootNode ):

    winframe = {}
    rootNode = self.rootNode
    ov = self.outlineView
    win = ov.window()
    frame = win.frame()
    if frame:
        winframe = {
            'windowLeft': int(frame.origin.x),
            'windowTop': int(frame.origin.y),
            'windowRight': int(frame.origin.x + frame.size.width),
            'windowBottom': int(frame.origin.y + frame.size.height)
        }

    # parse root down to head
    children = rootNode.children
    head = body = False
    for child in children:
        if child.name == u"head":
            head = child
        if child.name == u"body":
            body = child
    #if head:
    #    ov.collapseItem_collapseChildren_( head, True )

    # start at first child of body
    if body:
        if len(body.children) &gt; 0:
            expanded = []
            item = body.children[0]
            # expandable item 1
            idx = 1
            # is at row
            row = ov.rowForItem_( item )

            if ov.isItemExpanded_( item ):
                expanded.append( idx )

            while True:
                idx += 1
                row += 1
                item = ov.itemAtRow_( row )
                if not item:
                    break
                if ov.isItemExpanded_( item ):
                    expanded.append( idx )
                if idx % 1000 == 0:
                    print "idx, items", idx, len(expanded)

            expanded = [str(i) for i in expanded]
            expanded = ', '.join( expanded )
            if expanded == "":
                expanded = "1"
            if 1: #kwlog:
                print "CactusOutlineDocument.calculateExpansionState_()"
                print "expansionState: ", repr(expanded)
                print
            winframe['expansionState'] = expanded
            return winframe

    # scavenge document metadata
    searchKeys = ( 'dateCreated dateModified ownerName ownerEmail '
                   'expansionState windowTop windowLeft windowBottom '
                   'windowRight'.split() )
    meta = {}

    if len(children) == 1:
        ov.expandItem_expandChildren_(children[0], False)

    if head and body: # ;-)
        children = head.children

        for child in children:
            k = child.name
            v = child.displayValue
            if k in searchKeys:
                if v:
                    meta[k] = v

        # start - collapse head - expand body
        ov.collapseItem_collapseChildren_(head, True)
        ov.collapseItem_collapseChildren_(body, True)
        ov.expandItem_expandChildren_(body, False)

        # first row is 2
        rows = False
        if "expansionState" in meta:
            rows = meta[ 'expansionState' ]


</t>
<t tx="karstenw.20160619131254.19">def dataRepresentationOfType_( self, theType ):
    if kwlog:
        print "CactusOutlineDocument.dataRepresentationOfType_( %s )" % repr(theType)

    defaults = NSUserDefaults.standardUserDefaults()

    # future scaffolding
    if theType == CactusOPMLType:

        expansionState = self.calculateExpansionState_( self.rootNode )
        if expansionState == None:
            expansionState = {}
        rootOPML = CactusOPML.generateOPML( self.rootNode, indent=1, expansion=expansionState )

        e = etree.ElementTree( rootOPML )

        fob = cStringIO.StringIO()
        e.write(fob, encoding="utf-8", xml_declaration=True, method="xml" )
        t = fob.getvalue()
        fob.close()
        return NSData.dataWithBytes_length_(t, len(t))

    elif theType == CactusRSSType:
        t = CactusOPML.generateRSS( self.rootNode, indent=1 )
        return NSData.dataWithBytes_length_(t, len(t))

    elif theType == CactusXMLType:
        # closed after finding the trailing text bug/misconception
        # return None
        rootXML = CactusOPML.generateXML( self.rootNode) #, indent=1 )

        # check consistency
        if self.rootNode.noOfChildren() &gt; 1:
            firstborn = self.rootNode.childAtIndex_(0)
            name = firstborn.name
            errorDialog(u"Warning",
                u"XML documents can have only 1 to level node. Every node after '%s' will be ommited on save." % (name,))
        e = etree.ElementTree( rootXML )

        fob = cStringIO.StringIO()
        # e.write(fob, pretty_print=True, encoding="utf-8", xml_declaration=True, method="xml" )
        e.write(fob, encoding="utf-8", xml_declaration=True, method="xml" )
        t = fob.getvalue()
        fob.close()
        return NSData.dataWithBytes_length_(t, len(t))

    elif theType == CactusHTMLType:
        # closed after finding the trailing text bug/misconception
        # return None
        doctype = encoding = ""
        indent = 0
        try:
            doctype = unicode(defaults.objectForKey_( u'menDoctype'))
            encoding = unicode(defaults.objectForKey_( u'menEncoding'))
            indent = unicode(defaults.objectForKey_( u'txtIndent'))
            indent = int(indent)

        except StandardError, err:
            print "ERROR reading defaults.", repr(err)

        etHTML = CactusOPML.generateHTML( self.rootNode, doctype, encoding, indent )

        if etHTML:
            # e = etree.ElementTree( rootHTML )

            #fob = cStringIO.StringIO()
            ## e.write(fob, pretty_print=True, encoding="utf-8", xml_declaration=True, method="xml" )
            #etHTML.write(fob) # , encoding="utf-8", xml_declaration=False, method="html" )
            #t = fob.getvalue()
            #fob.close()
            #return NSData.dataWithBytes_length_(t, len(t))
            return NSData.dataWithBytes_length_(etHTML, len(etHTML))

    elif theType == CactusDocumentTypes.CactusPLISTType:
        return CactusOPML.serializePLISTOutline_( self.rootNode )

    # these are just ideas
    elif theType == CactusDocumentTypes.CactusTEXTType:
        pass
    elif theType == CactusDocumentTypes.CactusSQLITEType:
        pass
    elif theType == CactusDocumentTypes.CactusXOXOType:
        pass
    elif theType == CactusDocumentTypes.CactusEMACSORGType:
        pass
    elif theType == CactusDocumentTypes.CactusTABLEType:
        pass

    else:
        print
        print "ERROR! Bogus filetype for writing: '%s'" % repr(theType)
        print

    # Insert code here to write your document from the given data.
    # You can also choose to override -fileWrapperRepresentationOfType:
    # or -writeToFile:ofType: instead.

    # For applications targeted for Tiger or later systems, you should
    # use the new Tiger API -dataOfType:error:.  In this case you can
    # also choose to override -writeToURL:ofType:error:,
    # -fileWrapperOfType:error:,
    # or -writeToURL:ofType:forSaveOperation:originalContentsURL:error:
    # instead.

    if kwlog:
        print "CactusOutlineDocument.dataRepresentationOfType_( %s ) RETURNED NONE" % repr(theType)
    return None


</t>
<t tx="karstenw.20160619131254.2">def boilerplateOPML( rootNode ):
    """Creates the minimal outline nodes for the OPML structure.

    rootNode - the node under which the structure will be created

    """
    if kwlog:
        print "boilerplateOPML()"

    ZERO = datetime.timedelta(0)
    HOUR = datetime.timedelta(hours=1)
    class UTC(datetime.tzinfo):
        """UTC - from python library examples."""

        def utcoffset(self, dt):
            return ZERO

        def tzname(self, dt):
            return "UTC"

        def dst(self, dt):
            return ZERO

    now = datetime.datetime.now( UTC() )
    s = now.strftime("%a, %d %b %Y %H:%M:%S %Z")

    root = rootNode.findRoot()
    head = OutlineNode("head", "", rootNode, typeOutline, root)
    rootNode.addChild_( head )

    defaults = NSUserDefaults.standardUserDefaults()
    uname = uemail = ""
    try:
        uname = unicode(defaults.objectForKey_( u'txtUserName'))
        uemail = unicode(defaults.objectForKey_( u'txtUserEmail'))
    except StandardError, err:
        print "ERROR reading defaults.", repr(err)

    head.addChild_(OutlineNode("dateCreated", s, head, typeOutline, root))
    head.addChild_(OutlineNode("dateModified", s, head, typeOutline, root))
    head.addChild_(OutlineNode("ownerName", uname, head, typeOutline, root))
    head.addChild_(OutlineNode("ownerEmail", uemail, head, typeOutline, root))
    head.addChild_(OutlineNode("expansionState", "", head, typeOutline, root))
    head.addChild_(OutlineNode("vertScrollState", "", head, typeOutline, root))
    head.addChild_(OutlineNode("windowTop", "", head, typeOutline, root))
    head.addChild_(OutlineNode("windowLeft", "", head, typeOutline, root))
    head.addChild_(OutlineNode("windowBottom", "", head, typeOutline, root))
    head.addChild_(OutlineNode("windowRight", "", head, typeOutline, root))

    body = OutlineNode("body", "", rootNode, typeOutline, root)
    rootNode.addChild_( body )

    body.addChild_( OutlineNode("", "", body, typeOutline, root) )
    #head.release()
    #body.release()
    if 0:
        print "root:", root.retainCount()
        print "head:", head.retainCount()
        print "body:", body.retainCount()
    return


</t>
<t tx="karstenw.20160619131254.20">def loadDataRepresentation_ofType_(self, data, aType):
    if kwlog:
        print
        print "------ TBD ----- CactusOutlineDocument.loadDataRepresentation_ofType_()"
        print
    # Insert code here to read your document from the given data.  You can
    # also choose to override -loadFileWrapperRepresentation:ofType: or
    # -readFromFile:ofType: instead.

    # For applications targeted for Tiger or later systems, you should use
    # the new Tiger API readFromData:ofType:error:.  In this case you can
    # also choose to override -readFromURL:ofType:error: or
    # -readFromFileWrapper:ofType:error: instead.

    return True


</t>
<t tx="karstenw.20160619131254.21">def readFromData_ofType_error_(self, data, typeName, err):
    # This should be deleted
    if kwlog:
        print "X" * 80
        print "CactusOutlineDocument.readFromData_ofType_error_()"
        print "X" * 80

    outError = None
    readSuccess = False

    s = str(data.bytes())
    if typeName == CactusOPMLType:
        d = CactusOPML.opml_from_string( s )
        if d:
            root, typeName = openOPML_( d )
            if self.rootNode:
                pass
                # release here
            self.rootNode = root
            readSuccess = True

    elif theType == CactusDocumentTypes.CactusRSSType:
        d = feedparser.parse( s, agent=CactusVersion.user_agent )
        if d:
            root, typeName = openRSS_( d )
            if self.rootNode:
                pass
                # release here
            self.rootNode = root
            readSuccess = True
    else:
        print "ERROR: Wrong type requested: ", repr(typename)
    return (readSuccess, outError)


</t>
<t tx="karstenw.20160619131254.22">def showWindows( self ):
    if kwlog:
        print "CactusOutlineDocument.showWindows()"

    c = objc.super( CactusOutlineDocument, self).showWindows()
    #
    # extract data for expansionstate &amp; window size
    #
    controllers = self.windowControllers()

    defaults = NSUserDefaults.standardUserDefaults()
    doanimate = True
    try:
        doanimate = bool(defaults.objectForKey_( u'optAnimateOPMLOpen'))
    except Exception, err:
        pass

    for controller in controllers:
        rootNode = controller.rootNode
        outlineView = controller.outlineView
        # parse root down to head
        children = rootNode.children
        head = body = False
        for child in children:
            if child.name == u"head":
                head = child
            if child.name == u"body":
                body = child
        # scavenge document metadata
        #
        # not used for now
        #
        # 'dateCreated dateModified ownerName ownerEmail '
        #
        searchKeys = ('expansionState windowTop windowLeft '
                      'windowBottom windowRight'.split() )
        meta = {}

        if len(children) == 1:
            outlineView.expandItem_expandChildren_(children[0], False)
    
        redisplay = True
        if head and body: # ;-)
            children = head.children

            for child in children:
                k = child.name
                v = child.displayValue
                if k in searchKeys:
                    if v:
                        meta[k] = v

            # start - collapse head - expand body
            outlineView.collapseItem_collapseChildren_(head, True)
            outlineView.collapseItem_collapseChildren_(body, True)
            outlineView.expandItem_expandChildren_(body, False)

            # first row is 2
            rows = meta.get("expansionState", [])

            if rows:
                try:
                    rows = rows.split(',')
                    rows = [int(i)+1 for i in rows if i]
                except Exception, err:
                    print "\nERROR: expansionState reading failed.\n", err
                    print
                if rows:
                    for row in rows:
                        item = outlineView.itemAtRow_( row )
                        outlineView.expandItem_expandChildren_(item, False)

            keys = 'windowLeft windowTop windowRight windowBottom'.split()
            coords = []

            try:
                for key in keys:
                    coords.append( float( meta[key] ))
                window = outlineView.window()

                # this makes the found rect the minimum size of the nib
                # can the nib values be queried?
                w = coords[2] - coords[0]
                h = coords[3] - coords[1]
                h = max(h, 260.0)
                w = max(w, 590.0)
                s = NSMakeRect(coords[0], coords[1], w, h)

                # animation is too slow, ca 0.5s per file
                # print "ANIME:", window.animationResizeTime_( s )
                window.setFrame_display_animate_(s, True, doanimate)

                # window.setFrame_display_(s, True)
                redisplay = False
            except StandardError, err:
                print err
                print "No window setting for you."
        outlineView.setNeedsDisplay_( redisplay )

</t>
<t tx="karstenw.20160619131254.23">def makeWindowControllers(self):
    if kwlog:
        print "CactusOutlineDocument.makeWindowControllers()"

    c = CactusOutlineWindowController.alloc().init()
    self.addWindowController_( c )
    
    # c.document is set by addWindowController_
    c.finishControllerInit()

</t>
<t tx="karstenw.20160619131254.24">def windowControllers(self):
    if kwlog:
        print "CactusOutlineDocument.windowControllers()"
    #pdb.set_trace()
    #print
    return objc.super( CactusOutlineDocument, self).windowControllers()

</t>
<t tx="karstenw.20160619131254.25">def printShowingPrintPanel_(self, show):
    printInfo = self.printInfo()
    printOp = NSPrintOperation.printOperationWithView_printInfo_(
                        self.outlineView, printInfo )
    printOp.setShowPanels_( show )
    self.runModalPrintOperation_delegate_didRunSelector_contextInfo_(
                        printOp, None, None, None )


</t>
<t tx="karstenw.20160619131254.26">class CactusOutlineWindowController(NSWindowController):
    menRowLines = objc.IBOutlet()
    outlineView = objc.IBOutlet()
    optAlterLines = objc.IBOutlet()
    optCommentVisible = objc.IBOutlet()
    optHLines = objc.IBOutlet()
    optNameVisible = objc.IBOutlet()
    optTypeVisible = objc.IBOutlet()
    optValueVisible = objc.IBOutlet()
    optVariableRow = objc.IBOutlet()
    optVLines = objc.IBOutlet()
    txtOutlineType = objc.IBOutlet()
    txtWindowStatus = objc.IBOutlet()

    """the actual base class is NSWindowController

    menRowLines
    outlineView
    optAlterLines
    optCommentVisible
    optHLines
    optNameVisible
    optTypeVisible
    optValueVisible
    optVariableRow
    optVLines
    txtOutlineType

    window # in NSWindowController
    """

    @others
</t>
<t tx="karstenw.20160619131254.27">def dealloc(self):
    print "CactusOutlineWindowController.dealloc()", self.retainCount()
    #if self.rootNode:
    #    self.rootNode.release()
    #if self.parentNode:
    #    self.parentNode.release()
    print "DEALLOCDBG model:", self.model, self.model.retainCount()
    self.model.release()
    objc.super(CactusOutlineWindowController, self).dealloc()

</t>
<t tx="karstenw.20160619131254.28">def init(self):
    self = self.initWithWindowNibName_("OutlineEditor")
    self.retain()
    return self


</t>
<t tx="karstenw.20160619131254.29">def finishControllerInit(self):
    """This controller is used for outline and table windows.

    document is a CactusOutlineDocument

    """
    if kwlog:
        print "CactusOutlineWindowController.initWithObject_()"

    # self = self.initWithWindowNibName_("OutlineEditor")
    title = u"Unnamed Outline"

    # self.path = ""
    self.rootNode = None
    self.parentNode = None
    self.variableRowHeight = True
    self.rowLines = 2
    self.url = None

    document = self.document()

    if not isinstance(document, CactusOutlineDocument):
        print "FAKE document"

    if document.url:
        # self.nsurl = document.url
        if document.url.isFileURL():
            self.url = unicode(document.url.path())
        else:
            self.url = NSURL2str(document.url)
    # path is a string or False now

    self.rootNode = document.rootNode
    if self.rootNode:
        # all nodes can access the document
        self.rootNode.controller = self

    self.parentNode = document.parentNode
    title = document.title

    if 0:
        # get window name from url or path
        if self.nsurl:
            if os.path.exists( self.url ):
                fld, fle = os.path.split( self.url )
                title = fle
            else:
                title = self.url
        else:
            # keep unnamed title
            pass

    window = self.window()
    window.setTitle_( self.displayName() )

    self.model = OutlineViewDelegateDatasource.alloc().initWithObject_type_parentNode_(
                                            self.rootNode,
                                            typeOutline,
                                            self.parentNode )

    # needed for drag and drop
    self.model.setOutlineView_( self.outlineView )

    # this is evil, and doesn't work
    # self.rootNode.model = self.model

    # TBD: make this accesssor
    # self.model.document = document

    self.model.setController_( self )

    # this will become very dangerous when a document gets more than 1 window
    #s = self.document()
    #s.outlineView = self.outlineView
    
    document.outlineView = self.outlineView

    self.outlineView.setDataSource_(self.model)
    self.outlineView.setDelegate_(self.model)

    self.outlineView.setTarget_(self)
    # self.outlineView.setDoubleAction_("doubleClick:")

    self.window().makeFirstResponder_(self.outlineView)

    # store them columns
    self.nameColumn = self.outlineView.tableColumnWithIdentifier_( "name" )
    self.typeColumn = self.outlineView.tableColumnWithIdentifier_( "type" )
    self.valueColumn = self.outlineView.tableColumnWithIdentifier_( "value" )
    self.commentColumn = self.outlineView.tableColumnWithIdentifier_( "comment" )

    # set name column to wrap
    self.nameColumn.dataCell().setWraps_( True )
    self.commentColumn.dataCell().setWraps_( True )
    self.valueColumn.dataCell().setWraps_( True )

    defaults = NSUserDefaults.standardUserDefaults()
    self.rowLines = 2
    self.optValueVisible.setState_( True )

    try:
        self.rowLines = int(defaults.objectForKey_( u'txtNoOfMaxRowLines'))
        self.menRowLines.setTitle_( str(self.rowLines) )
        self.optValueVisible.setState_( defaults.objectForKey_( u'optValueColumn') )
        self.optCommentVisible.setState_( defaults.objectForKey_( u'optCommentColumn') )
        self.optTypeVisible.setState_( defaults.objectForKey_( u'optTypeColumn') )

        self.optAlterLines.setState_( defaults.objectForKey_( u'optAlternateLines') )
        self.optVariableRow.setState_( defaults.objectForKey_( u'optVariableRowHeight') )
        self.optVLines.setState_( defaults.objectForKey_( u'optVLines') )
        self.optHLines.setState_( defaults.objectForKey_( u'optHLines') )

    except StandardError, err:
        print "ERROR reading defaults.", repr(err)

    if document.fileType() in (CactusPLISTType,):
        # disable value column for plist (for now)
        self.optValueVisible.setState_( False )

    if document.fileType() in (CactusXMLType, CactusHTMLType, CactusPLISTType):
        # enable comment column
        self.optCommentVisible.setState_( True )

    self.applySettings_(None)

    self.showWindow_(self)

    #self.retain()
    #return self

</t>
<t tx="karstenw.20160619131254.3"># a cocoa NSDocument subclass
class CactusOutlineDocument(NSDocument):
    parentNode = objc.IBOutlet()
    rootNode = objc.IBOutlet()
    url = objc.IBOutlet()

    #
    # outlets:
    #  parentNode
    #  rootNode
    #  url
    # parentclass(NSDocument) outlets:
    #   window
    #
    """
    """

    @others
    #
    # methods to do:
    #
    # writeSafelyToURL_ofType_forSaveOperation_error_


</t>
<t tx="karstenw.20160619131254.30">def nsurl(self):
    result = None
    try:
        result = self.document().fileURL()
    except Exception, err:
        pass
    return result


</t>
<t tx="karstenw.20160619131254.31">def displayName(self):
    # get window name
    if 0: #kwlog:
        print "CactusOutlineWindowController.displayName() -&gt;",
    doc = self.document()
    if not doc:
        return ""

    title = doc.title
    url = doc.fileURL()
    
    if url:
        path = unicode(url.path())
        urslstring = NSURL2str( url )
        if os.path.exists( path ):
            fld, fle = os.path.split( path )
            title = fle
        else:
            title = urslstring
    else:
        # keep unnamed title
        pass
    if 0: #kwlog:
        print repr(title)
    return title


</t>
<t tx="karstenw.20160619131254.32">def windowWillClose_(self, notification):
    if kwlog:
        print "CactusOutlineWindowController.windowWillClose_()"
    # see comment in self.initWithObject_()
    #
    # TBD: check model.dirty
    #
    self.autorelease()


</t>
<t tx="karstenw.20160619131254.33">def doubleClick_(self, sender):
    if kwlog:
        print "CactusOutlineWindowController.doubleClick_()"
    #objc.super(CactusOutlineWindowController, self).doubleClick_(sender)

</t>
<t tx="karstenw.20160619131254.34">def reloadData(self):
    if kwlog:
        print "CactusOutlineWindowController.reloadData()"
    self.outlineView.reloadData()

</t>
<t tx="karstenw.20160619131254.35">def reloadData_(self, item):
    if kwlog:
        print "CactusOutlineWindowController.reloadData_(item)"
    self.outlineView.reloadItem_reloadChildren_( item, True )

</t>
<t tx="karstenw.20160619131254.36">def reloadData_reloadChildren_(self, item, children):
    if kwlog:
        print "CactusOutlineWindowController.reloadData_reloadChildren_(item, children)"
    self.outlineView.reloadItem_reloadChildren_( item, children )

</t>
<t tx="karstenw.20160619131254.37">@objc.IBAction
def loadFile_(self, sender):
    if kwlog:
        print "-" * 80
        print "EMPTY CactusOutlineWindowController.loadFile_()"

</t>
<t tx="karstenw.20160619131254.38">@objc.IBAction
def applySettings_(self, sender):
    """target of the document check boxes. sets some tableview settings.
    """

    if kwlog:
        print "CactusOutlineWindowController.applySettings_()"

    # rowHeight
    self.variableRowHeight = self.optVariableRow.state()

    # alterLines
    alterLines = self.optAlterLines.state()
    self.outlineView.setUsesAlternatingRowBackgroundColors_( alterLines )

    # columns
    tableColumns = self.outlineView.tableColumns()

    if self.optNameVisible.state():
        if not self.nameColumn in tableColumns:
            self.outlineView.addTableColumn_(self.nameColumn)
    else:
        if self.nameColumn in tableColumns:
            self.outlineView.removeTableColumn_(self.nameColumn)

    if self.optTypeVisible.state():
        if not self.typeColumn in tableColumns:
            self.outlineView.addTableColumn_(self.typeColumn)
    else:
        if self.typeColumn in tableColumns:
            self.outlineView.removeTableColumn_(self.typeColumn)

    if self.optValueVisible.state():
        if not self.valueColumn in tableColumns:
            self.outlineView.addTableColumn_(self.valueColumn)
    else:
        if self.valueColumn in tableColumns:
            self.outlineView.removeTableColumn_(self.valueColumn)

    if self.optCommentVisible.state():
        if not self.commentColumn in tableColumns:
            self.outlineView.addTableColumn_(self.commentColumn)
    else:
        if self.commentColumn in tableColumns:
            self.outlineView.removeTableColumn_(self.commentColumn)

    if self.txtOutlineType:
        s = self.document()
        self.txtOutlineType.setStringValue_( unicode( s.fileType() ) )

    # lines per row menu
    try:
        l = self.menRowLines.title()
        l = int(l)
        self.rowLines = l
    except StandardError, err:
        print "\nERROR  ---  Menu Row lines '%'" % repr(l)
        self.rowLines = 4
        self.menRowLines.setTitle_( u"4" )

    # grid style
    gridStyleMask = self.outlineView.gridStyleMask()
    newStyle = NSTableViewGridNone
    if self.optVLines.state():
        newStyle |= NSTableViewSolidVerticalGridLineMask
    if self.optHLines.state():
        newStyle |= NSTableViewSolidHorizontalGridLineMask
    self.outlineView.setGridStyleMask_(newStyle)

    #
    self.outlineView.reloadData()
    self.outlineView.setNeedsDisplay_( True )
</t>
<t tx="karstenw.20160619131254.4">def __repr__(self):
    s = u"CactusOutlineDocument\n"
    s = s + u"    rootNode: '%s'\n" % self.rootNode
    s = s + u"    parentNode: '%s'\n" % self.parentNode
    s = s + u"    url: '%s'\n" % self.url
    s = s + u"    title: '%s'\n" % self.title
    s = s + u"    outlineView: '%s'\n" % self.outlineView
    return s.encode("utf-8")

</t>
<t tx="karstenw.20160619131254.5">def init(self):
    if kwlog:
        print "CactusOutlineDocument.init()"
    self = objc.super( CactusOutlineDocument, self).init()

    # outline specific
    # parentNode is used to determine if only an aspect of the outline is edited
    self.parentNode = None

    # outline root node; invisible and not editable
    self.rootNode = None

    #
    self.url = None

    #
    self.title = "Untitled Outline"

    self.outlineView = None

    # TBD
    self.setHasUndoManager_( False )
    return self

</t>
<t tx="karstenw.20160619131254.6">def dealloc(self):
    print "CactusOutlineDocument.dealloc()"
    objc.super(CactusOutlineDocument, self).dealloc()


</t>
<t tx="karstenw.20160619131254.7">def autosavingFileType(self):
    """2012-12-12 KW created to disable autosaving."""
    return None

</t>
<t tx="karstenw.20160619131254.8">def readFromURL_ofType_error_(self, url, theType, err):
    if kwlog:
        msg = "CactusOutlineDocument.readFromURL_ofType_error_( %s, %s )\n"
        print msg % (repr(url), repr(theType))

    OK = True
    s = None
    err = None
    self.url = url

    # read opml content
    if theType == CactusOPMLType:
        d = None
        try:
            d = CactusOPML.opml_from_string( readURL( url, CactusOPMLType ) )
        except OPMLParseErrorException, v:
            tb = unicode(traceback.format_exc())
            v = unicode( repr(v) )
            err = tb
            errorDialog( message=v, title=tb )
            return (False, None)

        if d:
            root, theType = openOPML_withURLTag_( d, NSURL2str(url) )
            del d
            if not root:
                if kwlog:
                    print "FAILED CactusOutlineDocument.readFromURL_ofType_error_()"
                return (False, "Error creating the outline.")
            else:
                self.rootNode = root
                if not url.isFileURL():
                    self.updateChangeCount_( NSChangeReadOtherContents )
                else:
                    self.updateChangeCount_( NSChangeCleared )
        else:
            if kwlog:
                print "FAILED CactusOutlineDocument.readFromURL_ofType_error_()"
            return (False, None)

    # read rss content
    elif theType == CactusRSSType:
        root, theType = openRSS_( url )
        if root:
            self.rootNode = root
            if not url.isFileURL():
                self.updateChangeCount_( NSChangeReadOtherContents )
            else:
                self.updateChangeCount_( NSChangeCleared )
        else:
            if kwlog:
                print "FAILED CactusOutlineDocument.readFromURL_ofType_error_()"
            return (False, None)

    # read xml content
    elif theType == CactusXMLType:
        d = None
        try:
            d = CactusOPML.xml_from_string( readURL( url, CactusXMLType ) )
        except XMLParseErrorException, v:
            tb = unicode(traceback.format_exc())
            v = unicode( repr(v) )
            err = tb
            errorDialog( message=v, title=tb )
            return (False, None)

        root, theType = openXML_( d )
        del d

        if root:
            self.rootNode = root
            if not url.isFileURL():
                # mark internet document dirty
                self.updateChangeCount_( NSChangeReadOtherContents )
            else:
                # mark local document clean
                self.updateChangeCount_( NSChangeCleared )
        else:
            if kwlog:
                print "FAILED CactusOutlineDocument.readFromURL_ofType_error_()"
            return (False, None)

    # read html content
    elif theType == CactusHTMLType:
        d = None
        try:
            d = CactusOPML.html_from_url( url )
        except HTMLParseErrorException, v:
            tb = unicode(traceback.format_exc())
            v = unicode( repr(v) )
            err = tb
            errorDialog( message=v, title=tb )
            return (False, None)

        # don't read type here, HTML is terminal type
        root, dummy = openXML_( d )
        del d

        if root:
            self.rootNode = root
            if not url.isFileURL():
                self.updateChangeCount_( NSChangeReadOtherContents )
            else:
                self.updateChangeCount_( NSChangeCleared )
        else:
            if kwlog:
                print "FAILED CactusOutlineDocument.readFromURL_ofType_error_()"
            return (False, None)

    # read plist content
    elif theType == CactusPLISTType:
        d = None
        try:
            d = CactusOPML.parse_plist( url )
        except PLISTParseErrorException, v:
            tb = unicode(traceback.format_exc())
            v = unicode( repr(v) )
            err = tb
            errorDialog( message=v, title=tb )
            return (False, None)

        # may return ttheType=CactusPLISTType
        root, theType = None, None
        if d:
            root, theType = openPLIST_( d )
        del d

        if root:
            self.rootNode = root
            if not url.isFileURL():
                self.updateChangeCount_( NSChangeReadOtherContents )
            else:
                self.updateChangeCount_( NSChangeCleared )
        else:
            if kwlog:
                print "FAILED CactusOutlineDocument.readFromURL_ofType_error_()"
            return (False, None)

    # read itunes music xml
    elif theType == CactusIMLType:
        d = None
        try:
            d = CactusOPML.parse_plist( url )
        except PLISTParseErrorException, v:
            tb = unicode(traceback.format_exc())
            v = unicode( repr(v) )
            err = tb
            errorDialog( message=v, title=tb )
            return (False, None)

        # don't read type here, HTML is terminal type
        root, dummy = openIML_( d )
        del d

        if root:
            self.rootNode = root
            if not url.isFileURL():
                self.updateChangeCount_( NSChangeReadOtherContents )
            else:
                self.updateChangeCount_( NSChangeCleared )
        else:
            if kwlog:
                print "FAILED CactusOutlineDocument.readFromURL_ofType_error_()"
            return (False, None)

    else:
        OK = False

    if OK:
        self.setFileURL_( url )
        self.setFileType_( theType )

    print "OK CactusOutlineDocument.readFromURL_ofType_error_()"
    return (OK, None)


</t>
<t tx="karstenw.20160619131254.9">def initWithContentsOfURL_ofType_error_(self, url, theType, err):
    """Main entry point for opening documents."""
    if kwlog:
        msg = "\nCactusOutlineDocument.initWithContentsOfURL_ofType_error_( %s, %s )\n"
        print msg % ( repr(theType), repr(url))


    self, err = self.initWithType_error_( theType, err )

    if not self:
        return( None, None)

    OK, err = self.readFromURL_ofType_error_( url, theType, err )

    if OK:
        if not url.isFileURL():
            #
            # evil hack, because NSDocumentController doesn't open window if
            # document is loaded with http: scheme
            #
            # addendum 10.6
            #
            # now this does not work anymore
            docc = NSDocumentController.sharedDocumentController()
            docc.addDocument_(self)

            # this is source of trouble ( double or none call to makeWindowControllers)
            #
            self.makeWindowControllers()
            self.showWindows()

        # check opml file metadata
        if theType == CactusOPMLType:
            pass
        return (self, err)

    # could not create document
    return (None, err)


</t>
<t tx="karstenw.20160619131258.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619131304.1">
# -*- coding: utf-8 -*-


"""A collection of outline related stuff
"""

import sys
import os

import re

import traceback

import time
import datetime

import math
import feedparser

import cPickle

kwdbg = False
kwlog = True

import pdb
import pprint
pp = pprint.pprint

# debugging; gives nodes a serialnr
import itertools
counter = itertools.count()


import CactusOutlineTypes
typeOutline = CactusOutlineTypes.typeOutline

import objc
super = objc.super

import CactusTools
makeunicode = CactusTools.makeunicode

import Foundation
NSObject = Foundation.NSObject

NSMutableArray = Foundation.NSMutableArray

NSNotFound = Foundation.NSNotFound
NSIndexSet = Foundation.NSIndexSet

NSNumber = Foundation.NSNumber


import AppKit
NSString = AppKit.NSString
NSMutableString = AppKit.NSMutableString

</t>
<t tx="karstenw.20160619131304.10">
# We keep references to all child items (once created). This is
# neccesary because NSOutlineView holds on to OutlineNode instances
# without retaining them. If we don't make sure they don't get
# garbage collected, the app will crash. For the same reason this
# class _must_ derive from NSObject, since otherwise autoreleased
# proxies will be fed to NSOutlineView, which will go away too soon.

# attributes of OutlineNode:
# name
# value
# comment
# type
# parent
# children
#
# displayValue
#

#
# to be added
#
# nodeAttributes

# that's the deal
def __new__(cls, *args, **kwargs):
    return cls.alloc().init()

</t>
<t tx="karstenw.20160619131304.11">def __init__(self, name, obj, parent, typ, rootNode):

    # this is outlinetype, not valueType
    self.typ = typ
    self.attributes = ""
    self.name = ""
    self.comment = ""
    self.maxHeight = 1
    self.setParent_(parent)
    self.rootNode = rootNode

    # debugging
    self.nodenr = counter.next()

    # these must exists before any name/value is set
    self.children = NSMutableArray.arrayWithCapacity_( 0 )
    self.maxHeight = 1

    self.setName_( name )
    self.setValue_( obj )


    self.setAttributes_( obj )
    self.setComment_( "" )

    # self.setMaxLineHeight()

    self.controller = None
    #if rootNode != None:
    #    self.controller = rootNode.controller

    # leave this here or bad things will happen
    self.retain()

</t>
<t tx="karstenw.20160619131304.12">def __repr__(self):
    return "&lt;OutlineNode(%i, name='%s')" % (self.nodenr, self.name)

</t>
<t tx="karstenw.20160619131304.13">def dealloc(self):
    print "OutlineNode.dealloc()"
    # pp(self.__dict__)
    self.children.release()

    # 2013-05-15
    # currently crashes during dict dealloc.
    # seems like I'm on the right way to deallocation...
    psolved = False
    if psolved:
        super(OutlineNode, self).dealloc()


</t>
<t tx="karstenw.20160619131304.14">def setMaxLineHeight(self):
    items = [
        self.calcAttributesHeight(),
        self.lineHeight_( self.name ),
        self.lineHeight_( self.comment )]
    self.maxHeight = max(items)

</t>
<t tx="karstenw.20160619131304.15">def setAttributes_(self, attrs):
    d = {}
    t = type(attrs)
    if t in (str, unicode, NSString, bool, int, long,
             NSMutableString, objc.pyobjc_unicode):
        # stringtype
        d[ u"" ] = unicode(attrs)
    elif t in (list, tuple):
        #listtype
        for item in attrs:
            key, val = item
            key = unicode(key)
            val = unicode(val)
            d[ key ] = val
    elif t in (dict, feedparser.FeedParserDict):
        for key in attrs:
            val = unicode(attrs[key])
            key = unicode(key)
            d[ key ] = val
    else:
        # ???
        pass
    self.attributes = d
    self.setMaxLineHeight()


</t>
<t tx="karstenw.20160619131304.16">def lineHeight_(self, val):
    lines = 0
    try:
        lines += val.count( u"\r" )
        lines += val.count( u"\n" )
    except Exception, err:
        print "\n\nERROR in lineHeight_()"
        tb = unicode(traceback.format_exc())
        print err
        print
        print tb
        print
    vallength = len( val )
    if vallength &gt; 100:
        pass
    lines += int(math.ceil(vallength / 55.0))
    return max(1, lines)

</t>
<t tx="karstenw.20160619131304.17">def calcAttributesHeight(self):
    lineheight = 0
    for key in self.attributes:
        lineheight += self.lineHeight_( self.attributes[ key ] )
    return lineheight


</t>
<t tx="karstenw.20160619131304.18">def setParent_(self, parent):
    self.parent = parent

</t>
<t tx="karstenw.20160619131304.19">#
def setName_(self, value):
    self.name = makeunicode(value)
    self.setMaxLineHeight()

</t>
<t tx="karstenw.20160619131304.2">#
# NodeValue class
#

class NodeValue(object):
    """NodeValue is a helper with the value column which in some cases has
    a dual existence as a string or as a table.
    """
    @others
</t>
<t tx="karstenw.20160619131304.20">def setValue_(self, value):
    if value in (u"", {}, [], None, False):
        self.value = [(u"",u"")]
        self.displayValue = u""
        self.type = u"String"
    else:
        nv = NodeValue( value )
        self.value = nv.value

        if nv.isMultiValue():
            self.type = u"Attributes"
        else:
            self.type = u"String"
        self.displayValue = nv.displayValue()

</t>
<t tx="karstenw.20160619131304.21"># UNUSED
def addValue_(self, nameValue):
    self.value.append( nameValue )
    self.setValue_( self.value )
    r = self.findRoot()
    c = r.controller
    c.outlineView.reloadData()

</t>
<t tx="karstenw.20160619131304.22"># used in attribute editor
def removeValue_(self, nameValue):
    # repeated myself; copied from updateValue_ ...
    newname, newvalue = nameValue
    updated = idx = False
    for i,t in enumerate(self.value):
        k, v = t
        if k == newname:
            idx = i
            break
    if idx &gt;= 0:
        self.value.pop(idx)
        updated = True

    if updated:
        self.setValue_( self.value )
        r = self.findRoot()
        c = r.controller
        c.outlineView.reloadData()
    return updated

</t>
<t tx="karstenw.20160619131304.23"># used in attribute editor
def updateValue_(self, nameValue):
    newname, newvalue = nameValue
    updated = idx = None
    for i,t in enumerate(self.value):
        k, v = t
        if k == newname:
            idx = i
            break

    if idx != None:
        self.value.pop(idx)
        self.value.insert(idx, nameValue)
        updated = True

    if not updated:
        self.value.append( nameValue )
    self.setValue_( self.value )

    r = self.findRoot()
    try:
        c = r.controller
        c.outlineView.reloadData()
    except Exception, err:
        pass

</t>
<t tx="karstenw.20160619131304.24"># essential
def getValueDict(self):
    """Create a dictionary from the value."""
    if len(self.value) == 0:
        return {}
    elif len(self.value) == 1:
        if self.value[0][0] == "":
            if self.value[0][1] != "":
                return {'value': self.value[0][1] }
            else:
                return {}
        else:
            return {self.value[0][0]: self.value[0][1] }
    else:
        d = {}
        for t in self.value:
            k, v = t
            d[k] = v
        return d

</t>
<t tx="karstenw.20160619131304.25">def setComment_(self, comment):
    self.comment = makeunicode( comment )
    self.setMaxLineHeight()

</t>
<t tx="karstenw.20160619131304.26">#
def noOfChildren(self):
    return self.children.count()

</t>
<t tx="karstenw.20160619131304.27">#
def addChild_(self, child):
    if kwlog and 0:
        print "OutlineNode.addChild_", child
    # retain: child+1
    if isinstance(child, OutlineNode):
        if child.parent != self:
            child.setParent_(self)
        self.children.addObject_( child )
        # child.release()

</t>
<t tx="karstenw.20160619131304.28">def addChild_atIndex_(self, child, index):
    if kwdbg:
        print "addChild_atIndex_setParent", child
    # retain: child+1

    self.children.insertObject_atIndex_( child, index)
    if child.parent != self:
        child.setParent_(self)
    child.setParent_(self)
    # child.release()

</t>
<t tx="karstenw.20160619131304.29">def childAtIndex_( self, index ):
    # delegeate child getter
    if index &lt;= self.children.count():
        return self.children.objectAtIndex_( index )
    return None

</t>
<t tx="karstenw.20160619131304.3">
def __init__(self, value):
    if type(value) != list:
        if type(value) in (str, unicode, NSString, bool, int,
                           NSMutableString, objc.pyobjc_unicode):
            value = self.listFromDisplayValue_( value )
        elif isinstance(value, dict):
            value = self.listFromDictionary_( value )
        else:
            print "BOGATIVE VALUETYPE:", type(value)

    if type(value) != list:
        print "VALUE is not list"

    self.value = value
    self.typ = len(value) &gt; 1

</t>
<t tx="karstenw.20160619131304.30">def removeChild_(self, child):
    # retain: child-1
    # perhaps this should return the orphan

    # root is always outlineType
    index = self.children.indexOfObject_(child)
    if index != NSNotFound:
        self.children.removeObjectAtIndex_( index )
        return index
    return False

</t>
<t tx="karstenw.20160619131304.31">def isExpandable(self):
    return self.children.count() &gt; 0

</t>
<t tx="karstenw.20160619131304.32">def isRoot(self):
    return self.parent == None

</t>
<t tx="karstenw.20160619131304.33"># this is used too excessively, make it a var
def findRoot(self):
    if self.rootNode != None:
        return self.rootNode
    s = self
    while True:
        if s.parent == None:
            if s != self:
                self.rootNode = s
            return s
        s = s.parent

</t>
<t tx="karstenw.20160619131304.34">def pathFromRoot(self):
    l = []
    s = self
    while True:
        if s.parent == None:
            return l
        s = s.parent
        l.append( s )

</t>
<t tx="karstenw.20160619131304.35">#
# node math
#
def siblingCount(self):
    """How many are there me and my siblings?"""
    if self.parent == None:
        # i am root
        return -1
    p = self.parent
    # should work for tables too since root node is outline type
    l = p.children.count()
    return l

</t>
<t tx="karstenw.20160619131304.36">def siblingIndex(self):
    """What is my index in this sibling group?"""
    if self.parent == None:
        # i am root
        return -1
    p = self.parent
    index = p.children.indexOfObject_(self)
    if index == NSNotFound:
        return -1
    return index

</t>
<t tx="karstenw.20160619131304.37">def previousIndex(self):
    """The index of the sibling before me."""
    n = self.siblingIndex()
    if n &gt;= 0:
        if n &gt; 0:
            # not first, so there's one before me
            return n-1

        # is first
        return -1

    # no parent
    return -1

</t>
<t tx="karstenw.20160619131304.38">def nextIndex(self):
    """The index of the sibling after me."""
    n = self.siblingIndex()
    if n &gt;= 0:
        l = self.siblingCount()
        if n &lt; l - 1:
            # last index is allowed since it will be appended to the array
            return n+1
        # is last
        # perhaps left here
        return -1
    # no parent
    return n

</t>
<t tx="karstenw.20160619131304.39">def isFirst(self):
    """Am I the first sibling."""
    n = self.siblingIndex()
    return n == 0

</t>
<t tx="karstenw.20160619131304.4">def displayValue(self):
    # maxlen = max([len(k) for k in self.value.keys()])
    l = []
    if not isinstance(self.value, list):
        print "VALUE is not list"
        print repr(self.value)
    for t in self.value:
        k, v = t
        if k != "":
            l.append(u"%s:\t%s" % (k, v) )
        else:
            l.append(u"%s" % (v,))
    return '\n'. join(l)

</t>
<t tx="karstenw.20160619131304.40">def isLast(self):
    """Am I the last sibling."""
    n = self.siblingIndex()
    l = self.siblingCount()
    return n == (l - 1)

</t>
<t tx="karstenw.20160619131304.41">def next(self):
    """Return my immediate next sibling or -1."""
    n = self.nextIndex()
    if n &gt;= 0:
        return self.parent.children.objectAtIndex_(n)
    return -1

</t>
<t tx="karstenw.20160619131304.42">def previous(self):
    """Return my immediate previous sibling or -1."""
    n = self.previousIndex()
    if n &gt;= 0:
        return self.parent.children.objectAtIndex_(n)
    return -1

</t>
<t tx="karstenw.20160619131304.43">def isChildOf_(self, other):
    p = self
    i = 0
    while not p.isRoot():
        p = p.parent
        i += 1
        if p == other:
            return i
    return -1

</t>
<t tx="karstenw.20160619131304.44">def findFirstChildWithName_(self, name):
    for child in self.children:
        if child.name == name:
            return child

</t>
<t tx="karstenw.20160619131304.45">#
# node movements
#
def makeChildOf_(self, other):
    """Move self to be last child of other."""

    # parent needs to be saved since it's lost in addChild_
    parent = self.parent
    if parent == None:
        return -1
    other.addChild_(self)
    parent.removeChild_(self)

</t>
<t tx="karstenw.20160619131304.46">def moveLeft(self):
    # noveAfterParent
    """For dedenting."""
    if not self.typ in CactusOutlineTypes.hierarchicalTypes:
        return
    parent = self.parent
    if parent == None:
        return -1

    grandparent = parent.parent
    if parent.isLast():
        # append after parent
        self.makeChildOf_(grandparent)
        #grandparent.addChild_(self)
        #parent.removeChild_(self)

    else:
        # insert after parent
        parentIndex = parent.siblingIndex()
        grandparent.addChild_atIndex_(self, parentIndex+1)
        parent.removeChild_(self)

</t>
<t tx="karstenw.20160619131304.47">def moveRight(self):
    # make self child of previous
    if not self.typ in CactusOutlineTypes.hierarchicalTypes:
        return

    previous = self.previous()
    if previous != -1:
        self.makeChildOf_(previous)

</t>
<t tx="karstenw.20160619131304.48">def copyPython(self):
    result = []
    start = {
        'name': unicode(self.name),
        'value': self.getValueDict(),
        'typ': self.typ,
        'children': result}
    for i in self.children:
        result.append( i.copyPython() )
    return start


</t>
<t tx="karstenw.20160619131304.49">def copyNodesWithRoot_(self, root):
    result = []
    node = OutlineNode(self.name, self.getValueDict(), root, typeOutline, None)
    node.setComment_( self.comment )
    for i in self.children:
        node.addChild_( i.copyNodesWithRoot_(root) )
    return node

</t>
<t tx="karstenw.20160619131304.5">def listFromDisplayValue_(self, displayValue):
    try:
        lines = displayValue.split('\n')
    except AttributeError,err:
        print err
        lines = [ unicode(displayValue) ]

    l = []
    for line in lines:
        if line.count(':\t') == 0:
            k = u""
            v = line
        else:
            k, v = line.split(':\t', 1)
        l.append( (k, v) )
        d = {}
        for item in l:
            k, v = item
            if k in d:
                d[k] = d[k] + u'\n' + v
            else:
                d[k] = v
        l = d.items()
    return l

</t>
<t tx="karstenw.20160619131304.6">def listFromDictionary_(self, value):
    l = []
    for k, v in value.items():
        l.append( (k,v) )
    return l

</t>
<t tx="karstenw.20160619131304.7">def isSingleValue(self):
    if len(self.value) == 1:
        if self.value[0][0] in (u"", u"value"):
            return True
    return False

</t>
<t tx="karstenw.20160619131304.8">def isMultiValue(self):
    return not self.isSingleValue()



</t>
<t tx="karstenw.20160619131304.9">#
# Outline Node class
#

class OutlineNode(NSObject):

    """Wrapper class for items to be displayed in the outline view."""
    @others
</t>
<t tx="karstenw.20160619131434.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619131441.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619131507.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619131515.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619131522.1">
# the outline. what else?
typeOutline = 1

# the still used tableview. to be merged with outline
typeTable = 2

# an alternate view. exists only as an idea
typeBrowser = 3

# are these still used?
editorTypes = (typeOutline, typeTable, typeBrowser)
hierarchicalTypes = (typeOutline, typeBrowser)

</t>
<t tx="karstenw.20160619131524.1">#
#   CactusOutlineWindow.py
#
#   Created by Karsten Wolf on 04.12.13.
#   Copyright 2013 __MyCompanyName__. All rights reserved.
#

import sys
import os

import pdb
import pprint
pp = pprint.pprint
kwdbg = False
kwlog = True

import AppKit
NSApplication = AppKit.NSApplication
NSWindow = AppKit.NSWindow

NSFilenamesPboardType = AppKit.NSFilenamesPboardType
NSDragOperationCopy = AppKit.NSDragOperationCopy
NSFilenamesPboardType = AppKit.NSFilenamesPboardType
NSDragOperationNone = AppKit.NSDragOperationNone


</t>
<t tx="karstenw.20160619131524.2">class CactusOutlineWindow(NSWindow):
    @others
    """
    def draggingEntered_(self,sender):
        print "CactusOutlineWindow.draggingEntered_"
        pboard = sender.draggingPasteboard()
        types = pboard.types()
        opType = NSDragOperationNone
        if NSFilenamesPboardType in types:
            opType = NSDragOperationCopy
        return opType

    def performDragOperation_(self,sender):
        print "CactusOutlineWindow.performDragOperation_"
        pboard = sender.draggingPasteboard()
        successful = False
        if NSFilenamesPboardType in pboard.types():

            files = pboard.propertyListForType_( NSFilenamesPboardType )
            numberOfFiles = files.count()

            # Perform operation using the list of files
            # self.appDelegate.addFiles_( files )
            pp(files)

            successful = True
        return successful
    """</t>
<t tx="karstenw.20160619131524.3"># pass
def awakeFromNib(self):
    # self.registerForDraggedTypes_([NSFilenamesPboardType])
    pass
</t>
<t tx="karstenw.20160619131527.1"># -*- coding: utf-8 -*-

"""
"""



import objc

import Foundation
NSUserDefaults = Foundation.NSUserDefaults


import AppKit
NSApplication = AppKit.NSApplication
NSWindowController = AppKit.NSWindowController

import CactusTools

</t>
<t tx="karstenw.20160619131527.2">####

#
# Open Preferences
#
class CactusPreferenceController(NSWindowController):
    butSetCacheFolder = objc.IBOutlet()
    menDoctype = objc.IBOutlet()
    menEncoding = objc.IBOutlet()
    optAlternateLines = objc.IBOutlet()
    optCache = objc.IBOutlet()
    optNewDocumentOnStart = objc.IBOutlet()
    optCommentColumn = objc.IBOutlet()
    optHLines = objc.IBOutlet()
    optHTMLAutodetect = objc.IBOutlet()
    optIMLAutodetect = objc.IBOutlet()
    optIMLImportSystemLibraries = objc.IBOutlet()
    optOPMLAutodetect = objc.IBOutlet()
    optPLISTAutodetect = objc.IBOutlet()
    optRSSAutodetect = objc.IBOutlet()
    optRSSOpenEnclosure = objc.IBOutlet()
    optTypeColumn = objc.IBOutlet()
    optVLines = objc.IBOutlet()
    optValueColumn = objc.IBOutlet()
    optVariableRowHeight = objc.IBOutlet()
    txtCacheFolder = objc.IBOutlet()
    txtIndent = objc.IBOutlet()
    txtNoOfMaxRowLines = objc.IBOutlet()
    txtNoOfRecentURLs = objc.IBOutlet()
    txtUserEmail = objc.IBOutlet()
    txtUserName = objc.IBOutlet()
    optAnimateOPMLOpen = objc.IBOutlet()
    optMergeComment = objc.IBOutlet()
    optIgnoreDotFiles = objc.IBOutlet()

    """Present a dialog for entering a URL for http document retrieval."""
    @others
</t>
<t tx="karstenw.20160619131527.3">def init(self):
    self = self.initWithWindowNibName_("Preferences")

    wnd = self.window()

    wnd.setTitle_( u"Cactus Preferences" )
    wnd.setDelegate_( self )

    defaults = NSUserDefaults.standardUserDefaults()

    self.optCache.setState_( defaults.objectForKey_( u'optCache') )
    self.txtCacheFolder.setStringValue_( defaults.objectForKey_( u'txtCacheFolder') )
    self.txtNoOfMaxRowLines.setStringValue_( defaults.objectForKey_( u'txtNoOfMaxRowLines') )
    self.txtNoOfRecentURLs.setStringValue_( defaults.objectForKey_( u'txtNoOfRecentURLs') )
    self.txtUserEmail.setStringValue_( defaults.objectForKey_( u'txtUserEmail') )
    self.txtUserName.setStringValue_( defaults.objectForKey_( u'txtUserName') )
    self.optNewDocumentOnStart.setState_( defaults.objectForKey_( u'optNewDocumentOnStart') )

    self.optAnimateOPMLOpen.setState_( defaults.objectForKey_( u'optAnimateOPMLOpen') )
    self.optMergeComment.setState_( defaults.objectForKey_( u'optMergeComment') )
    self.optIgnoreDotFiles.setState_( defaults.objectForKey_( u'optIgnoreDotFiles') )

    self.optAlternateLines.setState_( defaults.objectForKey_( u'optAlternateLines') )
    self.optCommentColumn.setState_( defaults.objectForKey_( u'optCommentColumn') )
    self.optTypeColumn.setState_( defaults.objectForKey_( u'optTypeColumn') )
    self.optValueColumn.setState_( defaults.objectForKey_( u'optValueColumn') )

    self.optHLines.setState_( defaults.objectForKey_( u'optHLines') )
    self.optVLines.setState_( defaults.objectForKey_( u'optVLines') )
    self.optVariableRowHeight.setState_( defaults.objectForKey_( u'optVariableRowHeight') )

    self.menDoctype.setTitle_( defaults.objectForKey_( u'menDoctype') )
    self.menEncoding.setTitle_( defaults.objectForKey_( u'menEncoding') )
    self.txtIndent.setStringValue_( defaults.objectForKey_( u'txtIndent') )

    self.optIMLAutodetect.setState_( defaults.objectForKey_( u'optIMLAutodetect') )

    self.optOPMLAutodetect.setState_( defaults.objectForKey_( u'optOPMLAutodetect') )
    self.optRSSAutodetect.setState_( defaults.objectForKey_( u'optRSSAutodetect') )
    self.optHTMLAutodetect.setState_( defaults.objectForKey_( u'optHTMLAutodetect') )
    self.optPLISTAutodetect.setState_( defaults.objectForKey_( u'optPLISTAutodetect') )

    self.optRSSOpenEnclosure.setState_( defaults.objectForKey_( u'optRSSOpenEnclosure') )

    self.optIMLImportSystemLibraries.setState_( defaults.objectForKey_( u'optIMLImportSystemLibraries') )
    return self

</t>
<t tx="karstenw.20160619131527.4">def windowWillClose_(self, notification):
    defaults = NSUserDefaults.standardUserDefaults()
    defaults.setObject_forKey_(self.optCache.state(),   u'optCache')
    defaults.setObject_forKey_(self.txtCacheFolder.stringValue(),   u'txtCacheFolder')
    defaults.setObject_forKey_(self.txtNoOfMaxRowLines.stringValue(),   u'txtNoOfMaxRowLines')
    defaults.setObject_forKey_(self.txtNoOfRecentURLs.stringValue(),   u'txtNoOfRecentURLs')
    defaults.setObject_forKey_(self.txtUserEmail.stringValue(),   u'txtUserEmail')
    defaults.setObject_forKey_(self.txtUserName.stringValue(),   u'txtUserName')
    defaults.setObject_forKey_(self.optNewDocumentOnStart.state(),   u'optNewDocumentOnStart')

    defaults.setObject_forKey_(self.optAnimateOPMLOpen.state(),   u'optAnimateOPMLOpen')
    defaults.setObject_forKey_(self.optMergeComment.state(),   u'optMergeComment')
    defaults.setObject_forKey_(self.optIgnoreDotFiles.state(),   u'optIgnoreDotFiles')

    defaults.setObject_forKey_(self.optAlternateLines.state(),   u'optAlternateLines')
    defaults.setObject_forKey_(self.optCommentColumn.state(),   u'optCommentColumn')
    defaults.setObject_forKey_(self.optTypeColumn.state(),   u'optTypeColumn')
    defaults.setObject_forKey_(self.optValueColumn.state(),   u'optValueColumn')

    defaults.setObject_forKey_(self.optHLines.state(),   u'optHLines')
    defaults.setObject_forKey_(self.optVLines.state(),   u'optVLines')
    defaults.setObject_forKey_(self.optVariableRowHeight.state(),   u'optVariableRowHeight')

    defaults.setObject_forKey_(self.menDoctype.title(),   u'menDoctype')
    defaults.setObject_forKey_(self.menEncoding.title(),   u'menEncoding')
    defaults.setObject_forKey_(self.txtIndent.stringValue(),   u'txtIndent')

    defaults.setObject_forKey_(self.optIMLAutodetect.state(),   u'optIMLAutodetect')

    defaults.setObject_forKey_(self.optOPMLAutodetect.state(),   u'optOPMLAutodetect')
    defaults.setObject_forKey_(self.optRSSAutodetect.state(),   u'optRSSAutodetect')
    defaults.setObject_forKey_(self.optHTMLAutodetect.state(),   u'optHTMLAutodetect')
    defaults.setObject_forKey_(self.optPLISTAutodetect.state(),   u'optPLISTAutodetect')

    defaults.setObject_forKey_(self.optRSSOpenEnclosure.state(),   u'optRSSOpenEnclosure')

    defaults.setObject_forKey_(self.optIMLImportSystemLibraries.state(),   u'optIMLImportSystemLibraries')

</t>
<t tx="karstenw.20160619131527.5">@objc.IBAction
def chooseFolder_(self, sender):
    if sender == self.butSetCacheFolder:
        folders = CactusTools.getFolderDialog()
        if folders:
            self.txtCacheFolder.setStringValue_( folders[0] )


</t>
<t tx="karstenw.20160619131529.1">
# -*- coding: utf-8 -*-


"""
"""

import sys
import os

import datetime
import urllib

import xml.etree.cElementTree
etree = xml.etree.cElementTree

import pprint
pp = pprint.pprint

import pdb


import Foundation
NSObject = Foundation.NSObject
NSURL = Foundation.NSURL


import AppKit
NSDocument = AppKit.NSDocument
NSDocumentController = AppKit.NSDocumentController
NSWorkspace = AppKit.NSWorkspace

import PyObjCTools
#import PyObjCTools.NibClassBuilder
#extractClasses = PyObjCTools.NibClassBuilder.extractClasses
#AutoBaseClass = PyObjCTools.NibClassBuilder.AutoBaseClass


import CactusOutline
OutlineViewDelegateDatasource = CactusOutline.OutlineViewDelegateDatasource

import CactusOutlineNode
OutlineNode = CactusOutlineNode.OutlineNode


'''
class TableWindowController(AutoBaseClass):

    #
    # Can this be made for dual-use? outlines and tables?
    
    # the actual base class is NSWindowController
    # outlineView


    def init(self):
        # outline or table here
        # tables are outlines with no children
        doc = Document("Untitled", None)
        return self.initWithObject_type_(doc, typeOutline)


    def initWithObject_type_(self, obj, theType):
        """This controller is used for outline and table windows."""

        if theType == typeOutline:
            self = self.initWithWindowNibName_("OutlineEditor")
            title = u"Unnamed Outline"
        elif theType == typeTable:
            self = self.initWithWindowNibName_("TableEditor")
            title = u"Unnamed Table"
        elif theType == typeBrowser:
            pass #title = u"Browser"
        else:
            pass

        if not obj:
            obj = Document(title, None)

        self.path = ""
        self.root = None
        self.parentNode = None
        self.variableRowHeight = True

        if isinstance(obj, Document):
            self.path = obj.fileorurl
            self.root = obj.root
            self.parentNode = obj.parentNode

        # get window name from url or path
        if os.path.exists(self.path):
            fld, fle = os.path.split(self.path)
            title = fle
        elif self.path:
            title = self.path
        else:
            # keep unnamed title
            pass

        self.window().setTitle_( title )

        self.model = OutlineViewDelegateDatasource.alloc().initWithObject_type_parentNode_(
                                            self.root, theType, self.parentNode )

        # this is evil
        self.root.model = self.model

        self.model.setController_( self )
        self.outlineView.setDataSource_(self.model)
        self.outlineView.setDelegate_(self.model)

        self.outlineView.setTarget_(self)
        self.outlineView.setDoubleAction_("doubleClick:")

        self.window().makeFirstResponder_(self.outlineView)
        
        # store them columns
        self.nameColumn = self.outlineView.tableColumnWithIdentifier_( "name" )
        self.typeColumn = self.outlineView.tableColumnWithIdentifier_( "type" )
        self.valueColumn = self.outlineView.tableColumnWithIdentifier_( "value" )
        self.commentColumn = self.outlineView.tableColumnWithIdentifier_( "comment" )

        # set name column to wrap
        dataCell = self.nameColumn.dataCell()
        dataCell.setWraps_( True )

        # defaults to name &amp; value visible, type &amp; comment invisible
        typeVisible = self.optTypeVisible.setState_( False )
        commentVisible = self.optCommentVisible.setState_( False )
        self.applySettings_(None)

        self.showWindow_(self)

        # The window controller doesn't need to be retained (referenced)
        # anywhere, so we pretend to have a reference to ourselves to avoid
        # being garbage collected before the window is closed. The extra
        # reference will be released in self.windowWillClose_()
        self.retain()
        return self


    def windowWillClose_(self, notification):
        # see comment in self.initWithObject_()
        #
        # check model.dirty
        #
        self.autorelease()


    def doubleClick_(self, sender):
        # Open a new browser window for each selected expandable item
        print "doubleClick_()"

    def reloadData_(self, item=None, children=False):
        if item == None:
            self.outlineView.reloadData() #reloadItem_reloadChildren_( item, True )
        else:
            self.outlineView.reloadItem_reloadChildren_( item, children )

    def loadFile_(self, sender):
        pass
            

    def applySettings_(self, sender):
        """target of the apply button. sets some tableview settings.
        """
        # rowHeight
        self.variableRowHeight = self.optVariableRow.state()

        # menus - NOT YET USED
        formatChoice = self.menFormat.state()
        behaviourChoice = self.menBehaviour.state()

        # alterLines
        alterLines = self.optAlterLines.state()
        self.outlineView.setUsesAlternatingRowBackgroundColors_( alterLines )

        # columns
        tableColumns = self.outlineView.tableColumns()
        
        if self.optNameVisible.state():
            if not self.nameColumn in tableColumns:
                self.outlineView.addTableColumn_(self.nameColumn)
        else:
            if self.nameColumn in tableColumns:
                self.outlineView.removeTableColumn_(self.nameColumn)

        if self.optTypeVisible.state():
            if not self.typeColumn in tableColumns:
                self.outlineView.addTableColumn_(self.typeColumn)
        else:
            if self.typeColumn in tableColumns:
                self.outlineView.removeTableColumn_(self.typeColumn)

        if self.optValueVisible.state():
            if not self.valueColumn in tableColumns:
                self.outlineView.addTableColumn_(self.valueColumn)
        else:
            if self.valueColumn in tableColumns:
                self.outlineView.removeTableColumn_(self.valueColumn)

        if self.optCommentVisible.state():
            if not self.commentColumn in tableColumns:
                self.outlineView.addTableColumn_(self.commentColumn)
        else:
            if self.commentColumn in tableColumns:
                self.outlineView.removeTableColumn_(self.commentColumn)

        # grid style
        gridStyleMask = self.outlineView.gridStyleMask()
        newStyle = NSTableViewGridNone
        if self.optVLines.state():
            newStyle |= NSTableViewSolidVerticalGridLineMask
        if self.optHLines.state():
            newStyle |= NSTableViewSolidHorizontalGridLineMask
        self.outlineView.setGridStyleMask_(newStyle)

        #
        self.outlineView.reloadData()
        self.outlineView.setNeedsDisplay_( True )
'''</t>
<t tx="karstenw.20160619131535.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619131542.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619131549.1"># UNUSED
class CactusTableNode(NSObject):
    @others
</t>
<t tx="karstenw.20160619131549.2">def __new__(cls, *args, **kwargs):
    return cls.alloc().init()

</t>
<t tx="karstenw.20160619131549.3">def __repr__(self):
    return "&lt;CactusTableNode(%i, name='%s')" % (self.nodenr, self.name)

</t>
<t tx="karstenw.20160619131549.4">def __init__(self, name, obj, parent, rootNode):
    self.initphase = True

    # this is outlinetype, not valueType
    self.typ = typ

    self.maxHeight = 1
    self.setParent_(parent)
    self.rootNode = rootNode
    self.setName_( name )
    self.setValue_( obj )

    # self.setNodeAttributes( obj )

    self.setAttributes_( obj )
    self.setComment_( "" )

    self.children = NSMutableArray.arrayWithCapacity_( 0 )
    self.editable = True

    self.maxHeight = 1
    self.setMaxLineHeight()

    self.retain</t>
<t tx="karstenw.20160619131552.1">
# -*- coding: utf-8 -*-


"""Some tools which are needed by most files.
"""

import sys
import os

import traceback

import time
import datetime
import unicodedata

import struct

import mactypes
import appscript
asc = appscript
import Finder10

import CactusVersion
kwdbg = CactusVersion.developmentversion
kwlog = CactusVersion.developmentversion

import pdb

import re
import requests
import urllib
import urllib2
import urlparse
import StringIO
import gzip

import CactusDocumentTypes
CactusOPMLType = CactusDocumentTypes.CactusOPMLType
CactusRSSType = CactusDocumentTypes.CactusRSSType
CactusXMLType = CactusDocumentTypes.CactusXMLType
CactusHTMLType = CactusDocumentTypes.CactusHTMLType
CactusPLISTType = CactusDocumentTypes.CactusPLISTType
CactusIMLType = CactusDocumentTypes.CactusIMLType

CactusDocumentTypesSet = CactusDocumentTypes.CactusDocumentTypesSet
CactusDocumentXMLBasedTypesSet = CactusDocumentTypes.CactusDocumentXMLBasedTypesSet

import CactusXMLProperties
re_bogusCharacters = CactusXMLProperties.re_bogusCharacters

import feedparser

import objc

import Foundation
NSURL = Foundation.NSURL
NSFileManager = Foundation.NSFileManager
NSUserDefaults = Foundation.NSUserDefaults
NSString = Foundation.NSString

import AppKit
NSOpenPanel = AppKit.NSOpenPanel
NSAlert = AppKit.NSAlert
NSSavePanel = AppKit.NSSavePanel
NSFileHandlingPanelOKButton  = AppKit.NSFileHandlingPanelOKButton



</t>
<t tx="karstenw.20160619131552.10">def errorDialog( message="Error", title="Some error occured..."):
    return cancelContinueAlert(title, message)



</t>
<t tx="karstenw.20160619131552.11">#
# should be obsolete
#

#
# Open File
#
def getFileDialog(multiple=False):
    panel = NSOpenPanel.openPanel()
    panel.setCanChooseFiles_(True)
    panel.setCanChooseDirectories_(False)
    panel.setAllowsMultipleSelection_(multiple)
    rval = panel.runModalForTypes_( None )
    if rval:
        return [t for t in panel.filenames()]
    return []


</t>
<t tx="karstenw.20160619131552.12">def getFolderDialog(multiple=False):
    panel = NSOpenPanel.openPanel()
    panel.setCanChooseFiles_(False)
    panel.setCanChooseDirectories_(True)
    panel.setAllowsMultipleSelection_(multiple)
    rval = panel.runModalForTypes_([])
    if rval:
        return [t for t in panel.filenames()]
    return []


</t>
<t tx="karstenw.20160619131552.13">def NSURL2str( nsurl ):
    if isinstance(nsurl, NSURL):
        return str(nsurl.absoluteString())
    return nsurl

</t>
<t tx="karstenw.20160619131552.14">#
# File save dialog
#
# SHOULD NOT BE USED ANYMORE (NSDocument handling)
def saveAsDialog(path):
    panel = NSSavePanel.savePanel()

    if path:
        panel.setDirectory_( path )

    panel.setMessage_( u"Save as OPML" )
    panel.setExtensionHidden_( False )
    panel.setCanSelectHiddenExtension_(True)
    panel.setRequiredFileType_( u"opml" )
    if path:
        if not os.path.isdir( path ):
            folder, fle = os.path.split(path)
        else:
            folder = path
            fle = "Untitled.opml"
        rval = panel.runModalForDirectory_file_(folder, fle)
    else:
        rval = panel.runModal()

    if rval == NSFileHandlingPanelOKButton:
        return panel.filename()
    return False


</t>
<t tx="karstenw.20160619131552.15">def getFileProperties( theFile ):
    """
    """
    sfm = NSFileManager.defaultManager()
    props = sfm.fileAttributesAtPath_traverseLink_( theFile, True )
    if not props:
        return {}
    mtprops = props.mutableCopy()
    mtprops.removeObjectsForKeys_( [
        u"NSFileExtensionHidden",
        u"NSFileGroupOwnerAccountID",
        u"NSFileGroupOwnerAccountName",
        u"NSFileOwnerAccountID",
        u"NSFileOwnerAccountName",
        #u"NSFilePosixPermissions",
        #u"NSFileReferenceCount",
        # u"NSFileSize",
        #u"NSFileSystemFileNumber",
        u"NSFileSystemNumber",
        u"NSFileType",
        # u"NSFileHFSCreatorCode",
        # u"NSFileHFSTypeCode",
        #u"NSFileCreationDate"
        ] )
    return mtprops

</t>
<t tx="karstenw.20160619131552.16">def setFileProperties( theFile, props ):
    sfm = NSFileManager.defaultManager()
    return sfm.changeFileAttributes_atPath_( props, theFile )

</t>
<t tx="karstenw.20160619131552.17">def datestring_nsdate( dt=datetime.datetime.now() ):
    now = str(dt)
    now = now[:19]
    now = now + " +0000"
    return now


</t>
<t tx="karstenw.20160619131552.18">def getDownloadFolder( nsurl ):
    defaults = NSUserDefaults.standardUserDefaults()
    cacheFolder = CactusVersion.cachefolder
    try:
        cacheFolder = unicode(defaults.objectForKey_( u'txtCacheFolder'))
    except StandardError, err:
        print "CactusTools.getDownloadFolder(%s) -&gt; False" % NSURL2str(nsurl)
        print "ERROR reading defaults.", repr(err)

    cacheFolder = os.path.expanduser( cacheFolder )

    # parent folder must exists; minimal plausibility
    parent, foldername = os.path.split( cacheFolder )
    if not os.path.exists( parent ):
        print "CactusTools.getDownloadFolder(%s) -&gt; False" % NSURL2str(nsurl)
        return False, False

    if not os.path.exists(cacheFolder):
        os.makedirs( cacheFolder )
    #
    localpath = makeunicode( nsurl.relativePath() )
    s = nsurl.absoluteString()
    if '#' in s:
        n = s.count( '/' )
        if n &gt;= 3:
            l = s.split( '/' )
            filename = l[-1]
            filename = urllib.unquote( filename )
            base , fname = os.path.split( localpath )

            localpath = os.path.join( base, filename )

    if localpath.startswith( u'/' ):
        localpath = localpath[1:]
    localpath = os.path.join( makeunicode(nsurl.host()), localpath)

    if localpath:
        localrelfolder, localname = os.path.split( localpath )
        localpath = os.path.join( cacheFolder, localpath )
        if kwdbg:
            print "CactusTools.getDownloadFolder(%s) -&gt; %s" % (NSURL2str(nsurl), repr(localpath) )
        return localpath, localname
    return False, False


</t>
<t tx="karstenw.20160619131552.19">def getRemotefilemodificationDate( url ):

    try:
        f = urllib.urlopen( url )
    except IOError, err:
        print "ERROR: Could not open url (%s) for date reading." % url
        return False

    rinfo = f.info()
    f.close()

    remotemodfdate = rinfo.getdate('last-modified')
    if remotemodfdate:
        try:
            rmodfdate = datetime.datetime( *remotemodfdate[:6] )
            #rmodfdate = datetime.datetime( *rinfo.getdate('last-modified')[:6] )
        except TypeError, err:
            print "Could not get remote file(%s) modification date." % url
            return False
        return rmodfdate
    return False

</t>
<t tx="karstenw.20160619131552.2">#
# tools
#

def num2ostype( num ):
    if num == 0:
        return '????'
    s = struct.pack("&gt;I", num)
    return makeunicode(s, "macroman")


</t>
<t tx="karstenw.20160619131552.20">def setFileModificationDate( filepath, modfdt ):
    l = getFileProperties( filepath )
    date = Foundation.NSDate.dateWithString_( datestring_nsdate( modfdt ) )
    l['NSFileModificationDate'] = date
    setFileProperties( filepath, l)
    folder, filename = os.path.split( filepath )
    print "Setting file(%s) modification date to %s" % (filename, repr(modfdt))


</t>
<t tx="karstenw.20160619131552.21">def cache_url( nsurl, fileextension ):
    if 1:
        print "CactusTools.cache_url( %s, %s )" % (nsurl, fileextension)

    if not nsurl:
        return False

    returnURL = nsurl
    url = NSURL2str( nsurl )

    try:
        localpath, localname = getDownloadFolder(nsurl)

        # perhaps we are not caching
        if not localpath:
            return nsurl

        if not localpath.endswith(localname):
            localfullpath = os.path.join(localpath, localname)

        folder, filename = os.path.split( localpath )
        if not os.path.exists(folder):
            os.makedirs( folder )

        dodownload = False
        if os.path.exists( localpath ):
            # file already downloaded; perhaps set file modification date
            lmodfdate = os.stat( localpath ).st_mtime
            lmodfdate = datetime.datetime.utcfromtimestamp( lmodfdate )
            rmodfdate = getRemotefilemodificationDate( url )

            if not rmodfdate:
                # remote modification date could not be determined
                pass
            elif rmodfdate and rmodfdate &lt; lmodfdate:
                setFileModificationDate( localpath, rmodfdate )
            elif rmodfdate and rmodfdate == lmodfdate:
                pass
            else:
                dodownload = True
        else:
            dodownload = True

        if dodownload:
            #
            if os.path.isdir( localpath ):
                if not localname:
                    localname = "file"
                    localpath = os.path.join( localpath, localname + "." + fileextension )

            if fileextension:
                if not localpath.lower().endswith( "." + fileextension.lower() ):
                    localpath = localpath + '.' + fileextension

            print "LOAD: %s..." % url
            headers = {}
            r = requests.get( url )
            s = r.content
            headers = r.headers
            r.close()
            fob = open(localpath, 'w')
            fob.write( s )
            fob.close()
            
            dts = feedparser._parse_date( headers.get( 'last-modified', '' ) )
            dt = datetime.datetime.fromtimestamp(time.mktime( dts ))

            try:
                finder = asc.app(u'Finder.app', terms=Finder10)
                hfspath = mactypes.File( localpath ).hfspath
                finder.files[hfspath].comment.set( url )
            except StandardError, v:
                print "SET COMMENT FAILED ON '%s'" % localpath
            # get file date
            lmodfdate = os.stat( localpath ).st_mtime
            lmodfdate = datetime.datetime.utcfromtimestamp( lmodfdate )
            try:
                # rmodfdate = datetime.datetime( *headers.getdate('last-modified')[:6] )
                # setFileModificationDate( localpath, rmodfdate )
                setFileModificationDate( localpath, dt )
            except TypeError as err:
                # do not cache if modification date cannot be determined
                print "NOCACHE: Could not get remote file(%s) modification date." % url
                print( err )
            print "LOAD: %s...done" % url
            print "LOCAL:", repr(localpath)

        returnURL = NSURL.fileURLWithPath_( unicode(localpath) )

    except Exception, err:
        tb = unicode(traceback.format_exc())
        print tb
        print

    return returnURL

</t>
<t tx="karstenw.20160619131552.22">def mergeURLs( base, rel ):
    """create an url with base as the base, updated by existing parts of rel."""
    s = u"CactusTools.mergeURLs(%s, %s) -&gt;  %s"

    prel = urlparse.urlparse( rel )
    if prel.scheme and prel.netloc:
        return prel.geturl()

    if type(base) in (NSURL,):
        base = NSURL2str(base)
    
    # it's a relative path

    pbase = urlparse.urlparse( base )

    path = pbase.path
    folder, filename = os.path.split( path )
    basename, ext = os.path.splitext( filename )
    if ext != "" and path[-1] != '/':
        path = os.path.join(folder, rel)
    else:
        path = os.path.join(path, rel)
    

    target = urlparse.ParseResult(
        scheme = pbase.scheme,
        netloc = pbase.netloc,
        path = path,
        params = prel.params if (prel.params) else pbase.params,
        query = prel.query if (prel.query) else pbase.query,
        fragment = prel.fragment if (prel.fragment) else pbase.fragment)

    target = urlparse.urlunparse( target )
    try:
        s = s % ( base, rel, target)
        print s.encode("utf-8")
    except Exception, err:
        print
        print "ERROR in mergeURL"
        print err
        print "base:", repr(base)
        print "rel:", repr(rel)
        print "target:", repr(target)
        print
    return target


</t>
<t tx="karstenw.20160619131552.23">def getURLExtension( url ):
    purl = urlparse.urlparse( url )
    path = purl.path
    folder, filename = os.path.split( path )
    basename, ext = os.path.splitext( filename )
    if kwdbg:
        print "CactusTools.getURLExtension(%s) -&gt; '%s' . '%s'" % ( url, basename, ext )
    return (basename, ext)
</t>
<t tx="karstenw.20160619131552.3">def ostype2num( ostype ):
    return struct.pack('BBBB', list(ostype))


</t>
<t tx="karstenw.20160619131552.4">def makeunicode(s, srcencoding="utf-8", normalizer="NFC"):
    try:
        if type(s) not in (unicode, objc.pyobjc_unicode):
            s = unicode(s, srcencoding)
    except TypeError:
        print "makeunicode type conversion error"
        print "FAILED converting", type(s), "to unicode"
    s = unicodedata.normalize(normalizer, s)
    return s




</t>
<t tx="karstenw.20160619131552.5">def detectFileTypeAtURL( nsfileurl ):
    """Not yet sure how to autodetect without reading some files twice.

    So far the parsers used are:
        OPML: cElementTree (opens string)
        RSS: feedparser (opens string)
        XML: cElementTree (opens string)
        HTML: lxml (opens URL)
        PLIST: NSDictionary.dictionaryWithContentsOfURL_ (opens URL)
    """
    pass


</t>
<t tx="karstenw.20160619131552.6">def detectFileTypeLocalFile( path ):
    # this needs to be checked against the binary string
    xmlre = re.compile( r'''^&lt;?xml\s+version\s*="1.0"\s+encoding\s*=\s*"''' )




</t>
<t tx="karstenw.20160619131552.7">def readURL( nsurl, type_="" ):
    """Read a file. May be local, may be http"""
    url = NSURL2str(nsurl)
    if kwlog:
        print "CactusTools.readURL( '%s', '%s' )" % (url, type_)


    translateType = {
        CactusOPMLType: "opml",
        CactusHTMLType: "html",
        CactusXMLType: "xml",
        CactusRSSType: "rss",
        CactusPLISTType: "plist",
        CactusIMLType: "xml"
    }

    fileext = translateType.get( type_, ".bin")

    defaults = NSUserDefaults.standardUserDefaults()
    cache = False
    try:
        cache = bool(defaults.objectForKey_( u'optCache'))
    except StandardError, err:
        print "ERROR reading defaults.", repr(err)
    
    if cache:
        if not nsurl.isFileURL():
            nsurl = cache_url(nsurl, fileext)

    url = NSURL2str(nsurl)

    r = requests.get( url )
    s = r.content
    headers = r.headers
    r.close()

    # check for gzip compressed opml file
    # pdb.set_trace()
    try:
        if len(s) &gt; 2:
            if ord(s[0]) == 0x1f:
                if ord(s[1]) == 0x8b:
                    unzipped = gzip.GzipFile( fileobj=StringIO.StringIO(s) ).read()
                    s = unzipped
    except Exception:
        pass

    if type_ == CactusOPMLType:
        # this is a quick &amp; dirty approach and should be applied much more carefully
        # than it is now... perhaps those errors get corrected and &lt;directivecache&gt;
        # will be a propper node.

        # clean up bogative xml declaration. OPML-Editor, I'm looking at you...
        if s.startswith("""&lt;?xml encoding="ISO-8859-1" version="1.0"?&gt;"""):
            s = s.replace("""&lt;?xml encoding="ISO-8859-1" version="1.0"?&gt;""",
                          """&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;""")

            if kwlog:
                print "\nBOGUS XML DELARATION REPLACED\n"

        # this error occurs up until now only combined with the previous one
        if "&lt;directiveCache&gt;" in s:
            s = s.replace( "&lt;directiveCache&gt;", "&lt;/outline&gt;")
            if kwlog:
                print "\nBOGUS &lt;directiveCache&gt; XML TAG REPLACED\n"

        #
        # opmleditor rules error
        #
        startrule = """text="&amp;lt;rules &lt;"""
        endrule = """&amp;gt;"&gt;"""

        if startrule in s:
            n = s.count(startrule)
            if kwlog:
                print "BOGUS OPML RULE SECTION: %i SUBSTITUTIONS" % n
            idx = s1 = s2 = 0
            for i in range(1, n+1):
                # get location o next start- ans endrule
                s1 = s.find( startrule,s2 )
                s2 = s.find( endrule, s1 )
                s2 = s2 + len(endrule)

                # save stuff before, location and after bogative rule
                pre = s[:s1]
                defectiveSnippet = s[s1:s2]
                post = s[s2:]

                if kwlog:
                    print "\nOLD", repr(defectiveSnippet)

                # clear out false markers
                defectiveSnippet = defectiveSnippet.replace( startrule, "&lt;")
                defectiveSnippet = defectiveSnippet.replace( endrule, "")

                defectiveSnippet = defectiveSnippet.replace( '&lt;', "&amp;lt;")
                defectiveSnippet = defectiveSnippet.replace( '&gt;', "&amp;gt;")
                defectiveSnippet = defectiveSnippet.replace( '"', "&amp;quot;")

                # restore start and end
                defectiveSnippet = 'text="' + defectiveSnippet + '"&gt;'

                # advance pointer
                s2 = len(pre) + len(defectiveSnippet)

                # restore s
                s = pre + defectiveSnippet + post

                if kwlog:
                    print "\nNEW", repr(defectiveSnippet)

    if type_ in CactusDocumentXMLBasedTypesSet:
        # this apllies to all since cactus currently only reads xml files
        if s.startswith("&lt;?xml ") or s.startswith("&lt;opml") or s.startswith("&lt;rss"):
            re_bogusCharacters = re.compile(r'[\x00-\x08\x0b\x0c\x0e-\x1f]')

            # TBD: perhaps an effort to preserve the replaced character should be made here
            # use urlescape
            t = re.sub( re_bogusCharacters, "???", s)
            if s != t:
                print "Bogus characters in XML..."
            s = t
    return s


</t>
<t tx="karstenw.20160619131552.8"># UNUSED
def classifyAndReadUrl( url ):
    """TBD

    Read in an URL and try to classify it as opml, bogative opml, rss, xml.
    """

    s = readURL( url )

    # check for bogative OPML editor xml declaration
    bogus = re.compile( """&lt;?xml encoding=["']ISO-8859-1["'] version=["']1.0["']?&gt;""" )
    if s.startswith("""&lt;?xml encoding="ISO-8859-1" version="1.0"?&gt;"""):
        pass


    # the type should be determinable within the first 250 bytes
    checkpart = s[:250]

    xmlre = re.compile( "^&lt;?xml\W+version" )
    rspre = re.compile( "&lt;reallySimplePhoto" )
    opmlre = re.compile( "&lt;opml version" )

    if checkpart.startswith( "&lt;?xml version" ):
        pass
        # we have a xml based document

    if checkpart.startswith( "&lt;?xml version" ):
        pass
        # check for opml
        # check for rss


</t>
<t tx="karstenw.20160619131552.9">#
# dialogs
#
def cancelContinueAlert(title, message, butt1="OK", butt2=False):
    """Run a generic Alert with buttons "Weiter" &amp; "Abbrechen".

       Returns True if "Weiter"; False otherwise
    """
    alert = NSAlert.alloc().init()
    alert.setAlertStyle_( 0 )
    alert.setInformativeText_( title )
    alert.setMessageText_( message )
    alert.setShowsHelp_( False )
    alert.addButtonWithTitle_( butt1 )

    if butt2:
        # button 2 has keyboard equivalent "Escape"
        button2 = alert.addButtonWithTitle_( butt2 )
        button2.setKeyEquivalent_( unichr(27) )

    f = alert.runModal()
    return f == AppKit.NSAlertFirstButtonReturn


</t>
<t tx="karstenw.20160619131607.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619131616.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619131622.1">
# -*- coding: utf-8 -*-


"""A class to handle all of Cactus URL conversion needs.
"""

import sys
import os

import traceback

import datetime
import unicodedata

import struct

import mactypes
import appscript
asc = appscript

import CactusVersion
kwdbg = CactusVersion.developmentversion
kwlog = CactusVersion.developmentversion

import pdb

import re

import urllib
import urllib2
import urlparse

import Foundation
NSURL = Foundation.NSURL
NSString = Foundation.NSString


</t>
<t tx="karstenw.20160619131622.2">def NSURL2str( nsurl ):
    if isinstance(nsurl, NSURL):
        return str(nsurl.absoluteString())
    return nsurl


</t>
<t tx="karstenw.20160619131622.3">class CactusURL(object):
    @others
</t>
<t tx="karstenw.20160619131622.4">def __init__(self, url):
    # str, unicode or NSURL
    self.inputurl = url
    t = type(url)
    if t in (str, unicode):
        self.url = url
    elif t in (NSURL,):
        self.url = NSURL2str( url )
    p = urlparse.urlparse( self.url )
    self.schema = p.schema
</t>
<t tx="karstenw.20160619131622.5">def ascachepath(self):
    pass

</t>
<t tx="karstenw.20160619131625.1">
import os

appname ="Cactus Outline-Editor"
appnameshort = "Cactus"

copyright = 'Copyright 2011-2021 Karsten Wolf'

version = "0.7.8"

# 
user_agent = "%s/%s +https://github.com/karstenw/Cactus-opml-Outliner" % (appname, version)

document_creator = "Created by %s %s" % (appname, version)

cachefolder = os.path.expanduser("~/Library/Application Support/%s" % appname )

developmentversion = False
</t>
<t tx="karstenw.20160619131631.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619131636.1">
# -*- coding: utf-8 -*-


"""A unsorted collection of items regarding XML properties which are needed in
different places.
"""


import re


# in XML the only valid characters in the range 0-32 are:
# 09 - tab
# 0a - newline
# 0d - carriage return
re_bogusCharacters = re.compile(r'[\x00-\x08\x0b\x0c\x0e-\x1f]')
</t>
<t tx="karstenw.20160619131957.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619132007.1">version = 1.1
path = 'Finder10.sdef'

classes = [       ('application', 'capp'),
        ('item', 'cobj'),
        ('container', 'ctnr'),
        ('computer_object', 'ccmp'),
        ('disk', 'cdis'),
        ('folder', 'cfol'),
        ('desktop_object', 'cdsk'),
        ('trash_object', 'ctrs'),
        ('file', 'file'),
        ('alias_file', 'alia'),
        ('application_file', 'appf'),
        ('document_file', 'docf'),
        ('internet_location_file', 'inlf'),
        ('clipping', 'clpf'),
        ('package', 'pack'),
        ('window', 'cwin'),
        ('Finder_window', 'brow'),
        ('desktop_window', 'dktw'),
        ('information_window', 'iwnd'),
        ('preferences_window', 'pwnd'),
        ('clipping_window', 'lwnd'),
        ('process', 'prcs'),
        ('application_process', 'pcap'),
        ('desk_accessory_process', 'pcda'),
        ('preferences', 'cprf'),
        ('label', 'clbl'),
        ('icon_family', 'ifam'),
        ('icon_view_options', 'icop'),
        ('column_view_options', 'cvop'),
        ('list_view_options', 'lvop'),
        ('column', 'lvcl'),
        ('alias_list', 'alst')]

enums = [       ('read_only', 'read'),
        ('read_write', 'rdwr'),
        ('write_only', 'writ'),
        ('none', 'none'),
        ('Mac_OS_format', 'dfhf'),
        ('Mac_OS_Extended_format', 'dfh+'),
        ('UFS_format', 'dfuf'),
        ('NFS_format', 'dfnf'),
        ('audio_format', 'dfau'),
        ('ProDOS_format', 'dfpr'),
        ('MSDOS_format', 'dfms'),
        ('NTFS_format', 'dfnt'),
        ('ISO_9660_format', 'df96'),
        ('High_Sierra_format', 'dfhs'),
        ('QuickTake_format', 'dfqt'),
        ('Apple_Photo_format', 'dfph'),
        ('AppleShare_format', 'dfas'),
        ('UDF_format', 'dfud'),
        ('WebDAV_format', 'dfwd'),
        ('FTP_format', 'dfft'),
        ('Packet_written_UDF_format', 'dfpu'),
        ('Xsan_format', 'dfac'),
        ('unknown_format', 'df??'),
        ('General_Information_panel', 'gpnl'),
        ('Sharing_panel', 'spnl'),
        ('Memory_panel', 'mpnl'),
        ('Preview_panel', 'vpnl'),
        ('Application_panel', 'apnl'),
        ('Languages_panel', 'pklg'),
        ('Plugins_panel', 'pkpg'),
        ('Name_and_Extension_panel', 'npnl'),
        ('Comments_panel', 'cpnl'),
        ('Content_Index_panel', 'cinl'),
        ('Burning_panel', 'bpnl'),
        ('More_Info_panel', 'minl'),
        ('Simple_Header_panel', 'shnl'),
        ('General_Preferences_panel', 'pgnp'),
        ('Label_Preferences_panel', 'plbp'),
        ('Sidebar_Preferences_panel', 'psid'),
        ('Advanced_Preferences_panel', 'padv'),
        ('icon_view', 'icnv'),
        ('list_view', 'lsvw'),
        ('column_view', 'clvw'),
        ('group_view', 'grvw'),
        ('flow_view', 'flvw'),
        ('not_arranged', 'narr'),
        ('snap_to_grid', 'grda'),
        ('arranged_by_name', 'nama'),
        ('arranged_by_modification_date', 'mdta'),
        ('arranged_by_creation_date', 'cdta'),
        ('arranged_by_size', 'siza'),
        ('arranged_by_kind', 'kina'),
        ('arranged_by_label', 'laba'),
        ('right', 'lrgt'),
        ('bottom', 'lbot'),
        ('normal', 'snrm'),
        ('reversed', 'srvs'),
        ('name_column', 'elsn'),
        ('modification_date_column', 'elsm'),
        ('creation_date_column', 'elsc'),
        ('size_column', 'elss'),
        ('kind_column', 'elsk'),
        ('label_column', 'elsl'),
        ('version_column', 'elsv'),
        ('comment_column', 'elsC'),
        ('small_icon', 'smic'),
        ('large_icon', 'lgic'),
        ('mini', 'miic'),
        ('small', 'smic'),
        ('large', 'lgic'),
        ('name', 'pnam'),
        ('modification_date', 'asmo'),
        ('creation_date', 'ascd'),
        ('size', 'phys'),
        ('kind', 'kind'),
        ('label_index', 'labi'),
        ('comment', 'comt'),
        ('version', 'vers')]

properties = [       ('clipboard', 'pcli'),
        ('name', 'pnam'),
        ('visible', 'pvis'),
        ('frontmost', 'pisf'),
        ('selection', 'sele'),
        ('insertion_location', 'pins'),
        ('product_version', 'ver2'),
        ('version', 'vers'),
        ('startup_disk', 'sdsk'),
        ('desktop', 'desk'),
        ('trash', 'trsh'),
        ('home', 'home'),
        ('computer_container', 'pcmp'),
        ('Finder_preferences', 'pfrp'),
        ('name', 'pnam'),
        ('displayed_name', 'dnam'),
        ('name_extension', 'nmxt'),
        ('extension_hidden', 'hidx'),
        ('index', 'pidx'),
        ('container', 'ctnr'),
        ('disk', 'cdis'),
        ('position', 'posn'),
        ('desktop_position', 'dpos'),
        ('bounds', 'pbnd'),
        ('label_index', 'labi'),
        ('locked', 'aslk'),
        ('kind', 'kind'),
        ('description', 'dscr'),
        ('comment', 'comt'),
        ('size', 'ptsz'),
        ('physical_size', 'phys'),
        ('creation_date', 'ascd'),
        ('modification_date', 'asmo'),
        ('icon', 'iimg'),
        ('URL', 'pURL'),
        ('owner', 'sown'),
        ('group', 'sgrp'),
        ('owner_privileges', 'ownr'),
        ('group_privileges', 'gppr'),
        ('everyones_privileges', 'gstp'),
        ('information_window', 'iwnd'),
        ('properties', 'pALL'),
        ('class_', 'pcls'),
        ('entire_contents', 'ects'),
        ('expandable', 'pexa'),
        ('expanded', 'pexp'),
        ('completely_expanded', 'pexc'),
        ('container_window', 'cwnd'),
        ('id', 'ID  '),
        ('capacity', 'capa'),
        ('free_space', 'frsp'),
        ('ejectable', 'isej'),
        ('local_volume', 'isrv'),
        ('startup', 'istd'),
        ('format', 'dfmt'),
        ('journaling_enabled', 'Jrnl'),
        ('ignore_privileges', 'igpr'),
        ('warns_before_emptying', 'warn'),
        ('file_type', 'asty'),
        ('creator_type', 'fcrt'),
        ('stationery', 'pspd'),
        ('product_version', 'ver2'),
        ('version', 'vers'),
        ('original_item', 'orig'),
        ('id', 'ID  '),
        ('suggested_size', 'sprt'),
        ('minimum_size', 'mprt'),
        ('preferred_size', 'appt'),
        ('accepts_high_level_events', 'isab'),
        ('has_scripting_terminology', 'hscr'),
        ('opens_in_Classic', 'Clsc'),
        ('location', 'iloc'),
        ('clipping_window', 'lwnd'),
        ('id', 'ID  '),
        ('position', 'posn'),
        ('bounds', 'pbnd'),
        ('titled', 'ptit'),
        ('name', 'pnam'),
        ('index', 'pidx'),
        ('closeable', 'hclb'),
        ('floating', 'isfl'),
        ('modal', 'pmod'),
        ('resizable', 'prsz'),
        ('zoomable', 'iszm'),
        ('zoomed', 'pzum'),
        ('visible', 'pvis'),
        ('collapsed', 'wshd'),
        ('properties', 'pALL'),
        ('target', 'fvtg'),
        ('current_view', 'pvew'),
        ('icon_view_options', 'icop'),
        ('list_view_options', 'lvop'),
        ('column_view_options', 'cvop'),
        ('toolbar_visible', 'tbvi'),
        ('statusbar_visible', 'stvi'),
        ('sidebar_width', 'sbwi'),
        ('item', 'cobj'),
        ('current_panel', 'panl'),
        ('current_panel', 'panl'),
        ('name', 'pnam'),
        ('visible', 'pvis'),
        ('frontmost', 'pisf'),
        ('file', 'file'),
        ('file_type', 'asty'),
        ('creator_type', 'fcrt'),
        ('accepts_high_level_events', 'isab'),
        ('accepts_remote_events', 'revt'),
        ('has_scripting_terminology', 'hscr'),
        ('total_partition_size', 'appt'),
        ('partition_space_used', 'pusd'),
        ('application_file', 'appf'),
        ('desk_accessory_file', 'dafi'),
        ('window', 'cwin'),
        ('icon_view_options', 'icop'),
        ('list_view_options', 'lvop'),
        ('column_view_options', 'cvop'),
        ('folders_spring_open', 'sprg'),
        ('delay_before_springing', 'dela'),
        ('desktop_shows_hard_disks', 'pdhd'),
        ('desktop_shows_external_hard_disks', 'pehd'),
        ('desktop_shows_removable_media', 'pdrm'),
        ('desktop_shows_connected_servers', 'pdsv'),
        ('new_window_target', 'pnwt'),
        ('folders_open_in_new_windows', 'ponw'),
        ('folders_open_in_new_tabs', 'pont'),
        ('new_windows_open_in_column_view', 'pocv'),
        ('all_name_extensions_showing', 'psnx'),
        ('name', 'pnam'),
        ('index', 'pidx'),
        ('color', 'colr'),
        ('large_monochrome_icon_and_mask', 'ICN#'),
        ('large_8_bit_mask', 'l8mk'),
        ('large_32_bit_icon', 'il32'),
        ('large_8_bit_icon', 'icl8'),
        ('large_4_bit_icon', 'icl4'),
        ('small_monochrome_icon_and_mask', 'ics#'),
        ('small_8_bit_mask', 'ics8'),
        ('small_32_bit_icon', 'is32'),
        ('small_8_bit_icon', 'ics8'),
        ('small_4_bit_icon', 'ics4'),
        ('arrangement', 'iarr'),
        ('icon_size', 'lvis'),
        ('shows_item_info', 'mnfo'),
        ('shows_icon_preview', 'prvw'),
        ('text_size', 'fsiz'),
        ('label_position', 'lpos'),
        ('background_picture', 'ibkg'),
        ('background_color', 'colr'),
        ('text_size', 'fsiz'),
        ('shows_icon', 'shic'),
        ('shows_icon_preview', 'prvw'),
        ('shows_preview_column', 'shpr'),
        ('discloses_preview_pane', 'dspr'),
        ('calculates_folder_sizes', 'sfsz'),
        ('shows_icon_preview', 'prvw'),
        ('icon_size', 'lvis'),
        ('text_size', 'fsiz'),
        ('sort_column', 'srtc'),
        ('uses_relative_dates', 'urdt'),
        ('index', 'pidx'),
        ('name', 'pnam'),
        ('sort_direction', 'sord'),
        ('width', 'clwd'),
        ('minimum_width', 'clwn'),
        ('maximum_width', 'clwm'),
        ('visible', 'pvis')]

elements = [       ('application', 'capp'),
        ('items', 'cobj'),
        ('containers', 'ctnr'),
        ('computer_objects', 'ccmp'),
        ('disks', 'cdis'),
        ('folders', 'cfol'),
        ('desktop_objects', 'cdsk'),
        ('trash_objects', 'ctrs'),
        ('files', 'file'),
        ('alias_files', 'alia'),
        ('application_files', 'appf'),
        ('document_files', 'docf'),
        ('internet_location_files', 'inlf'),
        ('clippings', 'clpf'),
        ('packages', 'pack'),
        ('windows', 'cwin'),
        ('Finder_windows', 'brow'),
        ('desktop_windows', 'dktw'),
        ('information_windows', 'iwnd'),
        ('preferences_windows', 'pwnd'),
        ('clipping_windows', 'lwnd'),
        ('process', 'prcs'),
        ('application_process', 'pcap'),
        ('desk_accessory_process', 'pcda'),
        ('preferences', 'cprf'),
        ('labels', 'clbl'),
        ('icon_familys', 'ifam'),
        ('icon_view_options', 'icop'),
        ('column_view_options', 'cvop'),
        ('list_view_options', 'lvop'),
        ('columns', 'lvcl'),
        ('alias_lists', 'alst')]

commands = [       ('open', 'aevtodoc', [('using', 'usin'), ('with_properties', 'prdt')]),
        ('print_', 'aevtpdoc', [('with_properties', 'prdt')]),
        ('quit', 'aevtquit', []),
        ('activate', 'miscactv', []),
        ('close', 'coreclos', []),
        ('count', 'corecnte', [('each', 'kocl')]),
        ('data_size', 'coredsiz', [('as_', 'rtyp')]),
        ('delete', 'coredelo', []),
        (       'duplicate',
                'coreclon',
                [       ('to', 'insh'),
                        ('replacing', 'alrp'),
                        ('routing_suppressed', 'rout'),
                        ('exact_copy', 'exct')]),
        ('exists', 'coredoex', []),
        (       'make',
                'corecrel',
                [       ('new', 'kocl'),
                        ('at', 'insh'),
                        ('to', 'to  '),
                        ('with_properties', 'prdt')]),
        (       'move',
                'coremove',
                [       ('to', 'insh'),
                        ('replacing', 'alrp'),
                        ('positioned_at', 'mvpl'),
                        ('routing_suppressed', 'rout')]),
        ('select', 'miscslct', []),
        ('copy', 'misccopy', []),
        ('sort', 'DATASORT', [('by', 'by  ')]),
        ('clean_up', 'fndrfclu', [('by', 'by  ')]),
        ('eject', 'fndrejct', []),
        ('empty', 'fndrempt', [('security', 'sec?')]),
        ('erase', 'fndrfera', []),
        ('reveal', 'miscmvis', []),
        ('update', 'fndrfupd', [('necessity', 'nec?'), ('registering_applications', 'reg?')]),
        ('restart', 'fndrrest', []),
        ('shut_down', 'fndrshut', []),
        ('sleep', 'fndrslep', [])]

</t>
<t tx="karstenw.20160619132017.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619132023.1">"""PyRSS2Gen - A Python library for generating RSS 2.0 feeds."""

__name__ = "PyRSS2Gen"
__version__ = (1, 1, 0)
__author__ = "Andrew Dalke &lt;dalke@dalkescientific.com&gt;"

_generator_name = __name__ + "-" + ".".join(map(str, __version__))

import datetime

import sys

if sys.version_info[0] == 3:
    # Python 3
    basestring = str
    from io import StringIO
else:
    # Python 2
    try:
        from cStringIO import StringIO
    except ImportError:
        # Very old (or memory constrained) systems might
        # have left out the compiled C version. Fall back
        # to the pure Python one. Haven't seen this sort
        # of system since the early 2000s.
        from StringIO import StringIO

</t>
<t tx="karstenw.20160619132023.10">def publish(self, handler):
    handler.startElement(self.name, self.element_attrs)
    handler.characters(str(self.val))
    handler.endElement(self.name)

</t>
<t tx="karstenw.20160619132023.11">class DateElement:
    """implements the 'publish' API for a datetime.datetime

    Takes the tag name and the datetime to publish.

    Converts the datetime to RFC 2822 timestamp (4-digit year).
    """
    @others
</t>
<t tx="karstenw.20160619132023.12">def __init__(self, name, dt):
    self.name = name
    self.dt = dt
</t>
<t tx="karstenw.20160619132023.13">def publish(self, handler):
    _element(handler, self.name, _format_date(self.dt))
</t>
<t tx="karstenw.20160619132023.14">####

class Category:
    """Publish a category element"""
    @others
</t>
<t tx="karstenw.20160619132023.15">def __init__(self, category, domain = None):
    self.category = category
    self.domain = domain
</t>
<t tx="karstenw.20160619132023.16">def publish(self, handler):
    d = {}
    if self.domain is not None:
        d["domain"] = self.domain
    _element(handler, "category", self.category, d)

</t>
<t tx="karstenw.20160619132023.17">class Cloud:
    """Publish a cloud"""
    @others
</t>
<t tx="karstenw.20160619132023.18">def __init__(self, domain, port, path,
             registerProcedure, protocol):
    self.domain = domain
    self.port = port
    self.path = path
    self.registerProcedure = registerProcedure
    self.protocol = protocol
</t>
<t tx="karstenw.20160619132023.19">def publish(self, handler):
    _element(handler, "cloud", None, {
        "domain": self.domain,
        "port": str(self.port),
        "path": self.path,
        "registerProcedure": self.registerProcedure,
        "protocol": self.protocol})

</t>
<t tx="karstenw.20160619132023.2"># Could make this the base class; will need to add 'publish'
class WriteXmlMixin:
    @others
</t>
<t tx="karstenw.20160619132023.20">class Image:
    """Publish a channel Image"""
    element_attrs = {}
    @others
</t>
<t tx="karstenw.20160619132023.21">def __init__(self, url, title, link,
             width = None, height = None, description = None):
    self.url = url
    self.title = title
    self.link = link
    self.width = width
    self.height = height
    self.description = description
    
</t>
<t tx="karstenw.20160619132023.22">def publish(self, handler):
    handler.startElement("image", self.element_attrs)

    _element(handler, "url", self.url)
    _element(handler, "title", self.title)
    _element(handler, "link", self.link)

    width = self.width
    if isinstance(width, int):
        width = IntElement("width", width)
    _opt_element(handler, "width", width)
    
    height = self.height
    if isinstance(height, int):
        height = IntElement("height", height)
    _opt_element(handler, "height", height)

    _opt_element(handler, "description", self.description)

    handler.endElement("image")

</t>
<t tx="karstenw.20160619132023.23">class Guid:
    """Publish a guid

    Defaults to being a permalink, which is the assumption if it's
    omitted.  Hence strings are always permalinks.
    """
    @others
</t>
<t tx="karstenw.20160619132023.24">def __init__(self, guid, isPermaLink = 1):
    self.guid = guid
    self.isPermaLink = isPermaLink
</t>
<t tx="karstenw.20160619132023.25">def publish(self, handler):
    d = {}
    if self.isPermaLink:
        d["isPermaLink"] = "true"
    else:
        d["isPermaLink"] = "false"
    _element(handler, "guid", self.guid, d)

</t>
<t tx="karstenw.20160619132023.26">class TextInput:
    """Publish a textInput

    Apparently this is rarely used.
    """
    element_attrs = {}
    @others
</t>
<t tx="karstenw.20160619132023.27">def __init__(self, title, description, name, link):
    self.title = title
    self.description = description
    self.name = name
    self.link = link

</t>
<t tx="karstenw.20160619132023.28">def publish(self, handler):
    handler.startElement("textInput", self.element_attrs)
    _element(handler, "title", self.title)
    _element(handler, "description", self.description)
    _element(handler, "name", self.name)
    _element(handler, "link", self.link)
    handler.endElement("textInput")
    

</t>
<t tx="karstenw.20160619132023.29">class Enclosure:
    """Publish an enclosure"""
    @others
</t>
<t tx="karstenw.20160619132023.3">def write_xml(self, outfile, encoding = "iso-8859-1"):
    from xml.sax import saxutils
    handler = saxutils.XMLGenerator(outfile, encoding)
    handler.startDocument()
    self.publish(handler)
    handler.endDocument()

</t>
<t tx="karstenw.20160619132023.30">def __init__(self, url, length, type):
    self.url = url
    self.length = length
    self.type = type
</t>
<t tx="karstenw.20160619132023.31">def publish(self, handler):
    _element(handler, "enclosure", None,
             {"url": self.url,
              "length": str(self.length),
              "type": self.type,
              })

</t>
<t tx="karstenw.20160619132023.32">class Source:
    """Publish the item's original source, used by aggregators"""
    @others
</t>
<t tx="karstenw.20160619132023.33">def __init__(self, name, url):
    self.name = name
    self.url = url
</t>
<t tx="karstenw.20160619132023.34">def publish(self, handler):
    _element(handler, "source", self.name, {"url": self.url})

</t>
<t tx="karstenw.20160619132023.35">class SkipHours:
    """Publish the skipHours

    This takes a list of hours, as integers.
    """
    element_attrs = {}
    @others
</t>
<t tx="karstenw.20160619132023.36">def __init__(self, hours):
    self.hours = hours
</t>
<t tx="karstenw.20160619132023.37">def publish(self, handler):
    if self.hours:
        handler.startElement("skipHours", self.element_attrs)
        for hour in self.hours:
            _element(handler, "hour", str(hour))
        handler.endElement("skipHours")

</t>
<t tx="karstenw.20160619132023.38">class SkipDays:
    """Publish the skipDays

    This takes a list of days as strings.
    """
    element_attrs = {}
    @others
</t>
<t tx="karstenw.20160619132023.39">def __init__(self, days):
    self.days = days
</t>
<t tx="karstenw.20160619132023.4">def to_xml(self, encoding = "iso-8859-1"):
    f = StringIO()
    self.write_xml(f, encoding)
    return f.getvalue()


</t>
<t tx="karstenw.20160619132023.40">def publish(self, handler):
    if self.days:
        handler.startElement("skipDays", self.element_attrs)
        for day in self.days:
            _element(handler, "day", day)
        handler.endElement("skipDays")

</t>
<t tx="karstenw.20160619132023.41">class RSS2(WriteXmlMixin):
    """The main RSS class.

    Stores the channel attributes, with the "category" elements under
    ".categories" and the RSS items under ".items".
    """
    
    rss_attrs = {"version": "2.0"}
    element_attrs = {}
    @others
</t>
<t tx="karstenw.20160619132023.42">def __init__(self,
             title,
             link,
             description,

             language = None,
             copyright = None,
             managingEditor = None,
             webMaster = None,
             pubDate = None,  # a datetime, *in* *GMT*
             lastBuildDate = None, # a datetime
             
             categories = None, # list of strings or Category
             generator = _generator_name,
             docs = "http://blogs.law.harvard.edu/tech/rss",
             cloud = None,    # a Cloud
             ttl = None,      # integer number of minutes

             image = None,     # an Image
             rating = None,    # a string; I don't know how it's used
             textInput = None, # a TextInput
             skipHours = None, # a SkipHours with a list of integers
             skipDays = None,  # a SkipDays with a list of strings

             items = None,     # list of RSSItems
             ):
    self.title = title
    self.link = link
    self.description = description
    self.language = language
    self.copyright = copyright
    self.managingEditor = managingEditor

    self.webMaster = webMaster
    self.pubDate = pubDate
    self.lastBuildDate = lastBuildDate
    
    if categories is None:
        categories = []
    self.categories = categories
    self.generator = generator
    self.docs = docs
    self.cloud = cloud
    self.ttl = ttl
    self.image = image
    self.rating = rating
    self.textInput = textInput
    self.skipHours = skipHours
    self.skipDays = skipDays

    if items is None:
        items = []
    self.items = items

</t>
<t tx="karstenw.20160619132023.43">def publish(self, handler):
    handler.startElement("rss", self.rss_attrs)
    handler.startElement("channel", self.element_attrs)
    _element(handler, "title", self.title)
    _element(handler, "link", self.link)
    _element(handler, "description", self.description)

    self.publish_extensions(handler)
    
    _opt_element(handler, "language", self.language)
    _opt_element(handler, "copyright", self.copyright)
    _opt_element(handler, "managingEditor", self.managingEditor)
    _opt_element(handler, "webMaster", self.webMaster)

    pubDate = self.pubDate
    if isinstance(pubDate, datetime.datetime):
        pubDate = DateElement("pubDate", pubDate)
    _opt_element(handler, "pubDate", pubDate)

    lastBuildDate = self.lastBuildDate
    if isinstance(lastBuildDate, datetime.datetime):
        lastBuildDate = DateElement("lastBuildDate", lastBuildDate)
    _opt_element(handler, "lastBuildDate", lastBuildDate)

    for category in self.categories:
        if isinstance(category, basestring):
            category = Category(category)
        category.publish(handler)

    _opt_element(handler, "generator", self.generator)
    _opt_element(handler, "docs", self.docs)

    if self.cloud is not None:
        self.cloud.publish(handler)

    ttl = self.ttl
    if isinstance(self.ttl, int):
        ttl = IntElement("ttl", ttl)
    _opt_element(handler, "ttl", ttl)

    if self.image is not None:
        self.image.publish(handler)

    _opt_element(handler, "rating", self.rating)
    if self.textInput is not None:
        self.textInput.publish(handler)
    if self.skipHours is not None:
        self.skipHours.publish(handler)
    if self.skipDays is not None:
        self.skipDays.publish(handler)

    for item in self.items:
        item.publish(handler)

    handler.endElement("channel")
    handler.endElement("rss")

</t>
<t tx="karstenw.20160619132023.44">def publish_extensions(self, handler):
    # Derived classes can hook into this to insert
    # output after the three required fields.
    pass



</t>
<t tx="karstenw.20160619132023.45">class RSSItem(WriteXmlMixin):
    """Publish an RSS Item"""
    element_attrs = {}
    @others
</t>
<t tx="karstenw.20160619132023.46">def __init__(self,
             title = None,  # string
             link = None,   # url as string
             description = None, # string
             author = None,      # email address as string
             categories = None,  # list of string or Category
             comments = None,  # url as string
             enclosure = None, # an Enclosure
             guid = None,    # a unique string
             pubDate = None, # a datetime
             source = None,  # a Source
             ):
    
    if title is None and description is None:
        raise TypeError(
            "must define at least one of 'title' or 'description'")
    self.title = title
    self.link = link
    self.description = description
    self.author = author
    if categories is None:
        categories = []
    self.categories = categories
    self.comments = comments
    self.enclosure = enclosure
    self.guid = guid
    self.pubDate = pubDate
    self.source = source
    # It sure does get tedious typing these names three times...

</t>
<t tx="karstenw.20160619132023.47">def publish(self, handler):
    handler.startElement("item", self.element_attrs)
    _opt_element(handler, "title", self.title)
    _opt_element(handler, "link", self.link)
    self.publish_extensions(handler)
    _opt_element(handler, "description", self.description)
    _opt_element(handler, "author", self.author)

    for category in self.categories:
        if isinstance(category, basestring):
            category = Category(category)
        category.publish(handler)
    
    _opt_element(handler, "comments", self.comments)
    if self.enclosure is not None:
        self.enclosure.publish(handler)
    _opt_element(handler, "guid", self.guid)

    pubDate = self.pubDate
    if isinstance(pubDate, datetime.datetime):
        pubDate = DateElement("pubDate", pubDate)
    _opt_element(handler, "pubDate", pubDate)

    if self.source is not None:
        self.source.publish(handler)
    
    handler.endElement("item")

</t>
<t tx="karstenw.20160619132023.48">def publish_extensions(self, handler):
    # Derived classes can hook into this to insert
    # output after the title and link elements
    pass
</t>
<t tx="karstenw.20160619132023.5">def _element(handler, name, obj, d = {}):
    if isinstance(obj, basestring) or obj is None:
        # special-case handling to make the API easier
        # to use for the common case.
        handler.startElement(name, d)
        if obj is not None:
            handler.characters(obj)
        handler.endElement(name)
    else:
        # It better know how to emit the correct XML.
        obj.publish(handler)

</t>
<t tx="karstenw.20160619132023.6">def _opt_element(handler, name, obj):
    if obj is None:
        return
    _element(handler, name, obj)


</t>
<t tx="karstenw.20160619132023.7">def _format_date(dt):
    """convert a datetime into an RFC 822 formatted date

    Input date must be in GMT.
    """
    # Looks like:
    #   Sat, 07 Sep 2002 00:00:01 GMT
    # Can't use strftime because that's locale dependent
    #
    # Isn't there a standard way to do this for Python?  The
    # rfc822 and email.Utils modules assume a timestamp.  The
    # following is based on the rfc822 module.
    return "%s, %02d %s %04d %02d:%02d:%02d GMT" % (
            ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"][dt.weekday()],
            dt.day,
            ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
             "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][dt.month-1],
            dt.year, dt.hour, dt.minute, dt.second)

        
</t>
<t tx="karstenw.20160619132023.8">##
# A couple simple wrapper objects for the fields which
# take a simple value other than a string.
class IntElement:
    """implements the 'publish' API for integers

    Takes the tag name and the integer value to publish.
    
    (Could be used for anything which uses str() to be published
    to text for XML.)
    """
    element_attrs = {}
    @others
</t>
<t tx="karstenw.20160619132023.9">def __init__(self, name, val):
    self.name = name
    self.val = val
</t>
<t tx="karstenw.20160619132031.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20160619132037.1">"""
Script for building the example.

Usage:
    python setup.py py2app
"""
import os

from distutils.core import setup
import py2app

import CactusVersion

iconpath = "+icon/large/"

import CactusDocumentTypes



appname = CactusVersion.appname
appnameshort = CactusVersion.appnameshort

copyright = CactusVersion.copyright

version = CactusVersion.version


infostr = appname + ' ' + version + ' ' + copyright


setup(
    app=[{

        # 'script': "Cactus.py",
        'script': "CactusMain.py",

        'plist':{
            'CFBundleGetInfoString': infostr,
            'CFBundleIdentifier': 'org.kw.Cactus',
            'CFBundleShortVersionString': version,
            'CFBundleDisplayName': appnameshort,
            'CFBundleName': appnameshort,
            'CFBundleSignature': 'KWCs',
            'CFBundleDocumentTypes': [
                {
                    'CFBundleTypeExtensions': CactusDocumentTypes.CactusOPMLFileExtensions,
                    'CFBundleTypeIconFile': 'OPMLDocument.icns',
                    'CFBundleTypeName': CactusDocumentTypes.CactusOPMLType,
                    'CFBundleTypeOSTypes': CactusDocumentTypes.CactusOPMLOSTypes,
                    'CFBundleTypeRole': 'Editor',
                    'NSDocumentClass': u'CactusOutlineDocument',
                },
                {
                    'CFBundleTypeExtensions': CactusDocumentTypes.CactusRSSFileExtensions,
                    'CFBundleTypeIconFile': 'RSSDocument.icns',
                    'CFBundleTypeName': CactusDocumentTypes.CactusRSSType,
                    'CFBundleTypeOSTypes': CactusDocumentTypes.CactusRSSOSTypes,
                    'CFBundleTypeRole': 'Editor',
                    'NSDocumentClass': u'CactusOutlineDocument',
                },
                {
                    'CFBundleTypeExtensions': CactusDocumentTypes.CactusXMLFileExtensions,
                    'CFBundleTypeIconFile': 'XMLDocument.icns',
                    'CFBundleTypeName': CactusDocumentTypes.CactusXMLType,
                    'CFBundleTypeOSTypes': CactusDocumentTypes.CactusXMLOSTypes,
                    'CFBundleTypeRole': 'Editor',
                    'NSDocumentClass': u'CactusOutlineDocument',
                },
                {
                    'CFBundleTypeExtensions': CactusDocumentTypes.CactusHTMLFileExtensions,
                    'CFBundleTypeIconFile': 'HTMLDocument.icns',
                    'CFBundleTypeName': CactusDocumentTypes.CactusHTMLType,
                    'CFBundleTypeOSTypes': CactusDocumentTypes.CactusHTMLOSTypes,
                    'CFBundleTypeRole': 'Editor',
                    'NSDocumentClass': u'CactusOutlineDocument',
                },
                {
                    'CFBundleTypeExtensions': CactusDocumentTypes.CactusPLISTFileExtensions,
                    'CFBundleTypeIconFile': 'PLISTDocument.icns',
                    'CFBundleTypeName': CactusDocumentTypes.CactusPLISTType,
                    'CFBundleTypeOSTypes': CactusDocumentTypes.CactusPLISTOSTypes,
                    'CFBundleTypeRole': 'Editor',
                    'NSDocumentClass': u'CactusOutlineDocument',
                },
                {
                    # 'CFBundleTypeExtensions': CactusDocumentTypes.CactusIMLFileExtensions,
                    'CFBundleTypeIconFile': 'IMLDocument.icns',
                    'CFBundleTypeName': CactusDocumentTypes.CactusIMLType,
                    'CFBundleTypeOSTypes': CactusDocumentTypes.CactusIMLOSTypes,
                    # 'CFBundleTypeRole': 'Editor',
                    'CFBundleTypeRole': 'Viewer',
                    'NSDocumentClass': u'CactusOutlineDocument',
                }
            ],
            'LSHasLocalizedDisplayName': False,
            'NSAppleScriptEnabled': False,
            'NSHumanReadableCopyright': copyright}}],

    data_files=["English.lproj/MainMenu.nib",
                "English.lproj/OutlineEditor.nib",
                "English.lproj/TableEditor.nib",
                "English.lproj/NodeEditor.nib",
                "English.lproj/OpenURL.nib",
                "English.lproj/CalendarCreator.nib",
                "English.lproj/OpenAsAccessoryView.nib",
                "English.lproj/Preferences.nib",
                iconpath + "OPMLDocument.icns",
                iconpath + "XMLDocument.icns",
                iconpath + "RSSDocument.icns",
                iconpath + "PLISTDocument.icns",
                iconpath + "iXMLDocument.icns",
                iconpath + "Cowskull.icns" ],

    options={
        'py2app':{
            'iconfile': iconpath + 'Cowskull.icns',
            'packages' : ['lxml'],
            'frameworks' : ['/usr/local/lib/libxml2.2.dylib',
                            '/usr/local/lib/libxslt.1.dylib',
                            '/usr/local/lib/libexslt.0.dylib']
          }
    }
)
</t>
<t tx="karstenw.20160619132048.1">@language shell
open /Users/karstenwo/python/pyobjc/+ideen/outliner_kw/Cactus-git/plan.oo3
open /Users/karstenwo/python/pyobjc/+ideen/outliner_kw/Cactus-git/Outline.py
open /Users/karstenwo/python/pyobjc/+ideen/outliner_kw/Cactus-git/Cactus.py
open /Users/karstenwo/python/pyobjc/+ideen/outliner_kw/Cactus-git/opml.py
open /Users/karstenwo/python/pyobjc/+ideen/outliner_kw/Cactus-git/AppKitKeys
open "/Volumes/Luna/themen/cocoa/Cocoa Browser/Cocoa Browser SN 2.51/Cocoa Browser.app"
open /Users/karstenwo/python/pyobjc/+ideen/outliner_kw/Cactus-git/English.lproj/TableEditor.nib
open /Users/karstenwo/python/pyobjc/+ideen/outliner_kw/Cactus-git/English.lproj/OutlineEditor.nib
# open /Users/karstenwo/python/pyobjc/+ideen/outliner_kw/Cactus-git/English.lproj/NodeEditor.nib
open /Users/karstenwo/python/pyobjc/+ideen/outliner_kw/Cactus-git/English.lproj/MainMenu.nib
</t>
<t tx="karstenw.20160619132221.1">@language shell
#!/bin/sh

rm -Rf ./build/*
rm -Rf ./dist/*

/usr/bin/env python setup.py py2app -O2 -g -x

mkdir -p ../Cactus-opml-Outliner-binaries/Cactus_v000

cp -p ./license_PyRSS2Gen.txt ../Cactus-opml-Outliner-binaries/Cactus_v000/
cp -p ./licence_feedreader.txt ../Cactus-opml-Outliner-binaries/Cactus_v000/
cp -p ./licenses_lxml.txt ../Cactus-opml-Outliner-binaries/Cactus_v000/
cp -p ./LICENSE ../Cactus-opml-Outliner-binaries/Cactus_v000/

# markdown README.md &gt;README.html
# markdown_py -o html5 -f README.html README.md
mmd README.md
cp README.html  ../Cactus-opml-Outliner-binaries/Cactus_v000/
cp README.md  ../Cactus-opml-Outliner-binaries/Cactus_v000/

rm -Rf ../Cactus-opml-Outliner-binaries/Cactus_v000/Cactus.app

mv ./dist/Cactus.app ../Cactus-opml-Outliner-binaries/Cactus_v000/
</t>
<t tx="karstenw.20160619132244.1">@nocolor
Copyright (c) 2010-2012 Kurt McKee &lt;contactme@kurtmckee.org&gt;
Copyright (c) 2002-2008 Mark Pilgrim
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
</t>
<t tx="karstenw.20160619132253.1">@nocolor
(This is the BSD license, based on the template at
   http://www.opensource.org/licenses/bsd-license.php )

Copyright (c) 2003, Dalke Scientific Software, LLC

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

  * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in
    the documentation and/or other materials provided with the
    distribution.

  * Neither the name of the Dalke Scientific Softare, LLC, Andrew
    Dalke, nor the names of its contributors may be used to endorse or
    promote products derived from this software without specific prior
    written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</t>
<t tx="karstenw.20160619132304.1">@nocolor
lxml is copyright Infrae and distributed under the BSD license (see
doc/licenses/BSD.txt), with the following exceptions:

Some code, such a selftest.py, selftest2.py and
src/lxml/_elementpath.py are derived from ElementTree and
cElementTree. See doc/licenses/elementtree.txt for the license text.

lxml.cssselect and lxml.html are copyright Ian Bicking and distributed
under the BSD license (see doc/licenses/BSD.txt).

test.py, the test-runner script, is GPL and copyright Shuttleworth
Foundation. See doc/licenses/GPL.txt. It is believed the unchanged
inclusion of test.py to run the unit test suite falls under the
"aggregation" clause of the GPL and thus does not affect the license
of the rest of the package.

The doctest.py module is taken from the Python library and falls under
the PSF Python License.

The isoschematron implementation uses several XSL and RelaxNG resources:
 * The (XML syntax) RelaxNG schema for schematron, copyright International
   Organization for Standardization (see 
   src/lxml/isoschematron/resources/rng/iso-schematron.rng for the license
   text)
 * The skeleton iso-schematron-xlt1 pure-xslt schematron implementation
   xsl stylesheets, copyright Rick Jelliffe and Academia Sinica Computing
   Center, Taiwan (see the xsl files here for the license text: 
   src/lxml/isoschematron/resources/xsl/iso-schematron-xslt1/)
 * The xsd/rng schema schematron extraction xsl transformations are unlicensed
   and copyright the respective authors as noted (see 
   src/lxml/isoschematron/resources/xsl/RNG2Schtrn.xsl and
   src/lxml/isoschematron/resources/xsl/XSD2Schtrn.xsl)
</t>
<t tx="karstenw.20160619132317.1">@language unknown_language
CHANGES</t>
<t tx="karstenw.20160619132327.1">@nocolor
Cactus is released under the following license:


Copyright (c) 2011-2013 Karsten Wolf
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
</t>
<t tx="karstenw.20160619132335.1">@nocolor




debug: 
	# build the app in debug mode
	rm -Rf ./build/*
	rm -Rf ./dist/*
	python setup.py py2app -A

release:
	# build the app in release mode
	rm -Rf ./build/*
	rm -Rf ./dist/*
	python setup.py py2app
	mkdir -p Cactus_v000
	
	# copy the additional licenses
	cp -p ./license_PyRSS2Gen.txt ./Cactus_v000/
	cp -p ./licence_feedreader.txt ./Cactus_v000/
	cp -p ./licenses_lxml.txt ./Cactus_v000/
	cp -p ./LICENSE ./Cactus_v000/
	
	# create a readable html from markdown
	
	# markdown README.md &gt;README.html
	# markdown_py -o html5 -f ./Cactus_v000/README.html README.md
	# DO NOT USE mmd !! It's a wrapper that kills the reported options
	# mmd -o ./Cactus_v000/README.html README.md
	multimarkdown -o ./Cactus_v000/README.html README.md

	cp README.md  ./Cactus_v000/
	
	rm -Rf ./Cactus_v000/Cactus.app
	
	mv ./dist/Cactus.app ./Cactus_v000/
	
	# move the release folder to the binary archive
	mv Cactus_v000 ../Cactus-opml-Outliner-binaries/

edit:
	edit Cactus*.py Makefile setup.py
</t>
<t tx="karstenw.20160619192706.1"></t>
<t tx="karstenw.20160619192840.1"></t>
<t tx="karstenw.20160619192849.1"></t>
<t tx="karstenw.20160619193218.1"></t>
<t tx="karstenw.20160619200133.1"></t>
</tnodes>
</leo_file>
